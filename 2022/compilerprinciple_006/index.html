<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>语法分析 3 - iris</title><meta name="Description" content="GinShio | 编译原理第四章 4.5 4.6 4.7 读书笔记"><meta property="og:title" content="语法分析 3" />
<meta property="og:description" content="GinShio | 编译原理第四章 4.5 4.6 4.7 读书笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.ginshio.org/2022/compilerprinciple_006/" /><meta property="og:image" content="https://blog.ginshio.org/avatar.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-20T16:25:13+08:00" />
<meta property="article:modified_time" content="2022-04-30T15:09:46+08:00" /><meta property="og:site_name" content="iris | GinShio的个人博客" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.ginshio.org/avatar.webp"/>

<meta name="twitter:title" content="语法分析 3"/>
<meta name="twitter:description" content="GinShio | 编译原理第四章 4.5 4.6 4.7 读书笔记"/>
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2022/compilerprinciple_006/" /><link rel="prev" href="https://blog.ginshio.org/2022/compilerprinciple_005/" /><link rel="next" href="https://blog.ginshio.org/2022/flex_and_bison/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/style.min.cd14de6b7577483a378a3e7b1d8d4d22e9116704e99988548443184415b6e7ea3d5f86d181e92e8d979297f4dc91299a.css" integrity="sha384-zRTea3V3SDo3ij57HY1NIukRZwTpmYhUhEMYRBW25&#43;o9X4bRgekujZeSl/TckSma"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <meta name="google-site-verification" content="fbzw9fQcZyEFrrrUtxLfzYW-qhZ5TMEZKHHSp9NeLBw" /><meta name="msvalidate.01" content="EC9CEC799D42793C414AE7BDB0D0205C" /><meta name="yandex-verification" content="c0b808dd3e49f730" /><meta name="baidu-site-verification" content="code-RhPhu2ccLc" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "语法分析 3",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2022\/compilerprinciple_006\/"
        },"image": ["https:\/\/blog.ginshio.org\/screenshot.png"],"genre": "posts","keywords": "Note, DragonBook, SyntacticAnalysis","wordcount":  9494 ,
        "url": "https:\/\/blog.ginshio.org\/2022\/compilerprinciple_006\/","datePublished": "2022-04-20T16:25:13+08:00","dateModified": "2022-04-30T15:09:46+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/avatar.webp"},"authors": [{
                        "@type": "Person",
                        "name": "GinShio"                    
                    }],"description": "GinShio | 编译原理第四章 4.5 4.6 4.7 读书笔记"
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark');}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#移入-归约">移入-归约</a>
      <ul>
        <li><a href="#归约">归约</a></li>
        <li><a href="#句柄剪枝">句柄剪枝</a></li>
        <li><a href="#移入-规约语法分析技术">移入-规约语法分析技术</a></li>
        <li><a href="#移入-归约语法分析中的冲突">移入-归约语法分析中的冲突</a></li>
      </ul>
    </li>
    <li><a href="#简单-lr-技术">简单 LR 技术</a>
      <ul>
        <li><a href="#为什么使用-lr-语法分析器">为什么使用 LR 语法分析器</a></li>
        <li><a href="#项和-lr--0--自动机">项和 LR(0) 自动机</a>
          <ul>
            <li><a href="#项集的闭包">项集的闭包</a></li>
            <li><a href="#goto-函数">GOTO 函数</a></li>
            <li><a href="#lr--0--自动机的用法">LR(0) 自动机的用法</a></li>
          </ul>
        </li>
        <li><a href="#lr-语法分析算法">LR 语法分析算法</a>
          <ul>
            <li><a href="#lr-语法分析表的结构">LR 语法分析表的结构</a></li>
            <li><a href="#lr-语法分析器的行为">LR 语法分析器的行为</a></li>
          </ul>
        </li>
        <li><a href="#构造-slr-语法分析表">构造 SLR 语法分析表</a></li>
      </ul>
    </li>
    <li><a href="#更强大的-lr-语法分析器">更强大的 LR 语法分析器</a>
      <ul>
        <li><a href="#规范-lr--1--项">规范 LR(1) 项</a></li>
        <li><a href="#构造-lr--1--项集">构造 LR(1) 项集</a></li>
        <li><a href="#规范-lr--1--语法分析表">规范 LR(1) 语法分析表</a></li>
        <li><a href="#构造-lalr-语法分析表">构造 LALR 语法分析表</a></li>
        <li><a href="#高效构造-lalr-语法分析表">高效构造 LALR 语法分析表</a></li>
      </ul>
    </li>
    <li><a href="#使用二义性文法">使用二义性文法</a>
      <ul>
        <li><a href="#用优先级和结合性解决冲突">用优先级和结合性解决冲突</a></li>
        <li><a href="#悬空-else-的二义性">悬空-else 的二义性</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">语法分析 3</h1><h2 class="single-subtitle">自底向上语法分析</h2><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/compilerprinciple/"><i class="far fa-folder fa-fw"></i>CompilerPrinciple</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E9%BE%99%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="far fa-list-alt fa-fw"></i>龙书学习笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="04-20">04-20</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="04-30">04-30</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 9494 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 19 分钟&nbsp;</div>
        </div><div class="details series-nav open">
                                <div class="details-summary series-title">
                                    <span>系列 - 龙书学习笔记</span>
                                    <span><i class="details-icon fas fa-angle-right"></i></span>
                                </div>
                                <div class="details-content series-content">
                                    <nav>
                                        <ul>
                                                    <li><a href="/2020/compilerprinciple_001/">编译器与程序设计语言</a></li>
                                                    <li><a href="/2020/compilerprinciple_002/">词法分析 1</a></li>
                                                    <li><a href="/2020/compilerprinciple_003/">词法分析 2</a></li>
                                                    <li><a href="/2020/compilerprinciple_004/">语法分析 1</a></li>
                                                    <li><a href="/2022/compilerprinciple_005/">语法分析 2</a></li><li><span class="active">语法分析 3</span></li>
                                                    <li><a href="/2022/compilerprinciple_007/">语法制导翻译</a></li>
                                                    <li><a href="/2022/compilerprinciple_008/">中间代码生成</a></li></ul>
                                    </nav>
                                </div>
                            </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#移入-归约">移入-归约</a>
      <ul>
        <li><a href="#归约">归约</a></li>
        <li><a href="#句柄剪枝">句柄剪枝</a></li>
        <li><a href="#移入-规约语法分析技术">移入-规约语法分析技术</a></li>
        <li><a href="#移入-归约语法分析中的冲突">移入-归约语法分析中的冲突</a></li>
      </ul>
    </li>
    <li><a href="#简单-lr-技术">简单 LR 技术</a>
      <ul>
        <li><a href="#为什么使用-lr-语法分析器">为什么使用 LR 语法分析器</a></li>
        <li><a href="#项和-lr--0--自动机">项和 LR(0) 自动机</a>
          <ul>
            <li><a href="#项集的闭包">项集的闭包</a></li>
            <li><a href="#goto-函数">GOTO 函数</a></li>
            <li><a href="#lr--0--自动机的用法">LR(0) 自动机的用法</a></li>
          </ul>
        </li>
        <li><a href="#lr-语法分析算法">LR 语法分析算法</a>
          <ul>
            <li><a href="#lr-语法分析表的结构">LR 语法分析表的结构</a></li>
            <li><a href="#lr-语法分析器的行为">LR 语法分析器的行为</a></li>
          </ul>
        </li>
        <li><a href="#构造-slr-语法分析表">构造 SLR 语法分析表</a></li>
      </ul>
    </li>
    <li><a href="#更强大的-lr-语法分析器">更强大的 LR 语法分析器</a>
      <ul>
        <li><a href="#规范-lr--1--项">规范 LR(1) 项</a></li>
        <li><a href="#构造-lr--1--项集">构造 LR(1) 项集</a></li>
        <li><a href="#规范-lr--1--语法分析表">规范 LR(1) 语法分析表</a></li>
        <li><a href="#构造-lalr-语法分析表">构造 LALR 语法分析表</a></li>
        <li><a href="#高效构造-lalr-语法分析表">高效构造 LALR 语法分析表</a></li>
      </ul>
    </li>
    <li><a href="#使用二义性文法">使用二义性文法</a>
      <ul>
        <li><a href="#用优先级和结合性解决冲突">用优先级和结合性解决冲突</a></li>
        <li><a href="#悬空-else-的二义性">悬空-else 的二义性</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>一个自底向上的语法分析过程对应于为输入字符串构造语法分析树的过程，它从叶节点开始开始逐渐向上构造。虽然大部分编译器前端不会显示构造语法分析树，而是直接翻译，但自底向上构建有些像构建语法分析树。</p>
<p>移入归约语法分析是自底向上语法分析的通用框架。LR 文法就是采用移入-归约语法分析的文法。</p>
<h2 id="移入-归约" class="headerLink">
    <a href="#%e7%a7%bb%e5%85%a5-%e5%bd%92%e7%ba%a6" class="header-mark"></a>移入-归约</h2><h3 id="归约" class="headerLink">
    <a href="#%e5%bd%92%e7%ba%a6" class="header-mark"></a>归约</h3><p>将语法分析过程，看作输入串 w <code>归约</code> (reduction) 为文法开始符号的过程， 在归约步骤中，一个与某产生式体相匹配的特定子串被替换为该产生式头部的非终结符。</p>
<p>自底向上语法分析过程中，最关键的是何时进行归约，以及应用哪个产生式进行归约。</p>
<p>当然归约是推导步骤的反向操作，不过可以是 <strong>最右</strong> 推导。</p>
<h3 id="句柄剪枝" class="headerLink">
    <a href="#%e5%8f%a5%e6%9f%84%e5%89%aa%e6%9e%9d" class="header-mark"></a>句柄剪枝</h3><p>对输入进行从左向右扫描，并在扫描过程中进行自底向上语法分析，就可以反向构造出最右推导。简单地说，<strong>句柄</strong> 是和某个产生式体匹配的子串，对它的归约代表了相应最右推导中的一个反向步骤。</p>
<p>如果有 \(\textit{S}\xRightarrow[rm]{*}\alpha\textit{A}w\xRightarrow[rm]{}\alpha\beta{}w\)，那么紧跟 \(\alpha\) 的产生式 \(\textit{A}\rightarrow\beta\) 是 \(\alpha\beta{}w\) 的一个 <strong>句柄</strong> (handle)。换句话说，最右句型 \(\gamma\) 的一个句柄是满足以下条件的产生式 \(\textit{A}\rightarrow\beta\) 及串
\(\beta\) 在 \(\gamma\) 中出现的位置：将这个位置上的 \(\beta\) 替换为 <em>A</em> 之后得到的串是
\(\gamma\) 的某个最右推导序列中出现在位于 \(\gamma\) 之前的最右句型。</p>
<figure><img src="/images/alpha-beta-w-parsing-tree-handle.svg"/>
</figure>

<p>句柄右边的串 w 一定只包含终结符，即产生式体 \(\beta\) 称为一个句柄 (而不是
\(\textit{A}\rightarrow\beta\))，如果文法有二义性时可能存在多个最右推导，但无二义性的文法有且仅有一个句柄。通过<strong>句柄剪枝</strong>可以得到一个反向的最右推导。</p>
<h3 id="移入-规约语法分析技术" class="headerLink">
    <a href="#%e7%a7%bb%e5%85%a5-%e8%a7%84%e7%ba%a6%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e6%8a%80%e6%9c%af" class="header-mark"></a>移入-规约语法分析技术</h3><p>该语法分析使用栈来保存符号，并用一个输入缓冲区来存放将要进行语法分析的其余符号。句柄在被识别之前，总是出现在栈顶的。</p>
<p>在栈中依然用 \(\$\) 标记栈底位置，在从左到右扫描输入串时，语法分析器将零个或多个输入符号移动到栈顶，直到对栈顶的一个文法符号串 \(\beta\) 进行归约为止。语法分析器将不断重复这个过程，直到检测到错误，或栈中包含了开始符号且输入缓冲区为空为止。此时宣告语法分析完成。</p>
<p>语法分析器主要由四个动作构成</p>
<dl>
<dt>移入 (shift)</dt>
<dd>将下一个输入符号移到栈顶</dd>
<dt>归约 (reduce)</dt>
<dd>被归约的符号串的右端必然是栈顶，语法分析器在栈中确定这个栈的左端，并决定用哪个非终结符来替换这个串</dd>
<dt>接受 (accept)</dt>
<dd>语法分析完成</dd>
<dt>报错 (error)</dt>
<dd>发现一个语法错误，调用错误恢复过程</dd>
</dl>
<p>使用栈主要是因为在语法分析过程中有个重要的性质：<strong>句柄总出现在栈顶，绝不会出现在栈中</strong>。</p>
<h3 id="移入-归约语法分析中的冲突" class="headerLink">
    <a href="#%e7%a7%bb%e5%85%a5-%e5%bd%92%e7%ba%a6%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e4%b8%ad%e7%9a%84%e5%86%b2%e7%aa%81" class="header-mark"></a>移入-归约语法分析中的冲突</h3><p>某些上下文无关文法无法使用移入-归约语法分析技术，对于这样的文法可能出现如下
configuration：虽然知道栈中的所有内容以及接下来的 k 个输入符号，</p>
<dl>
<dt>移入/归约冲突</dt>
<dd>无法判断应该进行移动还是归约</dd>
<dt>归约/归约冲突</dt>
<dd>无法在多个可能的归约方法中原则正确的归约</dd>
</dl>
<p>简单的来看一个有关过程调用和数组引用的文法</p>
\[
\begin{align}
stmt&\rightarrow\textbf{id}\ \texttt{(}\ parameter\_list\ \texttt{)}\\
stmt&\rightarrow expr\ \texttt{::=}\ expr\\
parameter\_list&\rightarrow parameter\_list \ ,\ parameter\\
parameter\_list&\rightarrow parameter\\
parameter&\rightarrow \textbf{id}\\
expr&\rightarrow \textbf{id} \ \texttt{(}\ expr\_list \ \texttt{)}\\
expr&\rightarrow \textbf{id}\\
expr\_list&\rightarrow expr\_list \ ,\ expr\\
expr\_list&\rightarrow expr
\end{align}\]

<p>对一个以 \(p(i, j)\) 开头的语句以词法单元流 \(\textbf{id}(\textbf{id},
\textbf{id})\) 的方式输入词法分析器。在处于如下 configuration 时，</p>
<p>栈 \(\cdots \textbf{id} ( \textbf{id}\)，输入 \(, \textbf{id} )\cdots\)</p>
<p>此时应该归约栈顶的 <strong>id</strong>，但选用哪个产生式呢？如果：</p>
<ul>
<li>p 是一个过程，那么正确的选择是产生式 <code>5</code></li>
<li>p 是一个数组，那么正确的选择是产生式 <code>7</code></li>
</ul>
<p>这将产生归约/归约冲突。</p>
<p>这必须在 p 的声明中来确定符号表中的信息。相对简单地方法是，将产生式 <code>1</code> 中的词法单元 <strong>id</strong> 改为 <strong>procid</strong>，使用更加复杂的词法分析器，在识别到过程名字的词素时返回词法单元名 <strong>procid</strong>。</p>
<p>可以发现，移入-归约语法分析技术可以使用栈中离栈顶较远的信息来引导语法分析过程。</p>
<h2 id="简单-lr-技术" class="headerLink">
    <a href="#%e7%ae%80%e5%8d%95-lr-%e6%8a%80%e6%9c%af" class="header-mark"></a>简单 LR 技术</h2><p>与 LL(1) 技术类似，<code>LR(k)</code> 技术即从左向右扫描的最右推导过程，语法分析决定最多向前看 k 个字符。</p>
<p>最简单的移入-规约语法分析方法被称为 <code>SLR</code> (简单 LR 技术)。</p>
<h3 id="为什么使用-lr-语法分析器" class="headerLink">
    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8-lr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8" class="header-mark"></a>为什么使用 LR 语法分析器</h3><p>LR 分析器是表格驱动的，与迭代 LL 语法分析器类似。并且只要存在从左到右的移入-归约语法分析器，它总能在某文法的最右句型的句柄出现在栈顶时识别出句柄，那么这个文法是
LR 的。</p>
<p>LR 语法分析技术的吸引力如下：</p>
<ul>
<li>对几乎所有的程序设计语言都糟，只要能写出该构造的上下文无关文法，就能构造出识别该构造的 LR 语法分析器。确实存在非 LR 的上下文无关文法，但一般来说构造都可以避免这样的文法。</li>
<li>LR 语法分析方法是已知最通用的无回溯移入-归约方法，并且实现可以和其他更原始的移入-归约方法一样高效。</li>
<li>一个 LR 语法分析器可以在对输入进行从左到右扫描时，尽可能早地检测到错误。</li>
<li>可以使用 LR 方法进行语法分析的文法类是可以使用预测方法或 LL 方法进行语法分析的文法类的真超集。因此 LR 文法能够比 LL 文法描述更多的程序设计语言。
<ul>
<li><code>LR(k)</code> 文法是，当在一个最右句型中看到某个产生式的右部时，再向前看 k
个符号就可以决定是否使用这个产生式进行归约</li>
<li><code>LL(k)</code> 文法是，决定是否使用某个产生式时，只能向前看该产生式右部推导出的串的前 k 个符号</li>
</ul>
</li>
</ul>
<p>LR 方法的主要缺点是，为一个典型的程序设计语言文法手工构造 LR 分析器的工作量非常大。因此有很多通用的 LR 语法分析生成器的工具诞生，简化了 LR 分析器构造的工作量。</p>
<h3 id="项和-lr--0--自动机" class="headerLink">
    <a href="#%e9%a1%b9%e5%92%8c-lr--0--%e8%87%aa%e5%8a%a8%e6%9c%ba" class="header-mark"></a>项和 LR(0) 自动机</h3><p>那么一个语法分析器怎么知道何时移入、何时归约的呢？</p>
<p>一个 IR 语法分析器通过维护一些状态，用这些状态来表明我们在语法分析过程中所处的位置，从而做出移入-归约决定。这些状态代表了<strong>项</strong> (item) 的集合。一个文法 G 的一个
LR (0) 项是 G 的一个产生式再加上一个位于它的体中某处的点。因此，产生式
\(\textit{A}\rightarrow\textit{XYZ}\) 产生了四个项：</p>
<p>\[\begin{aligned}
\textit{A} &amp;\rightarrow \cdot\textit{XYZ}\\
\textit{A} &amp;\rightarrow \textit{X}\cdot\textit{YZ}\\
\textit{A} &amp;\rightarrow \textit{XY}\cdot\textit{Z}\\
\textit{A} &amp;\rightarrow \textit{XYZ}\cdot
\end{aligned}\]</p>
<p>产生式 \(\textit{A}\rightarrow\varepsilon\) 只生成一个项 \(\textit{A}\rightarrow\cdot\) 。</p>
<p>一个称为<strong>规范 LR(0) 项集族</strong>的一组项集提供了构建一个确定有穷自动机的基础，该自动机用于做出语法分析决定，这样的自动机被称为 LR(0) 自动机。这个自动机的每个状态代表了规范 LR(0) 项集族中的一个项集。</p>
<p>为了构造一个文法的规范 LR(0) 项集族，我们定义了一个增广文法和两个函数 <code>CLOSURE</code>
和 <code>GOTO</code>。如果 G 是以 S 为开始符号的文法，那么 G 的增广文法 \(\textit{G}^{&rsquo;}\)
就是在 G 中加上新的开始符号 \(\textit{S}^{&rsquo;}\) 和产生式
\(\textit{S}^{&rsquo;}\rightarrow\textit{S}\) 的文法。引入新的产生式的目的是告诉文法分析器何时应该停止语法分析并宣称接受输入符号串。</p>
<p>对于之前反复提到的示例 <strong>id</strong> <code>+</code> <strong>id</strong> <code>*</code> <strong>id</strong>，可以构造出如下自动机。</p>
<figure><img src="/images/LR-0-automachine-example.svg"/>
</figure>

<h4 id="项集的闭包" class="headerLink">
    <a href="#%e9%a1%b9%e9%9b%86%e7%9a%84%e9%97%ad%e5%8c%85" class="header-mark"></a>项集的闭包</h4><p>如果 <em>I</em> 是文法 G 的一个项集，那么 \(\texttt{CLOSURE}(\textit{I})\) 就是根据以下两个规则从 <em>I</em> 构造得到的：</p>
<ol>
<li>将 <em>I</em> 中的各个项加入到 \(\texttt{CLOSURE}(\textit{I})\) 中</li>
<li>如果 \(\textit{A}\rightarrow\alpha\cdot\textit{B}\beta\) 在 \(\texttt{CLOSURE}(\textit{I})\) 中，
\(\textit{B}\rightarrow\gamma\) 是一个产生式，并且项 \(\textit{B}\rightarrow\cdot\gamma\) 不在
\(\texttt{CLOSURE}(\textit{I})\) 中，就将这个项加入其中。不断应用这个规则，直到没有新项可以加入 \(\texttt{CLOSURE}(\textit{I})\) 中为止。</li>
</ol>
<p>closure 可以按照以下方式计算。函数 closure 可以添加一个 added 数组来方便实现，该数组下标是 G 的非终结符，当各个 B 的产生式 \(\textit{B}\rightarrow\gamma\) 加入对应的项
\(\textit{B}\rightarrow\cdot\gamma\) 时，<code>added[B]</code> 被设置为 <strong>true</strong>。</p>
<div class="verse">
<p>SetOfItems CLOSURE(<em>I</em>) {<br />
    <em>J</em> = <em>I</em>;<br />
    <strong>repeat</strong><br />
        <strong>for</strong> (<em>J</em> 中的每个项 \(\textit{A}\rightarrow\alpha\cdot\textit{B}\beta\))<br />
            <strong>for</strong> (<em>G</em> 的每个产生式 \(\textit{B}\rightarrow\gamma\))<br />
                <strong>if</strong> (项 \(\textit{B}\rightarrow\cdot\gamma\) 不在 <em>G</em> 中)<br />
                    将 \(\textit{B}\rightarrow\cdot\gamma\) 添加到 <em>J</em> 中;<br />
    <strong>until</strong> 没有可以被加入到 <em>J</em> 中的项;<br />
    <strong>return</strong> <em>J</em>;<br />
}<br /></p>
</div>
<p>如果点在最左端的产生式 <em>B</em> 被加入 <em>I</em> 中，那么所有 <em>B</em> 的产生式都会被加入 <em>I</em> 的闭包中。因此在某些情况下，不需要真的将那些被 \(\texttt{CLOSURE}\) 函数加入到 <em>I</em>
中的项 \(\textit{B}\rightarrow\cdot\gamma\) 列出来，只需要列出这些被加入的产生式的左部非终结符就行。可以将各项分为两类：</p>
<dl>
<dt>内核项</dt>
<dd>包括初始化 \(\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}\) 以及点不在最左端的所有项</dd>
<dt>非内核项</dt>
<dd>除了 \(\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}\) 之外的所有点在最左端的所有项</dd>
</dl>
<p>感兴趣的项集是某个内核项集合的闭包，求闭包加入的项必然是非内核项。如果我们抛弃所有非内核项，就可以用很少的内存来表示真正感兴趣的项的集合，因为我们已知这些非内核项可以通过闭包运算重新生成。即之前构造出自动机的阴影部分。</p>
<h4 id="goto-函数" class="headerLink">
    <a href="#goto-%e5%87%bd%e6%95%b0" class="header-mark"></a>GOTO 函数</h4><p><code>GOTO(I,X)</code>，其中 <em>I</em> 是一个项集而 <em>X</em> 是一个文法符号。<code>GOTO(I,X)</code> 被定义为 <em>I</em>
中所有形如 \([\textit{A}\rightarrow\alpha\cdot\textit{X}\beta]\) 的项所对应的项
\([\textit{A}\rightarrow\alpha\textit{X}\cdot\beta]\) 的集合的闭包。简单地说，就是自动机的状态转换。示例自动机，\(\texttt{GOTO}(\textit{I}_{1}, +)\) 的结果为项集 \(\textit{I}_{6}\)。</p>
<p>现在我们可以构造出增广文法 \(\textit{G}^{&rsquo;}\) 的规范 LR(0) 项集族 <em>C</em> 的算法。</p>
<div class="verse">
<p><strong>void</strong> items(\(\textit{G}^{&rsquo;}\)) {<br />
    C = {\(\texttt{CLOSURE}\)(\([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}]\))};<br />
    <strong>repeat</strong><br />
        <strong>for</strong> (<em>C</em> 中的每个项集 <em>I</em>)<br />
            <strong>for</strong> (每个文法符号 <em>X</em>)<br />
                <strong>if</strong> (\(\texttt{GOTO}(\textit{I}, \textit{X})\) 非空且不在 <em>C</em> 中)<br />
                    将 \(\texttt{GOTO}(\textit{I}, \textit{X})\) 加入 <em>C</em> 中;<br />
    <strong>until</strong> 在某轮中没有新的项集加入到 <em>C</em> 中;<br />
}<br /></p>
</div>
<h4 id="lr--0--自动机的用法" class="headerLink">
    <a href="#lr--0--%e8%87%aa%e5%8a%a8%e6%9c%ba%e7%9a%84%e7%94%a8%e6%b3%95" class="header-mark"></a>LR(0) 自动机的用法</h4><p>SLR 的中心思想是根据文法构造出 LR(0) 自动机。这个自动机的状态是规范 LR(0) 项集族中的元素，而它的转换由 \(\texttt{GOTO}\) 函数给出。</p>
<p>状态 j 是指对应的与项集 \(\textit{I}_{j}\) 的状态。LR(0) 自动机从开始状态 0 运行到某个状态 j，如果下一个输入符号为 a 且状态 j 有一个 a 上的转换，那么就移入 a，否则就进行归约。</p>
<h3 id="lr-语法分析算法" class="headerLink">
    <a href="#lr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e7%ae%97%e6%b3%95" class="header-mark"></a>LR 语法分析算法</h3><p>还记得 LL 语法分析的非递归预测分析中提到的<strong>分析表驱动的语法分析器</strong>吗，我们的 LR
语法分析器与它很像。</p>
<figure><img src="/images/LR-parser-model.svg"/>
</figure>

<p>所有 LR 语法分析器的驱动程序都是相同的，而语法分析表是根据语法分析器的不同而变化的。每个状态都有一个对应的文法符号，各个状态都和每个项集对应，并有从状态 i 到状态 j 的转换 \(\texttt{GOTO}(\textit{I}_{i}, \textit{X}) = \textit{I}_{j}\)。所有到达状态 j 的转换一定对应于同一个文法符号 \(\textit{X}\)。因此，除了开始状态 0
之外每个状态都和唯一的文法符号项关联。</p>
<h4 id="lr-语法分析表的结构" class="headerLink">
    <a href="#lr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8%e7%9a%84%e7%bb%93%e6%9e%84" class="header-mark"></a>LR 语法分析表的结构</h4><p>语法分析表由语法分析动作函数 <code>ACTION</code> 和转换函数 <code>GOTO</code> 组成。</p>
<ol>
<li>\(\texttt{ACTION}[i, a]\) 取值有四种形式:
<ol>
<li>移入状态 j。语法分析器将输入符号 a 高效地移入栈中，并使用 j 来代表 a</li>
<li>归约 \(\textit{A}\rightarrow\beta\)。语法分析器将栈顶的 \(\beta\) 高效地归约为产生式头 <em>A</em></li>
<li>接受。语法分析器接受输入并完成分析过程</li>
<li>报错。发现语法分析错误并执行纠正动作</li>
</ol>
</li>
<li>\(\texttt{GOTO}[\textit{I}_{i}, \textit{A}] = \textit{I}_{j}\)，将状态 i 与非终结符 <em>A</em> 映射到状态 j</li>
</ol>
<h4 id="lr-语法分析器的行为" class="headerLink">
    <a href="#lr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8%e7%9a%84%e8%a1%8c%e4%b8%ba" class="header-mark"></a>LR 语法分析器的行为</h4><p>语法分析器根据 configuration 决定下一个动作时，首先读入当前输入符号 \(a_{i}\) 和栈顶状态
\(s_{m}\)，在分析动作表中查询条目 \(\texttt{ACTION}[s_{m}, a_{i}]\)。对于每个
<code>ACTION</code> 的形式结束后格局如下：</p>
<ul>
<li>如果 ACTION 为移入 s，那么语法分析器将下一个状态 s 移入栈中，而输入符号
\(a_{i}\) 不需要存放在栈中</li>
<li>如果 ACTION 为归约 \(\textit{A}\rightarrow\beta\)，那么语法分析器进行一次归约操作。语法分析器会先从栈中弹出 r 个状态 (r 是 \(\beta\) 的长度)，之后将状态 s
(\(\texttt{GOTO}[s_{m-r}, \textit{A}]\) 的值) 压入栈。而归约动作中，当前输入符号不会改变。</li>
</ul>
<p>所有的 LR 语法分析器都会按照以下的算法执行，两个 LR 语法分析器之间唯一的区别即
<code>ACTION</code> 和 <code>GOTO</code> 包含的信息不同。</p>
<div class="verse">
<p>输入：一个输入串 w，一个 LR 语法分析表 (GOTO 和 ACTION)<br />
输出：如果 w 在 L(G) 中，输出 w 的自底向上语法分析过程的归约步骤，否则报错<br />
方法：语法分析器栈中最初为 \(s_{0}\)，输入缓冲区的内容为 \(w\$\)，然后执行以下算法<br />
<br />
令 a 为 \(w\$\) 的第一个符号;<br />
<strong>while</strong> (true) {<br />
    令 s 是栈顶状态;<br />
    <strong>if</strong> (\(\texttt{ACTION}[s, a] =\) 移入 t) {<br />
        将 t 压入栈;<br />
        令 a 为下一个符号;<br />
    } <strong>else if</strong> (\(\texttt{ACTION}[s, a] =\) 归约 \(\textit{A}\rightarrow\beta\)) {<br />
        从栈中弹出 \(\texttt{len}(\beta)\) 个符号;<br />
        令 t 为当前栈顶的符号;<br />
        将 \(\texttt{GOTO}[t, \textit{A}]\) 压入栈;<br />
        输出产生式 \(\textit{A}\rightarrow\beta\);<br />
    } <strong>else if</strong> (\(\texttt{ACTION}[s, a] =\) 接受) <strong>break</strong>;<br />
    <strong>else</strong> 调用错误恢复例程;<br />
}<br /></p>
</div>
<p>我们尝试构造一下老朋友 <strong>id</strong> <code>+</code> <strong>id</strong> <code>*</code> <strong>id</strong> 的语法分析表，首先对产生式进行编号：</p>
\[
\begin{align}
\textit{E} &\rightarrow \textit{E} + \textit{T}\tag{1}\\
\textit{E} &\rightarrow \textit{T}\tag{2}\\
\textit{T} &\rightarrow \textit{T} * \textit{F}\tag{3}\\
\textit{T} &\rightarrow \textit{F}\tag{4}\\
\textit{F} &\rightarrow (\textit{E})\tag{5}\\
\textit{F} &\rightarrow \textbf{id}\tag{6}
\end{align}\]

<p>我们由如下规定</p>
<ul>
<li>si 表示移入并将状态 i 压入栈</li>
<li>rj 表示将编号为 j 的产生式进行归约</li>
<li>acc 表示接受</li>
<li>空白表示报错</li>
</ul>
<figure><img src="/images/analysis-table-of-SLR-example.svg"/>
</figure>

<h3 id="构造-slr-语法分析表" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a0-slr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8" class="header-mark"></a>构造 SLR 语法分析表</h3><p>构造增广文法 \(\textit{G}^{&rsquo;}\) 的语法分析表方法如下：</p>
<ol>
<li>构造 \(\textit{G}^{&rsquo;}\) 的规范 LR(0) 项集族 \(C = \{\textit{I}_{0},
\textit{I}_{1}, \cdots, \textit{I}_{n}\}\)</li>
<li>根据 \(\textit{I}_{i}\) 构造出状态 i,状态 i 的语法分析动作按照下面的方法决定。如果这些规则生成了任何冲突动作，那么文法就不是 SLR(1) 的，也就无法生成语法分析器。
<ol>
<li>如果 \([\textit{A}\rightarrow\alpha\cdot{}a\beta]\) 在 \(\textit{I}_{i}\) 中且
\(\texttt{GOTO}(\textit{I}_{i}, a) = \textit{I}_{j}\)，那么将
\(\texttt{ACTION}[i, a]\) 设置为移入 j，其中 a 必须是一个终结符</li>
<li>如果 \([\textit{A}\rightarrow\alpha\cdot]\) 在 \(\textit{I}_{i}\) 中，那么对于
\(\texttt{FOLLOW}(\textit{A})\) 中的所有 a，将 \(\texttt{ACTION}[i, a]\)
设置为归约 \(\textit{A}\rightarrow\alpha\)，这里 \(\textit{A}\) 不为 \(\textit{S}^{&rsquo;}\)</li>
<li>如果 \([\textit{S}^{&rsquo;}\rightarrow\textit{S}\cdot]\) 在 \(\textit{I}_{i}\) 中，那么将
\(\texttt{ACTION}[i, \$]\) 设置为接受</li>
</ol>
</li>
<li>状态 i 对于各个非终结符 <em>A</em> 的 \(\texttt{GOTO}\) 转换使用下面的规则构造：如果 \(\texttt{GOTO}(\textit{I}_{i}, \textit{A}) = \textit{I}_{j}\)，那么
\(\textit{GOTO}[i, \textit{A}] = j\)。</li>
<li>规则 2 与规则 3 没有定义的所有条目都是报错。</li>
<li>语法分析器的初始状态根据 \([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}]\) 所在的项集构造得到的状态。</li>
</ol>
<p>每个 SLR 文法都是无二义性的，但还是存在一些非 SLR 的无二义性文法，如：
\[\begin{aligned}
\textit{S} &amp;\rightarrow \textit{L} = \textit{R} \ |\ \textit{R}\\
\textit{L} &amp;\rightarrow * \textit{R} \ |\ \textbf{id}\\
\textit{R} &amp;\rightarrow \textit{L}
\end{aligned}.\]</p>
<p>其对应的规范 LR(0) 项集为：</p>
<ul>
<li>\(\textit{I}_{0}\)
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \cdot\textit{S}\\
\textit{S} &amp;\rightarrow \cdot\textit{L} = \textit{R}\\
\textit{S} &amp;\rightarrow \cdot\textit{R}\\
\textit{L} &amp;\rightarrow \cdot*\textit{R}\\
\textit{L} &amp;\rightarrow \cdot\textbf{id}\\
\textit{R} &amp;\rightarrow \cdot\textit{L}
\end{aligned}\]</li>
<li>\(\textit{I}_{1}\)
\[\textit{S}^{&rsquo;} \rightarrow \textit{S}\cdot\]</li>
<li>\(\textit{I}_{2}\)
\[\begin{aligned}
\textit{S} &amp;\rightarrow \textit{L}\cdot = \textit{R}\\
\textit{R} &amp;\rightarrow \textit{L}\cdot
\end{aligned}\]</li>
<li>\(\textit{I}_{3}\)
\[\textit{S} \rightarrow \textit{R}\cdot\]</li>
<li>\(\textit{I}_{4}\)
\[\begin{aligned}
\textit{L} &amp;\rightarrow *\cdot\textit{R}\\
\textit{R} &amp;\rightarrow \cdot\textit{L}\\
\textit{L} &amp;\rightarrow \cdot*\textit{R}\\
\textit{L} &amp;\rightarrow \cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{5}\)
\[\textit{L} \rightarrow \textbf{id}\cdot\]</li>
<li>\(\textit{I}_{6}\)
\[\begin{aligned}
\textit{S} &amp;\rightarrow \textit{L} = \cdot\textit{R}\\
\textit{R} &amp;\rightarrow \cdot\textit{L}\\
\textit{L} &amp;\rightarrow \cdot*\textit{R}\\
\textit{L} &amp;\rightarrow \cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{7}\)
\[\textit{L}\rightarrow*\textit{R}\cdot\]</li>
<li>\(\textit{I}_{8}\)
\[\textit{R}\rightarrow\textit{L}\cdot\]</li>
<li>\(\textit{I}_{9}\)
\[\textit{S}\rightarrow\textit{L}=\textit{R}\cdot\]</li>
</ul>
<p>项集 \(\textit{I}_{2}\) 告诉我们 \(\texttt{ACTION}[2, =]\) 是移入 6，而
\(\texttt{FOLLOW}(\textit{R})\) 告诉我们 \(\texttt{ACTION}[2, =]\) 是归约
\(\textit{R}\rightarrow\textit{L}\)，因此这回导致移入 / 归约冲突。产生的原因是 SLR 不够强大，之后更强大的 LR 语法分析可以成功处理更大的文法类型。当然有些无论什么 LR 方法都产生冲突的文法，在设计时都会避免使用。</p>
<h2 id="更强大的-lr-语法分析器" class="headerLink">
    <a href="#%e6%9b%b4%e5%bc%ba%e5%a4%a7%e7%9a%84-lr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8" class="header-mark"></a>更强大的 LR 语法分析器</h2><p>扩展 LR(0) 语法分析技术，在输入中向前看一个符号，有两种方法：</p>
<ol>
<li><strong>规范 LR</strong>，采用很大的 LR(1) 项集，充分利用向前符号</li>
<li><strong>向前看 LR</strong> 或 <strong>LALR</strong>，基于 LR(0) 项集族，但比 LR(1) 拥有更少的状态。可以构造出更强的文法，同时分析表与 SLR 差不多大。</li>
</ol>
<h3 id="规范-lr--1--项" class="headerLink">
    <a href="#%e8%a7%84%e8%8c%83-lr--1--%e9%a1%b9" class="header-mark"></a>规范 LR(1) 项</h3><p>回顾一下在 <a href="#%e6%9e%84%e9%80%a0-slr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8" rel="">构造 SLR 语法分析表</a> 中提到的那个无二义性文法，\(\textit{I}_{2}\) 要求按照 \(\textit{R}\rightarrow\textit{L}\) 归约，同时要求
\(\textit{S}\rightarrow\textit{L}\cdot=\textit{R}\) 移入，很明显 \(\textit{I}_{2}\) 没有
\(\textit{R}=\cdots\) 开头的最右句型，因此只能进行移入操作。</p>
<p>如果我们在状态中添加额外的信息，在必要时分裂某些状态，设法让 LR 语法分析器的每个状态精确地指明哪些输入符号可以跟在句柄只有，从而使句柄被正确归约。</p>
<p>这个额外的信息将项变为了 \([\textit{A}\rightarrow\alpha\cdot\beta,{}a]\)，其中 \(\textit{A}\rightarrow\alpha\beta\) 是产生式，a 是终结符或结束标记。我们称这样的对象为 LR(1) 项，第二个分量称为向前看符号。在形如 \([\textit{A}\rightarrow\alpha\cdot\beta,{}a]\) 且 \(\beta\ne\varepsilon\) 的项中向前看符没有任何用；但
\([\textit{A}\rightarrow\alpha\cdot,{}a]\) 的项只有在下一个输入符号等于 a 时才进行归约。通常 a 的集合是 \(\texttt{FOLLOW}(\textit{A})\) 的子集。</p>
<h3 id="构造-lr--1--项集" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a0-lr--1--%e9%a1%b9%e9%9b%86" class="header-mark"></a>构造 LR(1) 项集</h3><p>构造 LR(1) 项集只需要改写 <code>CLOSURE</code> 和 <code>GOTO</code> 方法。</p>
<div class="verse">
<p>SetOfItems \(\texttt{CLOSURE}\)(<em>I</em>) {<br />
    <strong>repeat</strong><br />
        <strong>for</strong> (<em>I</em> 中的每个项 \([\textit{A}\rightarrow\alpha\cdot\textit{B}\beta,{}a]\))<br />
            <strong>for</strong> (\(\textit{G}^{&rsquo;}\) 中的每个产生式 \(\textit{B}\rightarrow\gamma\))<br />
                <strong>for</strong> (\(\texttt{FIRST}(\beta{}a)\) 中的每个终结符 b)<br />
                    将 \([\textit{B}\rightarrow\cdot\gamma,{}b]\) 加入到集合 <em>I</em> 中;<br />
    <strong>until</strong> 不能向 <em>I</em> 中加入更多的项;<br />
    <strong>return</strong> <em>I</em>;<br />
}<br />
SetOfItems \(\texttt{GOTO}\)(<em>I</em>, <em>X</em>) {<br />
    将 <em>J</em> 初始化为空集;<br />
    <strong>for</strong> (<em>I</em> 中的每个项 \([\textit{A}\rightarrow\alpha\cdot\textit{X}\beta,{}a]\))<br />
        将\([\textit{A}\rightarrow\alpha\textit{X}\cdot\beta,{}a]\) 加入集合 <em>J</em> 中;<br />
    <strong>return</strong> \(\texttt{CLOSURE}(\textit{J})\);<br />
}<br />
<strong>void</strong> items(\(\textit{G}^{&rsquo;}\)) {<br />
    将 <em>C</em> 初始化为 \(\{\texttt{CLOSURE}\}(\{[\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S},\$]\})\);<br />
    <strong>repeat</strong><br />
        <strong>for</strong> (<em>C</em> 中的每个项集 <em>I</em>)<br />
            <strong>for</strong> (每个文法符号 <em>X</em>)<br />
                <strong>if</strong> (\(\texttt{GOTO}(\textit{I}, \textit{X})\) 非空且不在 <em>C</em> 中)<br />
                    将 \(\texttt{GOTO}(\textit{I}, \textit{X})\) 加入 <em>C</em> 中;<br />
    <strong>until</strong> 不再有新的项集加入到 <em>C</em> 中;<br />
}<br /></p>
</div>
<p>我们可以针对增广文法构造自动机
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \textit{S}\\
\textit{S} &amp;\rightarrow \textit{C}\ \textit{C}\\
\textit{C} &amp;\rightarrow c\ \textit{C} \ |\ d
\end{aligned}\]</p>
<figure><img src="/images/LR-1-automachine-example.svg"/>
</figure>

<h3 id="规范-lr--1--语法分析表" class="headerLink">
    <a href="#%e8%a7%84%e8%8c%83-lr--1--%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8" class="header-mark"></a>规范 LR(1) 语法分析表</h3><ol>
<li>构造 \(\textit{G}^{&rsquo;}\) 的规范 LR(1) 项集族
\(C^{&rsquo;} = \{\textit{I}_{0}, \textit{I}_{1}, \cdots, \textit{I}_{n}\}\)</li>
<li>根据 \(\textit{I}_{i}\) 构造出状态 i，状态 i 的语法分析动作按照下面的方法决定。如果这些规则生成了任何冲突动作，那么文法就不是 LR(1) 的，也就无法生成语法分析器。
<ol>
<li>如果 \([\textit{A}\rightarrow\alpha\cdot{}a\beta, b]\) 在 \(\textit{I}_{i}\) 中且
\(\texttt{GOTO}(\textit{I}_{i}, a) = \textit{I}_{j}\)，那么将
\(\texttt{ACTION}[i, a]\) 设置为移入 j，其中 a 必须是一个终结符</li>
<li>如果 \([\textit{A}\rightarrow\alpha\cdot, a]\) 在 \(\textit{I}_{i}\) 中且 \(\textit{A}\ne\textit{S}^{&rsquo;}\)，那么对于将 \(\texttt{ACTION}[i, a]\)
设置为归约 \(\textit{A}\rightarrow\alpha\)</li>
<li>如果 \([\textit{S}^{&rsquo;}\rightarrow\textit{S}\cdot,\$]\) 在 \(\textit{I}_{i}\) 中，那么将
\(\texttt{ACTION}[i, \$]\) 设置为接受</li>
</ol>
</li>
<li>状态 i 对于各个非终结符 <em>A</em> 的 \(\texttt{GOTO}\) 转换使用下面的规则构造：如果 \(\texttt{GOTO}(\textit{I}_{i}, \textit{A}) = \textit{I}_{j}\)，那么
\(\textit{GOTO}[i, \textit{A}] = j\)。</li>
<li>规则 2 与规则 3 没有定义的所有条目都是报错。</li>
<li>语法分析器的初始状态根据 \([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S},\$]\) 所在的项集构造得到的状态。</li>
</ol>
<p>每个 SLR 文法都是规范 LR(1) 文法，但对同一文法 SLR 的状态比 LR(1) 少。上一节提到的文法，SLR 只需要七个状态，而 LR(1) 文法需要 10 个状态。</p>
\[
\begin{align}
\textit{S} &\rightarrow \textit{C}\ \textit{C}\tag{1}\\
\textit{C} &\rightarrow c\ \textit{C}\tag{2}\\
\textit{C} &\rightarrow d\tag{3}
\end{align}\]

<p>其语法分析表如下：</p>
<figure><img src="/images/analysis-table-of-LR-1-example.svg"/>
</figure>

<h3 id="构造-lalr-语法分析表" class="headerLink">
    <a href="#%e6%9e%84%e9%80%a0-lalr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8" class="header-mark"></a>构造 LALR 语法分析表</h3><p>LALR 语法分析技术是实践中常用的分析技术，因为其分析表比 LR 分析表小的多，且大部分常见的程序设计语言都可以方便构造 LALR 文法表示。SLR 与 LALR 总是有相同数量的状态。比如 C 语言 SLR 可能有几百个状态，但规范 LR(1) 可能达到上千个状态。</p>
<p>考虑规范 LR(1) 文法中的示例，考虑状态 4 与状态 7 的区别，正则表达式 <code>c*dc*d</code>，第一组 <code>c*d</code> 会进入状态 4，而第二组 <code>c*d</code> 会进入状态 7</p>
<ul>
<li>\(\textit{I}_{4}\): \(\textit{C}\rightarrow{}d\cdot,c/d\)</li>
<li>\(\textit{I}_{7}\): \(\textit{C}\rightarrow{}d\cdot,\$\)</li>
</ul>
<p>基本没什么区别，可以将状态 4 和状态 7 作为并集替换为 \(\textit{I}_{47}\)，这个项集包含了 \([\textit{C}\rightarrow{}d\cdot,c/d/\$]\)。</p>
<p>我们通常将具有相同<strong>核心</strong> (core) 的 LR(1) 项集合并为第一分量的集合，一个核心就是当前正处理的文法的 LR(0) 项集，LR(1) 文法可能产生多个具有相同核心的项集。
\(\texttt{GOTO}(\textit{I}, \textit{X})\) 的核心只有 <em>I</em> 的核心决定，一组被合并的项集的 \(\texttt{GOTO}\) 的目标也可以被合并。因此我们可以相应地修改
\(\texttt{GOTO}\) 函数和动作函数。</p>
<p>但是如果无脑合并，可能会产生冲突，比如以下这个文法
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \textit{S}\\
\textit{S} &amp;\rightarrow a\textit{A}d\,|\,b\textit{B}d\,|\,a\textit{A}e\,|\,b\textit{A}e\\
\textit{A} &amp;\rightarrow c\\
\textit{B} &amp;\rightarrow c
\end{aligned}\]</p>
<p>这是一个 LR(1) 文法，其中有两个项集 core 相同：\(\{[\textit{A}\rightarrow{}c\cdot,d],
[\textit{B}\rightarrow{}c\cdot,e]\}\) 和 \(\{[\textit{A}\rightarrow{}c\cdot,e], [\textit{B}\rightarrow{}c\cdot,d]\}\)。但是它们的并集 \(\{[\textit{A}\rightarrow{}c\cdot,d/e], [\textit{B}\rightarrow{}c\cdot,d/e]\}\) 将会造成归约/
归约冲突。</p>
<p>那么可以给出定义 LALR(1) 文法的语法分析表构建方法，其核心思想就是<strong>构造出 LR(1)
项集，将没有冲突且相同核心的项集合并</strong>。</p>
<ol>
<li>构造 LR(1) 项集族 \(\textit{C}=\{\textit{I}_{0}, \textit{I}_{1}, \cdots,
\textit{I}_{n}\}\)</li>
<li>对于 LR(1) 项集中的每个核心，找出具有相同和新的项集，用并集替换它们</li>
<li>令 \(\textit{C}^{&rsquo;}=\{\textit{J}_{0}, \textit{J}_{1}, \cdots, \textit{J}_{m}\}\)
是得到的 LR(1) 项集族</li>
<li>GOTO 表的构造方法如下：如果 <em>J</em> 是一个或多个 LR(1) 项集的并集
(\(\textit{J}=\textit{I}_{1}\cup\textit{I}_{2}\cup\cdots\cup\textit{I}_{k}\))，那么
\(\texttt{GOTO}(\textit{I}_{1}, \textit{X})\)、
\(\texttt{GOTO}(\textit{I}_{2}, \textit{X})\)、\(\cdots\)、
\(\texttt{GOTO}(\textit{I}_{k}, \textit{X})\) 的核心相同，令 <em>K</em> 是所有和
\(\texttt{GOTO}(\textit{I}_{1}, \textit{X})\) 具有相同核心的项集的并集，那么 \(\texttt{GOTO}(\textit{J}, \textit{X}) = \textit{K}\)。</li>
</ol>
<p>如果没有冲突，那么将其称为 LALR(1) 文法，第三步的项集族被称为 LALR(1) 项集族。</p>
<p>我们可以针对之前 LR(1) 文法示例的增广文法构造自动机，方便对比两个文法
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \textit{S}\\
\textit{S} &amp;\rightarrow \textit{C}\ \textit{C}\\
\textit{C} &amp;\rightarrow c\ \textit{C} \ |\ d
\end{aligned}\]</p>
<figure><img src="/images/LALR-1-automachine-example.svg"/>
</figure>

<p>其分析表也很简单。</p>
<figure><img src="/images/analysis-table-of-LALR-1-example.svg"/>
</figure>

<p>在处理正确的输入时，LR 语法分析器和 LALR 语法分析器可以相互模拟；在处理错误的输入时，LALR 语法分析器可能在 LR 语法分析器报错之后继续执行一些归约动作，但绝不会在 LR 语法分析器报错之后移入任何符号。</p>
<h3 id="高效构造-lalr-语法分析表" class="headerLink">
    <a href="#%e9%ab%98%e6%95%88%e6%9e%84%e9%80%a0-lalr-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e8%a1%a8" class="header-mark"></a>高效构造 LALR 语法分析表</h3><p>构建 LALR(1) 文法时，实际上我们不需要先构建完整的规范 LR(1) 项集族，这样效率太低了，也不是实际应用的构建方式。因此可以优化其构造。</p>
<ul>
<li>首先只用用内核项来表示任意的 LR(0) 或 LR(1) 项集。就是只使用初始项
\([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}]\) 或 \([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S},\$]\) 以及那些点不在产生体左端的项来表示项集</li>
<li>我们可以使用一个<strong>传播和自发生成</strong>的过程生成向前看符号，根据 LR(0) 项的内核来生成 LALR(1) 项的内核</li>
<li>如果有了 LALR(1) 内核，对各个内核求 \(\texttt{CLOSURE}\)，再把 LALR(1) 项集当作规范 LR(1) 项集族，计算分析表，从而得到 LALR(1) 语法分析表</li>
</ul>
<p>还是一样的用一个示例构造 LALR(1) 语法分析表。
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \textit{S}\\
\textit{S} &amp;\rightarrow \textit{L} = \textit{R}\ |\ \textit{R}\\
\textit{L} &amp;\rightarrow * \textit{R} \ |\ \textbf{id}\\
\textit{R} &amp;\rightarrow \textit{L}
\end{aligned}\]</p>
<p>状态内核如下</p>
<ul>
<li>\(\textit{I}_{0}\): \(\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}\)</li>
<li>\(\textit{I}_{1}\): \(\textit{S}^{&rsquo;}\rightarrow\textit{S}\cdot\)</li>
<li>\(\textit{I}_{2}\): \[\begin{aligned}
\textit{S}&amp;\rightarrow\textit{L}\cdot=\textit{R}\\ \textit{R}&amp;\rightarrow\textit{L}\cdot\end{aligned}\]</li>
<li>\(\textit{I}_{3}\): \(\textit{S}\rightarrow\textit{R}\cdot\)</li>
<li>\(\textit{I}_{4}\): \(\textit{L}\rightarrow*\cdot\textit{R}\)</li>
<li>\(\textit{I}_{5}\): \(\textit{L}\rightarrow\textbf{id}\cdot\)</li>
<li>\(\textit{I}_{6}\): \(\textit{S}\rightarrow\textit{L}=\cdot\textit{R}\)</li>
<li>\(\textit{I}_{7}\): \(\textit{L}\rightarrow*\textit{R}\cdot\)</li>
<li>\(\textit{I}_{8}\): \(\textit{R}\rightarrow\textit{L}\cdot\)</li>
<li>\(\textit{I}_{9}\): \(\textit{S}\rightarrow\textit{L}=\textit{R}\cdot\)</li>
</ul>
<p>在这些内核上加上正确的向前看符号，创建出 LALR(1) 项集的内核。在两种情况下向前看符号 b 可以添加到某个 LALR(1) 项集 <em>J</em> 中的 LR(0) 项 \(\textit{B}\rightarrow\gamma\cdot\delta\) 上</p>
<ul>
<li>存在一个包含内核项 \([\textit{A}\rightarrow\alpha\cdot\beta, a]\) 的项集 <em>I</em> 且
\(\textit{J}=\texttt{GOTO}(\textit{I},\textit{X})\)。不管 a 为何值，构造
\(\texttt{GOTO}(\texttt{CLOSURE}(\{[\textit{A}\rightarrow\alpha\cdot\beta, a]\}), X)\) 时得到的结果总是包含 \([\textit{B}\rightarrow\gamma\cdot\delta, b]\)。对于 \(\textit{B}\rightarrow\gamma\cdot\delta\) 而言，这个向前看符号 b 称为<strong>自发生成的</strong>。符号 \(\$\) 对于初始项
\([\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}]\) 而言总是自发生成的。</li>
<li>其余条件与上一个条件相同，但是 \(a=b\)，且计算
\(\texttt{GOTO}(\texttt{CLOSURE}(\{[\textit{A}\rightarrow\alpha\cdot\beta, b]\}), \textit{X})\) 得到的结果中包含 \([\textit{B}\rightarrow\gamma\cdot\delta, b]\) 的原因是项 \(\textit{A}\rightarrow\alpha\cdot\beta\) 有一个向前看符号 b。这种情况称为向前看符号从 <em>I</em> 的内核中的 \(\textit{A}\rightarrow\alpha\cdot\beta\) 传播到了 <em>J</em> 的内核中的 \(\textit{B}\rightarrow\gamma\cdot\delta\) 上。</li>
</ul>
<p>需要确定每个 LR(0)　项集中自发生成的向前看符号，同时也要确定向前看符号从哪些项传播到了哪些项。</p>
<p>这个检测实际上很简单。令 \(\#\) 为一个不在当前文法中的符号。令
\(\textit{A}\rightarrow\alpha\cdot\beta\)　为项集 <em>I</em> 中的一个内核 LR(0) 项。对每个 <em>X</em> 计算
\(\textit{J}=\texttt{GOTO}(\texttt{CLOSURE}(\{[\textit{A}\rightarrow\alpha\cdot\beta, \#]\}),
\textit{X})\)。检查 <em>J</em> 中的每个内核项的向前看符号集合，如果 \(\#\) 是它的向前看符号，那么向前看符号就从 \(\textit{A}\rightarrow\alpha\cdot\beta\) 传播到这个项。所有其他的向前看符号都是自发生成的。这个算法还用到了一个性质：<em>J</em> 中的所有内核项中点的左边都是 <em>X</em>，即它们必然是形如 \(\textit{B}\rightarrow\gamma\textit{X}\cdot\delta\) 的项。</p>
<p>有 LR(0) 项集 <em>I</em> 的内核 <em>K</em> 构造向前看符号的算法如下：</p>
<div class="verse">
<p><strong>for</strong> (<em>K</em> 中的每个项 \(\textit{A}\rightarrow\alpha\cdot\beta\)) {<br />
    <em>J</em> := \(\texttt{CLOSURE}(\{[\textit{A}\rightarrow\alpha\cdot\beta, \#]\})\);<br />
    <strong>if</strong> (\([\textit{B}\rightarrow\gamma\cdot\textit{X}\delta, a]\) 在 <em>J</em> 中，且 \(a\ne\#\)) {<br />
        断定 \(\texttt{GOTO}(\textit{I}, \textit{X})\) 中的项 \(\textit{B}\rightarrow\gamma\textit{X}\cdot\delta\) 的向前看符号 a 是自发生成的;<br />
    }<br />
    <strong>if</strong> (\([\textit{B}\rightarrow\gamma\cdot\textit{X}\delta, \#]\) 在 <em>J</em> 中) {<br />
        断定向前看符号从 <em>I</em> 中的项 \(\textit{A}\rightarrow\alpha\cdot\beta\) 传播到了 \(\texttt{GOTO}(\textit{I}, \textit{X})\) 中的项 \(\textit{B}\rightarrow\gamma\textit{X}\cdot\delta\) 上;<br />
    }<br />
}<br /></p>
</div>
<p>现在我们就可以高效地构建 LALR(1) 项集族内核了。</p>
<ol>
<li>构造 G 的 LR(0) 项集族的内核，保留各个项集的内核项，并计算一个项集 <em>I</em> 的
<code>GOTO</code> 之前先计算 <em>I</em> 的闭包</li>
<li>对每个 LR(0) 项集的内核和每个文法符号 <em>X</em> 应用上面介绍的构造向前看符号的算法，确定 \(\texttt{GOTO}(\textit{I}, \textit{X})\) 中各内核项的哪些向前看符号是自发生成的，并确定向前看符号从 <em>I</em> 中的哪个项被传播
\(\texttt{GOTO}(\textit{I}, \textit{X})\) 中的内核上</li>
<li>初始化一个表格，表中给出了每个项集中的每个内核项相关的向前看符号。最初每个项的向前看符号只包括那些我们确定的自发生成的符号</li>
<li>不断扫描所有项集的内核项。当我们访问一个项 i 时，使用表中符号以及自发生成的符号，确定 i 将它的向前看符号传播到了哪些内核项中。项 i 的qq当前向前看符号集合被加到和这些被传播的内核项相关连的向前看符号集中。直到没有新的向前看符号被传播为止</li>
</ol>
<p>本节前文提到了 LALR(1) 的一个示例，对这个内核，我们先将计算向前看符号的算法应用到项集 \(\textit{I}_{0}\) 的内核上，计算
\(\texttt{CLOSURE}(\{[\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}, \#]\})\) 可以得到
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \cdot\textit{S}, \#  \qquad\qquad\qquad &amp; \textit{L} &amp;\rightarrow \cdot*\textit{R}, \#/=\\
\textit{S} &amp;\rightarrow \cdot\textit{L}=\textit{R}, \#  \qquad\qquad\qquad &amp; \textit{L} &amp;\rightarrow \cdot\textbf{id},\#/=\\
\textit{S} &amp;\rightarrow \cdot\textit{R}, \#  \qquad\qquad\qquad &amp; \textit{R} &amp;\rightarrow \cdot\textit{L}, \#
\end{aligned}\]</p>
<p>所以我们可以确定 \(\textit{I}_{0}\) 中的项 \(\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}\) 将它的向前看符号传播到了以下六个项中</p>
<ul>
<li>\(\textit{I}_{1}\) 中的 \(\textit{S}^{&rsquo;}\rightarrow\textit{S}\cdot\)</li>
<li>\(\textit{I}_{2}\) 中的 \(\textit{S}\rightarrow\textit{L}\cdot=\textit{R}\)</li>
<li>\(\textit{I}_{3}\) 中的 \(\textit{S}\rightarrow\textit{R}\cdot\)</li>
<li>\(\textit{I}_{4}\) 中的 \(\textit{L}\rightarrow*\cdot\textit{R}\)</li>
<li>\(\textit{I}_{5}\) 中的 \(\textit{L}\rightarrow\textbf{id}\cdot\)</li>
<li>\(\textit{I}_{2}\) 中的 \(\textit{R}\rightarrow\textit{L}\cdot\)</li>
</ul>
<p>依次列出每轮扫描向前看符号的传播途径</p>
<table>
<thead>
<tr>
<th>基础状态</th>
<th>传播到</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(\textit{I}_{0}\): \(\textit{S}^{&rsquo;}\rightarrow\cdot\textit{S}\)</td>
<td>\(\begin{aligned}\textit{I}_{1}:\ \textit{S}^{&rsquo;}&amp;\rightarrow\textit{S}\cdot\\ \textit{I}_{2}:\ \textit{S}&amp;\rightarrow\textit{L}\cdot=\textit{R}\\ \textit{I}_{2}:\ \textit{R}&amp;\rightarrow\textit{L}\cdot\\ \textit{I}_{3}:\ \textit{S}&amp;\rightarrow\textit{R}\cdot\\ \textit{I}_{4}:\ \textit{L}&amp;\rightarrow*\cdot\textit{R}\\ \textit{I}_{5}:\ \textit{L}&amp;\rightarrow\textbf{id}\cdot\end{aligned}\)</td>
</tr>
<tr>
<td>\(\textit{I}_{2}\): \(\textit{S}\rightarrow\textit{L}\cdot=\textit{R}\)</td>
<td>\(\textit{I}_{6}:\ \textit{S}\rightarrow\textit{L}=\cdot\textit{R}\)</td>
</tr>
<tr>
<td>\(\textit{I}_{4}\): \(\textit{L}\rightarrow*\cdot\textit{R}\)</td>
<td>\(\begin{aligned}\textit{I}_{4}:\ \textit{L}&amp;\rightarrow*\cdot\textit{R}\\ \textit{I}_{5}:\ \textit{L}&amp;\rightarrow\textbf{id}\cdot\\ \textit{I}_{7}:\ \textit{L}&amp;\rightarrow*\textit{R}\cdot\\ \textit{I}_{8}:\ \textit{R}&amp;\rightarrow\textit{L}\cdot\end{aligned}\)</td>
</tr>
<tr>
<td>\(\textit{I}_{6}\): \(\textit{S}\rightarrow\textit{L}=\cdot\textit{R}\)</td>
<td>\(\begin{aligned}\textit{I}_{4}:\ \textit{L}&amp;\rightarrow*\cdot\textit{R}\\ \textit{I}_{5}:\ \textit{L}&amp;\rightarrow\textbf{id}\cdot\\ \textit{I}_{8}:\ \textit{R}&amp;\rightarrow\textit{L}\cdot\\ \textit{I}_{9}:\ \textit{S}&amp;\rightarrow\textit{L}=\textit{R}\cdot\end{aligned}\)</td>
</tr>
</tbody>
</table>
<h2 id="使用二义性文法" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8%e4%ba%8c%e4%b9%89%e6%80%a7%e6%96%87%e6%b3%95" class="header-mark"></a>使用二义性文法</h2><p>每个二义性文法都不是 LR 的，但某些类型的二义性文法在语言的归约和实现中很有用。像表达式这样的语言构造，二义性文法能提供比任何等价的无二义性文法更短、更自然的归约。二义性文法的另一个用途是隔离经常出现的语法构造，以对其进行特殊优化。</p>
<p>虽然使用的文法有二义性，但在所有情况下给出消除二义性的规则，使得每个句子只有一颗语法分析树。通过这个方法，语言的归约在整体上是无二义性的，有时还可以构造出遵循这个二义性解决方法的 LR 语法分析器。</p>
<h3 id="用优先级和结合性解决冲突" class="headerLink">
    <a href="#%e7%94%a8%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e7%bb%93%e5%90%88%e6%80%a7%e8%a7%a3%e5%86%b3%e5%86%b2%e7%aa%81" class="header-mark"></a>用优先级和结合性解决冲突</h3><p>回想之前一直提及的示例 <strong>id</strong> <code>+</code> <strong>id</strong> <code>*</code> <strong>id</strong>，其无二义性文法
\[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}+\textit{T}\\
\textit{E}&amp;\rightarrow\textit{T}\\
\textit{T}&amp;\rightarrow\textit{T}*\textit{F}\\
\textit{T}&amp;\rightarrow\textit{F}\\
\textit{F}&amp;\rightarrow(\textit{E})\\
\textit{F}&amp;\rightarrow\textbf{id}\end{aligned}.\]</p>
<p>但其二义性文法
\[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}+\textit{E}\\
\textit{E}&amp;\rightarrow\textit{E}*\textit{E}\\
\textit{E}&amp;\rightarrow(\textit{E})\\
\textit{E}&amp;\rightarrow\textbf{id}\end{aligned}.\]</p>
<p>无二义性的版本指定了运算符 <code>+</code> 和 <code>*</code> 的优先级和结合性。但二义性文法没有给出这样的信息，可以轻易改变运算符的优先级和结合性，且不用修改文法产生式，也不用修改语法分析器的状态数目。</p>
<p>首先给出二义性文法的 LR(0) 项集</p>
<ul>
<li>\(\textit{I}_{0}\): \[\begin{aligned}
\textit{E}^{&rsquo;}&amp;\rightarrow\cdot\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}+\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}*\textit{E}\\
\textit{E}&amp;\rightarrow\cdot(\textit{E})\\
\textit{E}&amp;\rightarrow\cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{1}\): \[\begin{aligned}
\textit{E}^{&rsquo;}&amp;\rightarrow\textit{E}\cdot\\
\textit{E}&amp;\rightarrow\textit{E}\cdot+\textit{E}\\
\textit{E}&amp;\rightarrow\textit{E}\cdot*\textit{E}
\end{aligned}\]</li>
<li>\(\textit{I}_{2}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow(\cdot\textit{E})\\
\textit{E}&amp;\rightarrow\cdot\textit{E}+\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}*\textit{E}\\
\textit{E}&amp;\rightarrow\cdot(\textit{E})\\
\textit{E}&amp;\rightarrow\cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{3}\): \(\textit{E}\rightarrow\textbf{id}\cdot\)</li>
<li>\(\textit{I}_{4}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}+\cdot\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}+\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}*\textit{E}\\
\textit{E}&amp;\rightarrow\cdot(\textit{E})\\
\textit{E}&amp;\rightarrow\cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{5}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}*\cdot\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}+\textit{E}\\
\textit{E}&amp;\rightarrow\cdot\textit{E}*\textit{E}\\
\textit{E}&amp;\rightarrow\cdot(\textit{E})\\
\textit{E}&amp;\rightarrow\cdot\textbf{id}
\end{aligned}\]</li>
<li>\(\textit{I}_{6}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow(\textit{E}\cdot)\\
\textit{E}&amp;\rightarrow\textit{E}\cdot+\textit{E}\\
\textit{E}&amp;\rightarrow\textit{E}\cdot*\textit{E}
\end{aligned}\]</li>
<li>\(\textit{I}_{7}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}+\textit{E}\cdot\\
\textit{E}&amp;\rightarrow\textit{E}\cdot+\textit{E}\\
\textit{E}&amp;\rightarrow\textit{E}\cdot*\textit{E}
\end{aligned}\]</li>
<li>\(\textit{I}_{8}\): \[\begin{aligned}
\textit{E}&amp;\rightarrow\textit{E}*\textit{E}\cdot\\
\textit{E}&amp;\rightarrow\textit{E}\cdot+\textit{E}\\
\textit{E}&amp;\rightarrow\textit{E}\cdot*\textit{E}
\end{aligned}\]</li>
<li>\(\textit{I}_{9}\): \(\textit{E}\rightarrow(\textit{E})\cdot\)</li>
</ul>
<p>现在假设语法分析器处理完了 <strong>id</strong> <code>+</code> <strong>id</strong>，栈中的状态为 \(0, 1, 4, 7\)，剩下的输入为</p>
<ul>
<li><code>*</code> <strong>id</strong>，这会产生移入/归约冲突
<ul>
<li>如果 <code>*</code> 的优先级高于 <code>+</code>，语法分析器将移入 <code>*</code></li>
<li>如果 <code>+</code> 的优先级高于 <code>*</code>，语法分析器将归约
\(\textit{E}\rightarrow\textit{E}+\textit{E}\)</li>
</ul>
</li>
<li><code>+</code> <strong>id</strong>，这会产生移入/归约冲突。如果 <code>+</code> 是左结合的，那么按照
\(\textit{E}\rightarrow\textit{E}+\textit{E}\) 归约</li>
</ul>
<p>因此利用优先级和结合性，可以得到一个与 SLR 近似的语法动作表。</p>
<figure><img src="/images/analysis-table-of-ambiguous-grammar.svg"/>
</figure>

<h3 id="悬空-else-的二义性" class="headerLink">
    <a href="#%e6%82%ac%e7%a9%ba-else-%e7%9a%84%e4%ba%8c%e4%b9%89%e6%80%a7" class="header-mark"></a>悬空-else 的二义性</h3><p>再说说悬空 else 的文法
\[\begin{aligned}
smtm &amp;\rightarrow\ \textbf{if}\ expr\ \textbf{then}\ stmt\ \textbf{else}\ stmt\\
&amp;|\ \textbf{if}\ expr\ \textbf{then}\ stmt\\
&amp;|\ \textbf{other}
\end{aligned}\]</p>
<p>将其简写为如下这个增广文法
\[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \textit{S}\\
\textit{S} &amp;\rightarrow i\textit{S}e\textit{S} \ |\ i\textit{S} \ |\ a
\end{aligned}\]</p>
<p>它有如下 LR(0) 状态</p>
<ul>
<li>
<p>\(\textit{I}_{0}\): \[\begin{aligned}
\textit{S}^{&rsquo;} &amp;\rightarrow \cdot\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}e\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}a
\end{aligned}\]</p>
</li>
<li>
<p>\(\textit{I}_{1}\): \(\textit{S}^{&rsquo;} \rightarrow \cdot\textit{S}\)</p>
</li>
<li>
<p>\(\textit{I}_{2}\): \[\begin{aligned}
\textit{S} &amp;\rightarrow i\cdot\textit{S}e\textit{S}\\
\textit{S} &amp;\rightarrow i\cdot\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}e\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}a
\end{aligned}\]</p>
</li>
<li>
<p>\(\textit{I}_{3}\): \(\textit{S}\rightarrow{}a\cdot\)</p>
</li>
<li>
<p>\(\textit{I}_{4}\): \[\begin{aligned}
\textit{S} &amp;\rightarrow i\textit{S}\cdot{}e\textit{S}\\
\textit{S} &amp;\rightarrow i\textit{S}\cdot
\end{aligned}\]</p>
</li>
<li>
<p>\(\textit{I}_{5}\): \[\begin{aligned}
\textit{S} &amp;\rightarrow i\textit{S}e\cdot\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}e\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}i\textit{S}\\
\textit{S} &amp;\rightarrow \cdot{}a
\end{aligned}\]</p>
</li>
<li>
<p>\(\textit{I}_{6}\): \(\textit{S}\rightarrow{}i\textit{S}e\textit{S}\cdot\)</p>
</li>
</ul>
<p>在 \(\textit{I}_{4}\) 上有一个移入/归约冲突。项
\(\textit{S}\rightarrow{}i\textit{S}\cdot{}e\textit{S}\) 要求移入 e，但 \(\texttt{FOLLOW}(S) =
\{e, \$\}\)，项 \(\textit{S}\rightarrow{}i\textit{S}\cdot\) 在输入为 e 时进行归约。我们可以要求在输入 e 时执行移入操作，可以得到一个近似无二义性的 LR 分析表。</p>
<figure><img src="/images/analysis-table-of-ambiguous-grammar-for-if-else.svg"/>
</figure>

<p>当然如此解决悬空 else 问题后，我们可以为 iiaea 语法产生正确的语法分析动作。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>栈</th>
<th>符号</th>
<th>输入</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td>\(iiaea\$\)</td>
<td>移入</td>
</tr>
<tr>
<td>2</td>
<td>02</td>
<td>\(i\)</td>
<td>\(iaea\$\)</td>
<td>移入</td>
</tr>
<tr>
<td>3</td>
<td>022</td>
<td>\(ii\)</td>
<td>\(aea\$\)</td>
<td>移入</td>
</tr>
<tr>
<td>4</td>
<td>0223</td>
<td>\(iia\)</td>
<td>\(ea\$\)</td>
<td>归约 \(\textit{S}\rightarrow{}a\)</td>
</tr>
<tr>
<td>5</td>
<td>0224</td>
<td>\(ii\textit{S}\)</td>
<td>\(ea\$\)</td>
<td>移入</td>
</tr>
<tr>
<td>6</td>
<td>02245</td>
<td>\(ii\textit{S}e\)</td>
<td>\(a\$\)</td>
<td>移入</td>
</tr>
<tr>
<td>7</td>
<td>022453</td>
<td>\(ii\textit{S}ea\)</td>
<td>\(\$\)</td>
<td>归约 \(\textit{S}\rightarrow{}a\)</td>
</tr>
<tr>
<td>8</td>
<td>022456</td>
<td>\(ii\textit{S}e\textit{S}\)</td>
<td>\(\$\)</td>
<td>归约 \(\textit{S}\rightarrow{}i\textit{S}e\textit{S}\)</td>
</tr>
<tr>
<td>9</td>
<td>024</td>
<td>\(i\textit{S}\)</td>
<td>\(\$\)</td>
<td>归约 \(\textit{S}\rightarrow{}i\textit{S}\)</td>
</tr>
<tr>
<td>10</td>
<td>01</td>
<td>\(\textit{S}\)</td>
<td>\(\$\)</td>
<td>接受</td>
</tr>
</tbody>
</table>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 04-30</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/2022/compilerprinciple_006/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span><span>|&nbsp;<a class="link-to-report" href=https://gitlab.com/GinShio/ginshio.gitlab.io/issues/new?issue[title]=[BUG]%20%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90+3&issue[description]=[POST](https://blog.ginshio.org/2022/compilerprinciple_006/)%0A%0A##%20Isseus%0A target="_blank" rel="noopener noreferrer">报告问题</a>
                    </span></div>
            <div class="post-info-share">
                <span><a href="#" onclick="return false;" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3" data-hashtags="Note,DragonBook,SyntacticAnalysis"><i class="fab fa-twitter fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-hashtag="Note"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/"><i class="fab fa-linkedin fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" onclick="return false;" title="分享到 Telegram" data-sharer="telegram" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3" data-web><i class="fab fa-telegram-plane fa-fw"></i></a><a href="#" class="weixin" onclick="return false;" title="分享到 微信" data-sharer="weixin" data-url="https://blog.ginshio.org/2022/compilerprinciple_006/" data-title="语法分析 3" data-web><i class="fab fa-weixin fa-fw"></i><img src="https://api.oick.cn/qrcode/api.php?size=256&amp;text=https://blog.ginshio.org/2022/compilerprinciple_006/" title="语法分析 3">
    </a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/dragonbook/">DragonBook</a>,&nbsp;<a href="/tags/syntacticanalysis/">SyntacticAnalysis</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2022/compilerprinciple_005/" class="prev" rel="prev" title="语法分析 2"><i class="fas fa-angle-left fa-fw"></i>语法分析 2</a>
            <a href="/2022/flex_and_bison/" class="next" rel="next" title="词法分析软件 Flex 及语法分析软件 Bison 的用法">词法分析软件 Flex 及语法分析软件 Bison 的用法<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.102.3">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank" rel="noopener noreferrer"> </a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.b250718923eb2b3c2ba2de589fcc7f623ebf3efa17f0e501e7de204156024b108524ffafaf0958fd09d3b68cf0412999.css" integrity="sha384-slBxiSPrKzwrot5Yn8x/Yj6/PvoX8OUB594gQVYCSxCFJP&#43;vrwlY/QnTtozwQSmZ"><link rel="stylesheet" href="/lib/katex/katex.min.bcaaee8fe6b5dd4f321c8900c8680ad49dc0ad32f3ac51816c1734b43a7869dfc4c9ec0449e5c4fc8bfaec08fc80a674.css" integrity="sha384-vKruj&#43;a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"96cbbb15f26bebd9141b","clientSecret":"29c7df99d6e1806113996333163a9476027ff1fa","id":"2022-04-20T16:25:13+08:00","owner":"GinShio","repo":"ginshio.github.io","title":"语法分析 3"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"ABF13CGNA0","algoliaIndex":"ginshio_blog","algoliaSearchKey":"51cf3425aba132c091b477c3d5e06eea","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"sharerjs":true,"table":{"sort":true}};</script><script type="text/javascript" src="/lib/gitalk/gitalk.min.1420a0c0459673bc6824e7ba713f1e0ec1540e86491daf1b6149a7af9cd3f396c86b9182d03e4c727faefae17b746033.js" integrity="sha384-FCCgwEWWc7xoJOe6cT8eDsFUDoZJHa8bYUmnr5zT85bIa5GC0D5Mcn&#43;u&#43;uF7dGAz"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.dd4cfdb9c1bcaa687c9794e0620c478af43dec711c465b0560c274a0c20d6023bc183b8817015eb778ab746927905d6e.js" integrity="sha384-3Uz9ucG8qmh8l5TgYgxHivQ97HEcRlsFYMJ0oMINYCO8GDuIFwFet3irdGknkF1u"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.cd363f7498fd08d5e75d97ca1f2510d87d073b35592ba69016728082f8e5e9db33b432643010810a6e88152c4f650059.js" integrity="sha384-zTY/dJj9CNXnXZfKHyUQ2H0HOzVZK6aQFnKAgvjl6dsztDJkMBCBCm6IFSxPZQBZ"></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.d120034e53740430f5243f8e25b646e7bdcca97780e02962c37e3adefb264c1b457f8fc397698851f42e32d7168bdd1e.js" integrity="sha384-0SADTlN0BDD1JD&#43;OJbZG573MqXeA4Cliw3463vsmTBtFf4/Dl2mIUfQuMtcWi90e"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/katex/katex.min.3f04544ff62a6e71239193b4cd9c4da9cc400ab5defa3efae94d9a997720320e78e7baef7b663b23a6494a6d80d264b8.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe&#43;j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f95071777afa5e0511c9caad675d7b9d8c38e0e39c21ac79e99e1d09159bc723edd0aa1a875b87a0ad28e3efd1444d39.js" integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.c30ff9f376878715a4cf90c4567e8e2ad36221a2e2da20513595df251898d408bbb6727d517a44b32bce2135694e5e00.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.453374f1ad005c88a83c1715a2c12a3d47ca2beacfa7e875c7f8b347bc4c91d332bb091c64259dc4ef914b0205b495cd.js" integrity="sha384-RTN08a0AXIioPBcVosEqPUfKK&#43;rPp&#43;h1x/izR7xMkdMyuwkcZCWdxO&#43;RSwIFtJXN" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-J5NHMZLLDX', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-J5NHMZLLDX" async></script><script>
			var _hmt = _hmt || [];
			(function() {
			  var hm = document.createElement("script");
			  hm.src = "https://hm.baidu.com/hm.js?9370523af547bac6b97e9c3b1461cd16";
			  var s = document.getElementsByTagName("script")[0]; 
			  s.parentNode.insertBefore(hm, s);
			})();
		</script></div>
</body>

</html>