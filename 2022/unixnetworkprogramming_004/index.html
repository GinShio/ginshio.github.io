

<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>基本 TCP 编程 - iris</title><meta name="Description" content="GinShio | Unix 网络编程：卷一 (3rd) 第二部分第四章：基础 TCP 套接字编程、第五章：TCP 客户端/服务器示例"><meta property="og:url" content="https://blog.ginshio.org/2022/unixnetworkprogramming_004/">
  <meta property="og:site_name" content="iris">
  <meta property="og:title" content="基本 TCP 编程">
  <meta property="og:description" content="GinShio | Unix 网络编程：卷一 (3rd) 第二部分第四章：基础 TCP 套接字编程、第五章：TCP 客户端/服务器示例">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-02-19T15:31:05+08:00">
    <meta property="article:modified_time" content="2022-04-07T19:45:03+08:00">
    <meta property="article:tag" content="Note">
    <meta property="article:tag" content="Unix">
    <meta property="article:tag" content="Network">
    <meta property="article:tag" content="Posix">
    <meta property="article:tag" content="TCP">
    <meta property="og:image" content="https://blog.ginshio.org/avatar.webp">
      <meta property="og:see_also" content="https://blog.ginshio.org/2022/unixnetworkprogramming_001/">
      <meta property="og:see_also" content="https://blog.ginshio.org/2022/unixnetworkprogramming_002/">
      <meta property="og:see_also" content="https://blog.ginshio.org/2022/unixnetworkprogramming_003/">
      <meta property="og:see_also" content="https://blog.ginshio.org/2022/unixnetworkprogramming_005/">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://blog.ginshio.org/avatar.webp">
  <meta name="twitter:title" content="基本 TCP 编程">
  <meta name="twitter:description" content="GinShio | Unix 网络编程：卷一 (3rd) 第二部分第四章：基础 TCP 套接字编程、第五章：TCP 客户端/服务器示例">
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" /><link rel="prev" href="https://blog.ginshio.org/2022/unixnetworkprogramming_003/" /><link rel="next" href="https://blog.ginshio.org/2022/unixnetworkprogramming_005/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/color.34e5eb0ed3195c558eb6994b94f6ce01b4d7121bda08365c4f94b70d178301efdb761cb63c963c02c67c45152c3c9498.css" integrity="sha384-NOXrDtMZXFWOtplLlPbOAbTXEhvaCDZcT5S3DReDAe/bdhy2PJY8AsZ8RRUsPJSY"><link rel="stylesheet" href="/css/style.min.71903c93e482438bcb694a21934b32795f3f9dc2c7076dadfa66ca836805f90335eae546d168ddaa1c5de8eda3532d79.css" integrity="sha384-cZA8k&#43;SCQ4vLaUohk0syeV8/ncLHB22t&#43;mbKg2gF&#43;QM16uVG0Wjdqhxd6O2jUy15"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <meta name="google-site-verification" content="fbzw9fQcZyEFrrrUtxLfzYW-qhZ5TMEZKHHSp9NeLBw" /><meta name="msvalidate.01" content="EC9CEC799D42793C414AE7BDB0D0205C" /><meta name="yandex-verification" content="c0b808dd3e49f730" /><meta name="baidu-site-verification" content="code-RhPhu2ccLc" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "基本 TCP 编程",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2022\/unixnetworkprogramming_004\/"
        },"image": ["https:\/\/blog.ginshio.org\/screenshot.png"],"genre": "posts","keywords": "Note, Unix, Network, Posix, TCP","wordcount":  3427 ,
        "url": "https:\/\/blog.ginshio.org\/2022\/unixnetworkprogramming_004\/","datePublished": "2022-02-19T15:31:05+08:00","dateModified": "2022-04-07T19:45:03+08:00","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/avatar.webp"},"authors": [{
                        "@type": "Person",
                        "name": "GinShio"                    
                    }],"description": "GinShio | Unix 网络编程：卷一 (3rd) 第二部分第四章：基础 TCP 套接字编程、第五章：TCP 客户端/服务器示例"
    }
    </script><script src="//instant.page/5.1.1" defer type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>
</head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme; }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="#" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#基本-tcp-套接字函数">基本 TCP 套接字函数</a>
      <ul>
        <li><a href="#socket-函数">socket 函数</a></li>
        <li><a href="#connect-函数">connect 函数</a></li>
        <li><a href="#bind-函数">bind 函数</a></li>
        <li><a href="#listen-函数">listen 函数</a></li>
        <li><a href="#accept-函数">accept 函数</a></li>
      </ul>
    </li>
    <li><a href="#并发服务器">并发服务器</a>
      <ul>
        <li><a href="#fork">fork</a></li>
        <li><a href="#exec">exec</a></li>
        <li><a href="#getsockname-和-getpeername">getsockname 和 getpeername</a></li>
        <li><a href="#时间获取服务的并发示例">时间获取服务的并发示例</a></li>
      </ul>
    </li>
    <li><a href="#tcp-echo-服务">TCP Echo 服务</a>
      <ul>
        <li><a href="#tcp-echo-服务器">TCP Echo 服务器</a></li>
        <li><a href="#tcp-echo-客户端">TCP Echo 客户端</a></li>
        <li><a href="#echo-服务端的启动与终止">echo 服务端的启动与终止</a>
          <ul>
            <li><a href="#启动">启动</a></li>
            <li><a href="#终止">终止</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#posix-信号处理">POSIX 信号处理</a>
      <ul>
        <li><a href="#信号">信号</a></li>
        <li><a href="#信号处理">信号处理</a></li>
      </ul>
    </li>
    <li><a href="#意外情况下的程序终止">意外情况下的程序终止</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">基本 TCP 编程</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/api/"><i class="far fa-folder fa-fw"></i>API</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/unp-note/"><i class="far fa-list-alt fa-fw"></i>UNP Note</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="02-19">02-19</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="04-07">04-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3427 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div>
        </div><div class="details series-nav open">
                                <div class="details-summary series-title">
                                    <span>系列 - UNP Note</span>
                                    <span><i class="details-icon fas fa-angle-right"></i></span>
                                </div>
                                <div class="details-content series-content">
                                    <nav>
                                        <ul>
                                                    <li><a href="/2022/unixnetworkprogramming_001/">UNP 简介</a></li>
                                                    <li><a href="/2022/unixnetworkprogramming_002/">传输层总述</a></li>
                                                    <li><a href="/2022/unixnetworkprogramming_003/">Unix 套接字 API</a></li><li><span class="active">基本 TCP 编程</span></li>
                                                    <li><a href="/2022/unixnetworkprogramming_005/">I/O 复用</a></li></ul>
                                    </nav>
                                </div>
                            </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#基本-tcp-套接字函数">基本 TCP 套接字函数</a>
      <ul>
        <li><a href="#socket-函数">socket 函数</a></li>
        <li><a href="#connect-函数">connect 函数</a></li>
        <li><a href="#bind-函数">bind 函数</a></li>
        <li><a href="#listen-函数">listen 函数</a></li>
        <li><a href="#accept-函数">accept 函数</a></li>
      </ul>
    </li>
    <li><a href="#并发服务器">并发服务器</a>
      <ul>
        <li><a href="#fork">fork</a></li>
        <li><a href="#exec">exec</a></li>
        <li><a href="#getsockname-和-getpeername">getsockname 和 getpeername</a></li>
        <li><a href="#时间获取服务的并发示例">时间获取服务的并发示例</a></li>
      </ul>
    </li>
    <li><a href="#tcp-echo-服务">TCP Echo 服务</a>
      <ul>
        <li><a href="#tcp-echo-服务器">TCP Echo 服务器</a></li>
        <li><a href="#tcp-echo-客户端">TCP Echo 客户端</a></li>
        <li><a href="#echo-服务端的启动与终止">echo 服务端的启动与终止</a>
          <ul>
            <li><a href="#启动">启动</a></li>
            <li><a href="#终止">终止</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#posix-信号处理">POSIX 信号处理</a>
      <ul>
        <li><a href="#信号">信号</a></li>
        <li><a href="#信号处理">信号处理</a></li>
      </ul>
    </li>
    <li><a href="#意外情况下的程序终止">意外情况下的程序终止</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="基本-tcp-套接字函数" class="headerLink">
    <a href="#%e5%9f%ba%e6%9c%ac-tcp-%e5%a5%97%e6%8e%a5%e5%ad%97%e5%87%bd%e6%95%b0" class="header-mark"></a>基本 TCP 套接字函数</h2><figure><img src="/images/unp-socket-functions-for-elementary-tcp-client-and-server.svg" width="40%">
</figure>

<h3 id="socket-函数" class="headerLink">
    <a href="#socket-%e5%87%bd%e6%95%b0" class="header-mark"></a>socket 函数</h3><p>在网络编程中第一步往往调用 socket 函数，以指定通讯协议的详情。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return socket fd, or -1 and set errno on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>domain 指协议族，type 是套接字类型，protocol 参数应该设置为某个协议类型常量，或者为 0 表示对 domain 与 type 的系统默认值。</p>
<ul>
<li>domain
<ul>
<li><code>AF_INET</code>: IPv4 协议</li>
<li><code>AF_INET6</code>: IPv6 协议</li>
<li><code>AF_UNIX</code> or <code>AF_LOCAL</code>: Unix Domain Socket</li>
<li><code>AF_ROUTE</code>: 路由套接字</li>
<li><code>AF_KEY</code>: 密钥套接字</li>
</ul>
</li>
<li>type
<ul>
<li><code>SOCK_STREAM</code>: 字节流套接字</li>
<li><code>SOCK_DGRAM</code>: 数据报套接字</li>
<li><code>SOCK_SEQPACKET</code>: 有序分组套接字</li>
<li><code>SOCK_RAW</code>: 原始套接字</li>
</ul>
</li>
<li>protocol (for IPv4 and IPv6)
<ul>
<li><code>IPPROTO_TCP</code></li>
<li><code>IPPROTO_UDP</code></li>
<li><code>IPPROTO_SCTP</code></li>
</ul>
</li>
</ul>
<p>需要注意的是，不是所有的组合都是有效的，下表总结了有效的 socket 函数参数组合，空白意味着无效。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left"></th>
          <th style="text-align: left">AF_INET</th>
          <th style="text-align: left">AF_INET6</th>
          <th style="text-align: left">AF_LOCAL</th>
          <th style="text-align: left">AF_ROUTE</th>
          <th style="text-align: left">AF_KEY</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">SOCK_STREAM</td>
          <td style="text-align: left">TCP or SCTP</td>
          <td style="text-align: left">TCP or SCTP</td>
          <td style="text-align: left">YES</td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">SOCK_DGRAM</td>
          <td style="text-align: left">UDP</td>
          <td style="text-align: left">UDP</td>
          <td style="text-align: left">YES</td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">SOCK_SEQPACKET</td>
          <td style="text-align: left">SCTP</td>
          <td style="text-align: left">SCTP</td>
          <td style="text-align: left">YES</td>
          <td style="text-align: left"></td>
          <td style="text-align: left"></td>
      </tr>
      <tr>
          <td style="text-align: left">SOCK_RAM</td>
          <td style="text-align: left">IPv4</td>
          <td style="text-align: left">IPv6</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">YES</td>
          <td style="text-align: left">YES</td>
      </tr>
  </tbody>
</table>
<p>参数 domain 与 type 还有一些其他值，必须 4.4BSD 支持的 AF_NS (Xerox NS protocols
or XNS) 和 AF_ISO (OSI protocols)，而 Linux 表述了 SOCK_PACKET 这样的 type 参数来表示 BPF 类似的协议。AF_KEY 采用内核中密钥表的接口来实现的加密的。</p>
<p>另外说一下 AF 是 Adress Family 的缩写，而 PF 是 protocol family 的缩写，由于历史原因：单个 PF 可以支持多个 AF，但这从未实现过，因此在一些实现中 PF_xxx 总与
AF_xxx 相等。</p>
<h3 id="connect-函数" class="headerLink">
    <a href="#connect-%e5%87%bd%e6%95%b0" class="header-mark"></a>connect 函数</h3><p>connect 函数被用于 TCP 客户端与服务端之间建立连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>sockfd 是由 socket 函数成功调用时返回的套接字文件描述符，addr 是上一篇讲解过的通用套接字地址结构，最后的参数 addrlen 则是对 addr 取 sizeof 所得的大小。</p>
<p>客户端无需在 connect 之前调用 bind 来绑定端口，在需要时 OS 会选择一个临时端口与服务端进行通信。对于 TCP socket 来说，connect 函数会初始化三次握手，在返回时连接是建立完成的，或建立失败。我们可以从 errno 中获取一些出错原因：</p>
<ol>
<li>TCP 客户端没有收到 SYN-ACK 响应，返回 <strong>ETIMEDOUT</strong> 错误。比如 4.4BSD 上的客户端发送 SYN 后，分别在无响应 6s、24s 后再发送一个 SYN 请求，总计 75s 仍无响应则返回该错误</li>
<li>TCP 服务端对 SYN 响应 RST (复位)，表明主机在端口上没有等待连接的进程，这是一个 <strong>硬错误</strong> (hard error)，在收到 RST 后立即返回 <strong>ECONNREFUSED</strong> 错误</li>
<li>若 TCP 发送 SYN 请求时，链路上某个路由发生 <code>destination unreachable</code> (目的地址不可达) 的 ICMP 错误，则认为是 <strong>软错误</strong> (soft error)。内核将保留消息并按第一种错误的时间间隔重新发送请求，仍未响应的情况下返回 <strong>EHOSTUNREACH</strong> 或
<strong>ENETUNREACH</strong> 错误</li>
</ol>
<p>从 TCP 状态转换图来看，connect 函数将状态从 CLOSED 转移到 SYN_SENT，若成功则转移到 ESTABLISHED；失败时该套接字不可再次 connect，需要调用 close 函数关闭套接字文件描述符，然后重新调用 socket 创建新的套接字。</p>
<h3 id="bind-函数" class="headerLink">
    <a href="#bind-%e5%87%bd%e6%95%b0" class="header-mark"></a>bind 函数</h3><p>bind 函数将协议地址与一个套接字文件描述符进行绑定。bind 原型与 connect 类似。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>对于 TCP 套接字，bind 可以指定端口号或 IP 地址，或两者都指定，也可以两者都不指定</p>
<ul>
<li>TCP 如果没有经过 bind 就调用 connect 或 listen 时，内核会为其绑定一个临时端口</li>
<li>TCP 可以 bind 一个属于主机的网络接口之一的 IP 地址，对于客户端来说这是个源
IP 地址，而对服务端来说，这限定了只接收哪些目的地址的 IP。通常客户端不会绑定
IP，由内核根据外出网络接口决定源 IP 地址；服务器没有绑定 IP 时，内核会把客户发送 SYN 的目的地址作为服务器的源 IP 地址</li>
</ul>
<p>下表总结了 bind 对于 ip 与 port 指定或不指定时的结果</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">指定 IP 地址</th>
          <th style="text-align: left">指定 port</th>
          <th style="text-align: left">结果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">通配地址</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">内核选择 IP 与 port</td>
      </tr>
      <tr>
          <td style="text-align: left">通配地址</td>
          <td style="text-align: left">非 0</td>
          <td style="text-align: left">内核选择 IP，进程指定 port</td>
      </tr>
      <tr>
          <td style="text-align: left">本地 IP 地址</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">内核选择 port，进程指定 IP</td>
      </tr>
      <tr>
          <td style="text-align: left">本地 IP 地址</td>
          <td style="text-align: left">非 0</td>
          <td style="text-align: left">进程指定 IP 和 port</td>
      </tr>
  </tbody>
</table>
<p>对于 IPv4 来说，通配地址通常使用 <strong>INADDR_ANY</strong> 来指定，其值一般为 0 (0.0.0.0)，而
IPv6 中使用结构变量 <strong>in6addr_any</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// IPv4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr4</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">sin_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// IPv6
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="n">addr6</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">sin6_addr</span> <span class="o">=</span> <span class="n">in6addr_any</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在不指定端口时，bind 并无法获取分配的临时端口，需要调用函数 <code>getsockname</code> 来获取。</p>
<p>bind 常见的错误是 <strong>EADDRINUSE</strong> (Address already in use)，这在以后再详细说明。</p>
<h3 id="listen-函数" class="headerLink">
    <a href="#listen-%e5%87%bd%e6%95%b0" class="header-mark"></a>listen 函数</h3><p>在 TCP 服务器中需要调用 listen 函数，这个函数会完成以下两个行为：</p>
<ol>
<li>当套接字通过 socket 函数创建时，一般认为这是个主动连接套接字，也就是给客户端调用 connect 函数的。而 listen 可以将其转变为未连接的被动套接字，内核将连接进来的请求直接连接到这个套接字上。也就是说，在状态转换图上看，listen 将状态从 CLOSED 转换到 LISTEN</li>
<li>第二个参数往往指定内核开放的该套接字的连接队列的大小</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>通常情况下 listen 在 socket 和 bind 之后调用，在 accept 之前调用。为了明白参数
backlog，需要认识到内核会为 TCP 连接维护两个队列：</p>
<ol>
<li>接入队列，或者称半连接队列，这是 TCP 服务器接收到 SYN 请求并发送 SYN-ACK 后等待第三次握手时，所建立的客户端套接字队列</li>
<li>完成队列，这个队列中包含了完成三次握手的客户端套接字，这些套接字都是
ESTABLISHED 状态</li>
</ol>
<figure><img src="/images/unp-the-two-queues-maintained-by-tcp-listening.svg" width="64%">
</figure>

<p>当请求接入后，系统将自动地创建新连接并将监听的套接字信息复制到连接中，整个过程是自动化的，无需 server 进程插手。在 server 进行 SYN-ACK 回复后状态变为 SYN_RCVD，将连接放入半连接队列等待客户端回应。如果客户端连接超时则会将其从半连接队列中删除，连接完成后进入 ESTABLISHED 状态，并将该连接从半连接队列移至完成队列的末尾，等待
accept 将其取出进行通信。</p>
<p>关于这两个队列，需要考虑以下几点：</p>
<ul>
<li>listen 的第二个参数 backlog 基于历史原因，是指定两个队列的总和的最大值。在
4.2BSD 帮助手册上定义其为 <code>the maximum length the queue of pending connections may grow to</code> (等待的连接队列的最大可增长长度)，不过没有定义什么是等待的连接，是 SYN_RCVD 还是 ESTABLISHED 或者两者都是</li>
<li>基于 Berkeley 的实现为 backlog 增添了模糊因子 (fudge factor)，最终结果为
backlog 乘以 <strong>1.5</strong></li>
<li>不要将 backlog 设置为 0，在不同的实现上对此解释也不同，如果不想接收连接就直接关闭监听连接</li>
<li>在指定 backlog 时可以设置为比内核支持的最大值还要大的值，内核往往会将其改为自身支持的最大值而非返回错误</li>
<li>Linux 帮助手册的 NOTES 部分解释了 Linux 上 backlog 的实现行为，自 Linux 2.2
开始该参数指定的是完成队列的最大大小，即 ESTABLISHED 状态的连接队列。半连接状态队列大小可以通过 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 进行修改，而
backlog 的最大值在 <code>/proc/sys/net/core/somaxconn</code> 中，通常为 128</li>
<li>当队列满时，一个 SYN 请求到达时 TCP 将会忽略该请求而非 RST。这是因为过满的情况是暂时的，重传 SYN 时期望可以找到可用空间，而返回 RST 会终止正常的 TCP 重传机制，还会让客户端无法区分错误</li>
<li>三次握手完成后，在服务器调用 accept 之前到达的数据由服务器 TCP 进行排队，最大数据量为相应已连接套接字的接收缓冲区大小</li>
</ul>
<p>下表是 unp 给出的各个操作系统下，backlog 参数取不同值时已排队连接的实际数目。可以看到 AIX 与 MacOS 遵循传统的 Berkeley 算法，Solaris 也有类似的算法，而 FreeBSD
则是 backlog 值 \(+1\)。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">backlog</th>
          <th style="text-align: left">MaxOS 10.2.6 / AIX 5.1</th>
          <th style="text-align: left">Linux 2.4.7</th>
          <th style="text-align: left">HP-UX 11.11</th>
          <th style="text-align: left">FreeBSD 5.1</th>
          <th style="text-align: left">Solaris 2.9</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">2</td>
      </tr>
      <tr>
          <td style="text-align: left">2</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">5</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">4</td>
      </tr>
      <tr>
          <td style="text-align: left">3</td>
          <td style="text-align: left">5</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">5</td>
      </tr>
      <tr>
          <td style="text-align: left">4</td>
          <td style="text-align: left">7</td>
          <td style="text-align: left">7</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">5</td>
          <td style="text-align: left">6</td>
      </tr>
      <tr>
          <td style="text-align: left">5</td>
          <td style="text-align: left">8</td>
          <td style="text-align: left">8</td>
          <td style="text-align: left">7</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">8</td>
      </tr>
      <tr>
          <td style="text-align: left">6</td>
          <td style="text-align: left">10</td>
          <td style="text-align: left">9</td>
          <td style="text-align: left">9</td>
          <td style="text-align: left">7</td>
          <td style="text-align: left">10</td>
      </tr>
      <tr>
          <td style="text-align: left">7</td>
          <td style="text-align: left">11</td>
          <td style="text-align: left">10</td>
          <td style="text-align: left">10</td>
          <td style="text-align: left">8</td>
          <td style="text-align: left">11</td>
      </tr>
      <tr>
          <td style="text-align: left">8</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">11</td>
          <td style="text-align: left">12</td>
          <td style="text-align: left">9</td>
          <td style="text-align: left">13</td>
      </tr>
      <tr>
          <td style="text-align: left">9</td>
          <td style="text-align: left">14</td>
          <td style="text-align: left">12</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">10</td>
          <td style="text-align: left">14</td>
      </tr>
      <tr>
          <td style="text-align: left">10</td>
          <td style="text-align: left">16</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">15</td>
          <td style="text-align: left">11</td>
          <td style="text-align: left">16</td>
      </tr>
      <tr>
          <td style="text-align: left">11</td>
          <td style="text-align: left">17</td>
          <td style="text-align: left">14</td>
          <td style="text-align: left">16</td>
          <td style="text-align: left">12</td>
          <td style="text-align: left">17</td>
      </tr>
      <tr>
          <td style="text-align: left">12</td>
          <td style="text-align: left">19</td>
          <td style="text-align: left">15</td>
          <td style="text-align: left">18</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">19</td>
      </tr>
      <tr>
          <td style="text-align: left">13</td>
          <td style="text-align: left">20</td>
          <td style="text-align: left">16</td>
          <td style="text-align: left">19</td>
          <td style="text-align: left">14</td>
          <td style="text-align: left">20</td>
      </tr>
      <tr>
          <td style="text-align: left">14</td>
          <td style="text-align: left">22</td>
          <td style="text-align: left">17</td>
          <td style="text-align: left">21</td>
          <td style="text-align: left">15</td>
          <td style="text-align: left">22</td>
      </tr>
  </tbody>
</table>
<h3 id="accept-函数" class="headerLink">
    <a href="#accept-%e5%87%bd%e6%95%b0" class="header-mark"></a>accept 函数</h3><p>accept 是 TCP 服务端在 listen 之后的需要调用的函数，该函数返回一个完成队列中的连接，如果完成队列为空，则会阻塞服务器进程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">cliaddr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return non-negative descriptor if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>参数 cliaddr 与 addrlen 是结果参数，调用时，将 addrlen 设置为 cliaddr 的套接字地址结构长度；返回时，该整数被内核设置为结构的确切字节值。如果对客户端的地址不感兴趣，可以将这两个参数在调用时设置为 <code>NULL</code>。成功时返回值是内核自动生成的一个套接字描述符，这是与其连接的客户端的描述符。</p>
<p>想想第一篇的时间获取客户端，这里给出该客户端对应的时间获取服务端，以这个程序作为例子讲解。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 以下代码与 UNP intro/daytimetcpsrv1.c 等价
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// inet_pton/3, htons/1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// struct sockaddr_in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// errno
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// socket/3, connect/3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// read/3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAXLINE 4096
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LISTENQ 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">err_sys</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nf">vsnprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">snprintf</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">MAXLINE</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="s">&#34;:%s&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nf">strcat</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fputs</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fflush</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">err_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="nf">vsnprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">strcat</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fputs</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fflush</span><span class="p">(</span><span class="n">stderr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">listenfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">connfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_msg</span><span class="p">(</span><span class="s">&#34;accept error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;connection from %s, port %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="nf">inet_ntop</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">INET_ADDRSTRLEN</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">           <span class="nf">ntohs</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">ticks</span> <span class="o">=</span> <span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">snprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">&#34;%.24s</span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_msg</span><span class="p">(</span><span class="s">&#34;write error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在我的本地，编译该文件，用 daytimetcpcli 请求时间，服务器输出如下</p>
<div class="verse">
<p>connection from 127.0.0.1, port 49736<br />
connection from 192.168.0.105, port 53886<br /></p>
</div>
<p>与之前的客户端程序很相似，需要注意的是，程序一次调用 socket、bind、listen，之后在一个无限循环中调用 accept 接收请求，并在每次请求完成后，关闭与客户端的连接，进行下一次请求。</p>
<h2 id="并发服务器" class="headerLink">
    <a href="#%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8" class="header-mark"></a>并发服务器</h2><p>现在的服务端程序可以很好的运行，但是只能一次接受一个请求，如果请求很多且单次请求处理时间较长时，显然是不能满足及时响应客户请求的。于此，一个简单的方式诞生了，即创建一个新的进程，在这个新进程中处理请求，而老进程的任务变为接收请求并启动新进。这样每次有新请求时，都会开启一个新进程来处理，老进程可以继续无间断的接受新请求。</p>
<h3 id="fork" class="headerLink">
    <a href="#fork" class="header-mark"></a>fork</h3><p>在 Unix 操作系统中，有一个简单启动新进程的方式，即 <strong>fork</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// unistd.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 in child, process ID of child in parent, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>fork 是一个启动新进程的方式，该 syscall 会复制一份一模一样的进程环境作为新进程，新进程被称作子进程 (child process)，而老进程称为父进程 (parent process)。fork 在
parent 与 child 中都有返回值，child 中 fork 返回 0 表示调用成功，而 parent 中返回的是 child 的进程 ID (pid)，在不同的进程中不同的返回值可以让程序员知道当前身处哪个进程。fork 是比较特殊的函数，由于其创建新进程和两个不同的返回值的特性，需要特别注意。</p>
<p>首先介绍下 fork 的两个典型用法：</p>
<ol>
<li>创建自身进程的副本，每个副本都可以执行不同的操作，即网络服务器的典型操作</li>
<li>一个进程想要执行另一个程序，先创建一个副本，再通过副本调用其他 syscall (后面讲到的 exec) 替换为新的程序，这是 shell 程序的典型用法</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// example
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;  // fork, getpid, getppid</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAXLINE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">ppid</span> <span class="o">=</span> <span class="nf">getppid</span><span class="p">();</span>  <span class="c1">// 获取该进程的父进程 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>    <span class="c1">// 获取该进程的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">id</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 拷贝进程副本，即所有全局变量，与以上的所有变量、数据都被拷贝到新的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前分支由子进程执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ppid 与 pid 为副本存在于子进程中，值目前为止没有改变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">strcat</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;new process&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in %s, ppid: %d, pid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ppid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改 ppid 与 pid 的值，不影响父进程中的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>    <span class="c1">// 获取当前进程的 ID，即子进程的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ppid</span> <span class="o">=</span> <span class="nf">getppid</span><span class="p">();</span>  <span class="c1">// 获取当前进程的父进程 ID，即父进程的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in %s, ppid: %d, pid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ppid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前分支由父进程执行，id 值为子进程的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">strcat</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;old process&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in %s, ppid: %d, pid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ppid</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 由于在父进程中，重新获取后值应该不变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pid</span> <span class="o">=</span> <span class="nf">getpid</span><span class="p">();</span>    <span class="c1">// 获取当前进程的 ID，即子进程的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ppid</span> <span class="o">=</span> <span class="nf">getppid</span><span class="p">();</span>  <span class="c1">// 获取当前进程的父进程 ID，即父进程的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 子进程 ID 是 fork 为父进程返回的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in %s, ppid: %d, pid: %d, spid: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">ppid</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;fork error</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 因为分支结束，这里是所有分支都会执行的代码，即子进程、父进程都会执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;in %s, end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述程序可能的输出</p>
<div class="verse">
<p>in old process, ppid: 17081, pid: 17975<br />
in old process, ppid: 17081, pid: 17975, spid: 17976<br />
in old process, end<br />
in new process, ppid: 17081, pid: 17975<br />
in new process, ppid: 17975, pid: 17976<br />
in new process, end<br /></p>
</div>
<p>或</p>
<div class="verse">
<p>in old process, ppid: 17081, pid: 17961<br />
in old process, ppid: 17081, pid: 17961, spid: 17962<br />
in old process, end<br />
in new process, ppid: 17081, pid: 17961<br />
in new process, ppid: 1, pid: 17962<br />
in new process, end<br /></p>
</div>
<p>可以看到可能的输出中，子进程可能的父进程 ID 变为了 1，这是由于父进程在子进程之前结束生命周期，导致子进程成为孤儿进程，该进程由 init 进程 (id: 1) 收养所导致的子进程父进程变为 1。如果不希望这种事情发生，可以在父进程中使用 <code>wait</code> 或 <code>waitpid</code>
等待子进程结束，这在以后的 APUE 笔记中介绍。</p>
<h3 id="exec" class="headerLink">
    <a href="#exec" class="header-mark"></a>exec</h3><p>存放在硬盘中的可执行文件能够被 Unix 执行的唯一方法是：由一个现有进程调用 syscall
exec 系列函数中的一个 (共 6 个，这些函数被统称为 exec)，exec 可以将当前进程映像替换为新的进程文件，从新进程的 main 函数开始执行，而进程的 ID 不会改变。通常称调用 exec 的进程为 <strong>调用进程</strong> (calling process)，而新执行的程序称为 <strong>新程序</strong> (new
program)。</p>
<p>6 个 exec 函数分为三种</p>
<ol>
<li>待执行的程序文件是由文件名 (filename) 还是路径名 (pathname) 指定</li>
<li>新程序的参数是一一列出还是指针数组引用</li>
<li>调用进程的环境进行传递还是指定新环境</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// unistd.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">execlp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* (char  *)</span> <span class="nb">NULL</span> <span class="err">*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">execl</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* (char  *)</span> <span class="nb">NULL</span> <span class="err">*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">execvp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">execv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">execle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/*, (char *)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">envp</span><span class="p">[]</span> <span class="err">*/</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return -1 on error, no return on success
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这些函数只有错误时才返回到调用者，否则将从新程序的起始点 (通常为 main) 开始。一般 execve 是 syscall，而其他 5 个是调用 execve 的库函数，glibc 扩展了一个与
execve 的库函数 execvpe，检测宏为 <strong>_GNU_SOURCE</strong>。</p>
<figure><img src="/images/unp-relationship-between-exec-family-functions.svg" width="90%">
</figure>

<p>需要注意几点：</p>
<ul>
<li>execl、execlp、execle 三个参数将程序的每个字符串参数作为独立的参数传递给
exec，并以 NULL 作为程序参数结束的标志。而 execvp、execv、execve 三个参数将程序的字符串参数作为参数数组 argv 的一部分进行传递，由于没有传递该数组的长度，因此约定 argv 的末尾必须含有空指针 NULL 来标记结尾。</li>
<li>最左侧的 execlp 与 execvp 两个函数指定的是 file，exec 函数将当前的环境变量
PATH 作为查找程序的依据。但如果 file 参数字符串中存在 <code>/</code>，则在当前程序的工作目录 (workpath) 中查找程序，而非 PATH 环境变量中。</li>
<li>execl、execlp、execv、execvp 四个函数均不指定环境变量，因此使用外部变量
<strong>environ</strong> (man 7) 作为环境变量列表。execle 与 execve 使用用户指定的环境变量列表，同 argv 一样，需要用户传递的 envp 也以 NULL 结尾。</li>
<li>通常进程打开的所有文件描述符，在 exec 切换程序后都会保留，继续打开。可以通过
fcntl 设置 FD_CLOEXEC 来禁止该默认行为。</li>
</ul>
<h3 id="getsockname-和-getpeername" class="headerLink">
    <a href="#getsockname-%e5%92%8c-getpeername" class="header-mark"></a>getsockname 和 getpeername</h3><p>这两个函数与某个套接字关联的本端协议地址 (getsockname) 或对端协议地址
(getpeername) 相关的操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// sys/socket.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">getsockname</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">getpeername</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>简单的说就是用来获取已知套接字描述符，但不知道地址结构的套接字，具体用法如下：</p>
<ul>
<li>在 TCP 客户端 connect 成功返回后，使用 <code>getsockname</code> 获取内核赋予的本地 IP
地址与本地端口号</li>
<li>在以端口号为 0 或通配 IP 地址 (INADDR_ANY) 的 bind 调用，使用 <code>getsockname</code>
获取内核赋予的端口号或 IP (查看 IP 时需要使用 accept 返回的 connfd)</li>
<li><code>getsockname</code> 可以获取某个套接字的协议族 (AF)</li>
<li>在子进程中执行了 exec 操作时，仅可知已连接的客户端的套接字描述符 (其依然保持打开状态)，需要获取客户端 IP 与端口需要使用 <code>getpeername</code></li>
</ul>
<p>在最后一个用法中，需要注意 exec 之后的程序映像，需要获取 connfd 的值，而不是凭空出现 connfd 的值。常用的方式是作为程序的字符串参数进行传递，或约定特定描述符的
ID，也可以修改环境变量传递。</p>
<h3 id="时间获取服务的并发示例" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e8%8e%b7%e5%8f%96%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%b9%b6%e5%8f%91%e7%a4%ba%e4%be%8b" class="header-mark"></a>时间获取服务的并发示例</h3><p>在上面 accept 函数中给出了一个时间获取服务器的代码，这个服务器的实现是一连接一处理的方式，通常称其为 <strong>迭代服务器</strong> (iterative server)。缺点也说过了，对于处理时间较长且请求较多的场景下，是无法接受的，希望服务器可以同时服务更多用户。因此 Unix
环境下最简单的方式就是 fork 和 exec syscall，在子进程中处理请求，父进程只做监听、接收请求的操作。这种模型也就是 <strong>并发服务器</strong> (concurrent server)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// function main in daytimetcpsrv1.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">listenfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nf">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// in child process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>     <span class="c1">// child closes listening socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">dosomething</span><span class="p">();</span>       <span class="c1">// process the request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>       <span class="c1">// done with this client
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>  <span class="c1">// child terminates
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// parent closes connected socket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当连接建立时，accept 返回，此时服务器调用 fork 来创建新进程，listenfd (服务器的监听套接字) 和 connfd (客户端的请求套接字) 都会以副本的形式保留在新进程中，子进程不应该继续打开 listenfd，而父进程应该关闭 connfd。父进程就可以监听 listenfd 从而等待下一个客户端请求的到来，子进程只需要专心为以获取到的 connfd 工作。这就是一个简易的并发服务器模型。</p>
<p>这里有一个问题，close 套接字描述符时不是会导致该连接关闭，为什么子进程还可以正确处理客户端的请求？</p>
<p>每个文件描述符都是引用计数的，系统会维护一个打开的描述符列表，打开文件时会将对应的描述符引用计数 \(+1\)，而关闭时会将引用计数 \(-1\)，只有引用计数为 \(0\) 时系统才会真正的关闭这个文件。换到这里，accept 导致 connfd \(+1\)，而 fork 拷贝副本会导致
listenfd 与 connfd 再次 \(+1\) 从而值为 2，父进程关闭 connfd 不会使其引用计数为 0，这就是不会导致提前回收 connfd 的原因。真正回收 connfd 是在子进程调用 close 或结束时。</p>
<h2 id="tcp-echo-服务" class="headerLink">
    <a href="#tcp-echo-%e6%9c%8d%e5%8a%a1" class="header-mark"></a>TCP Echo 服务</h2><p>Echo 服务器是一种简单且基础的 TCP 服务，默认服务端口 7，支持 TCP 与 UDP 服务。
Echo 服务会将客户端发送的数据完全返回，即请求数据就是响应数据。不过 echo 服务有着正常网络应用该有的一切，如果可以在其基础上，将它修改为需要的网络服务应用。echo
与之前介绍的 daytime 服务不同，daytime 服务由服务器主动断开，而 echo 服务由客户端断开，服务端一直保持连接，客户端主动断开而断开连接。</p>
<p>在以后的代码中不会出现诸如 <code>err_sys</code> 之类的错误处理函数的原型，而是用 <code>unp.h</code> 替代。</p>
<h3 id="tcp-echo-服务器" class="headerLink">
    <a href="#tcp-echo-%e6%9c%8d%e5%8a%a1%e5%99%a8" class="header-mark"></a>TCP Echo 服务器</h3><p>这里直接展示一个 Echo 服务器的程序代码，相对于以前的代码来说，并没有太大的改动。这里将 <code>str_echo</code> 修改为其他行为就可以作为其他网络服务器使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">listenfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">cliaddr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">cliaddrlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cliaddr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">connfd</span> <span class="o">=</span> <span class="nf">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cliaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cliaddrlen</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_msg</span><span class="p">(</span><span class="s">&#34;accept error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="nf">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">str_echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的模板没什么看得，下来好好说一下 echo 服务中的 str_echo，str_echo 只会做一个简单的事：读出客户端的数据并将其重新写回客户端。简单的方式就是，用 read 函数读出数据，再用 write 函数写回即可。但是需要注意的是，这里服务器不会主动断开，而是一直接受客户端的请求并回射，直到被动断开。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">str_echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">=</span> <span class="nf">read</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">str_echo</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;str_echo: read error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="tcp-echo-客户端" class="headerLink">
    <a href="#tcp-echo-%e5%ae%a2%e6%88%b7%e7%ab%af" class="header-mark"></a>TCP Echo 客户端</h3><p>对于客户端来说，main 函数一样是模板</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;unp.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;usage: tcpcli &lt;IPaddress&gt;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">sockfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;socket error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">servaddr</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;inet_pton error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">servaddr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">err_sys</span><span class="p">(</span><span class="s">&#34;connect error&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">str_cli</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>str_cli</code> 可以理解为 <code>dosomething</code> 函数，这里是做所有请求的函数。该函数只做了一件事，循环从标准输入读入一行文本，写入到服务器，等待服务器回射响应，再将结果写入标准输出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">str_cli</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">sendline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="n">FILE</span> <span class="o">*</span><span class="n">sockfd_fp</span> <span class="o">=</span> <span class="nf">fdopen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="s">&#34;r+&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nf">fgets</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">fputs</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">sockfd_fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;str_cli: stop input&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">fgets</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">sockfd_fp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;str_cli: server terminated prematurely&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bzero</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bzero</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="echo-服务端的启动与终止" class="headerLink">
    <a href="#echo-%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%9a%84%e5%90%af%e5%8a%a8%e4%b8%8e%e7%bb%88%e6%ad%a2" class="header-mark"></a>echo 服务端的启动与终止</h3><h4 id="启动" class="headerLink">
    <a href="#%e5%90%af%e5%8a%a8" class="header-mark"></a>启动</h4><p>对于一般程序而言，在命令行中输入程序名称即可运行程序，但对于服务端这样的程序，需要一直运行，但当前终端我们可能需要做其他一些事情，不能一直让服务端占据，可以使用后台启动的方式 (即 fork 到子进程中启动) 运行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./examplesrv <span class="p">&amp;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务器启动后，调用 socket、bind、listen 和 accept，并阻塞于 accept。使用 lsof 命令可以看到 7 号端口的使用信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">lsof -i :7
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">COMMAND     PID    USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
</span></span><span class="line"><span class="cl">examplesr 20246    root    3u  IPv4 802379      0t0  TCP *:echo (LISTEN)
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然也可以使用 netstat 检查服务器监听套接字的状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">netstat -a
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Active Internet connections (servers and established)
</span></span><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:echo            0.0.0.0:*               LISTEN
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>*</code> 或 <code>0.0.0.0</code> 来表示通配地址，netstat 中 <code>:*</code> 表示了为 0 的端口号。这时候启动客户端并指定服务器地址为 127.0.0.1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">./examplecli 127.0.0.1
</span></span></code></pre></td></tr></table>
</div>
</div><p>客户端启动后通过 socket、connect 建立起连接，服务器上 accept 返回，客户端上
connect 返回，连接建立完成，客户端进入 fgets，等待用户输入，服务器子进程被 read
阻塞等待客户输入，父进程则会再次进入 accept 阻塞等待新的连接到来。</p>
<p>此时启动了一个客户端一个服务端，再次通过 netstat 查看网络信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">netstat -a
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Active Internet connections (servers and established)
</span></span><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:echo            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:echo            GinShio:32996           ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:32996           GinShio:echo            ESTABLISHED
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以清楚的看到，由父进程进行的 LISTEN 状态的 sockfd，子进程与客户端在 echo (7)
和 32996 端口建立起了连接，其中 32996 是客户端由系统自动分配的端口。这是再开启一个通过 wlan0 (无线网卡) 连接的客户端，可以得到如下的输出。可以看到有一个地址
192.168.0.0/24 的地址建立起了连接，这两个不同的连接可以同时工作，当然，还可以添加不同的客户端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Active Internet connections (servers and established)
</span></span><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:echo            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 192.168.0.105:46956     192.168.0.105:echo      ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 192.168.0.105:echo      192.168.0.105:46956     ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:echo            GinShio:32996           ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:32996           GinShio:echo            ESTABLISHED
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以通过 ps 命令来查看进程的状态与关系。我这里查看到服务端在 <code>pts/4</code> 上启动，而本地客户端在 <code>pts/5</code> 上，wlan0 客户端在 <code>pts/6</code> 上，通过以下 ps 命令查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># pts/4</span>
</span></span><span class="line"><span class="cl">ps -t pts/4 -o pid,ppid,tty,stat,args,wchan
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  PID  PPID TT       STAT COMMAND                     WCHAN
</span></span><span class="line"><span class="cl">19195 19144 pts/4    Ss+  /bin/zsh                    -
</span></span><span class="line"><span class="cl">20235 19195 pts/4    S    sudo ./examplesrv           -
</span></span><span class="line"><span class="cl">20246 20235 pts/4    S    ./examplesrv                -
</span></span><span class="line"><span class="cl">20254 20246 pts/4    S    ./examplesrv                -
</span></span><span class="line"><span class="cl">20256 20246 pts/4    S    ./examplesrv                -
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># pts/5</span>
</span></span><span class="line"><span class="cl">ps -t pts/5 -o pid,ppid,tty,stat,args,wchan
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  PID  PPID TT       STAT COMMAND                     WCHAN
</span></span><span class="line"><span class="cl">19236 19144 pts/5    Ss   /bin/zsh                    -
</span></span><span class="line"><span class="cl">20253 19236 pts/5    S+   ./examplecli 127.0.0.1      -
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># pts/6</span>
</span></span><span class="line"><span class="cl">ps -t pts/6 -o pid,ppid,tty,stat,args,wchan
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  PID  PPID TT       STAT COMMAND                     WCHAN
</span></span><span class="line"><span class="cl">19277 19144 pts/6    Ss   /bin/zsh                    -
</span></span><span class="line"><span class="cl">20255 19277 pts/6    S+   ./examplecli 192.168.0.105  -
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到所有的进程的 STAT 都是 S，表明进程因等待某些资源而阻塞。</p>
<h4 id="终止" class="headerLink">
    <a href="#%e7%bb%88%e6%ad%a2" class="header-mark"></a>终止</h4><p>客户端程序在处理时，使用 fgets 读入标准输入的数据，当标准输入中输入 EOF
(end-of-file) 字符时 fgets 将返回 NULL，由此可以终止客户端的输入，从而终止客户端程序。在 Unix 系统终端上，Control-D (<code>^D</code>) 即输入 EOF 字符。</p>
<p>终止客户端时，可能在 netstat 看到如下输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">Active Internet connections (servers and established)
</span></span><span class="line"><span class="cl">Proto Recv-Q Send-Q Local Address           Foreign Address         State
</span></span><span class="line"><span class="cl">tcp        0      0 0.0.0.0:echo            0.0.0.0:*               LISTEN
</span></span><span class="line"><span class="cl">tcp        0      0 192.168.0.105:46956     192.168.0.105:echo      TIME_WAIT
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:echo            GinShio:32996           ESTABLISHED
</span></span><span class="line"><span class="cl">tcp        0      0 GinShio:32996           GinShio:echo            ESTABLISHED
</span></span></code></pre></td></tr></table>
</div>
</div><p>客户端在结束输入之后关闭套接字描述符，这导致 TCP 客户端向服务端发送一个 FIN，处于 FIN_WAIT_2 状态，服务端响应 ACK，处于 CLOSE_WAIT 状态。服务端从 str_echo 返回子进程的主函数，通过 exit 终止，打开的套接字描述符关闭，从而发送 FIN 到客户端，并接收客户端发送的 ACK，连接终止，客户端套接字进入 TIME_WAIT 状态。</p>
<p>另外进程终止时，会向父进程发送一个 <strong>SIGCHLD</strong> 信号，服务端代码并没有捕获该代码进行处理，也没有使用 wait 进行处理，从而父进程默认忽略该信号。由于父进程的忽略，子进程进入僵尸状态，在 ps 上显示状态为 Z。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ps -t pts/4 -o pid,ppid,tty,stat,args,wchan
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">  PID  PPID TT       STAT COMMAND                     WCHAN
</span></span><span class="line"><span class="cl">19195 19144 pts/4    Ss+  /bin/zsh                    -
</span></span><span class="line"><span class="cl">20235 19195 pts/4    S    sudo ./examplesrv           -
</span></span><span class="line"><span class="cl">20246 20235 pts/4    S    ./examplesrv                -
</span></span><span class="line"><span class="cl">20254 20246 pts/4    S    ./examplesrv                -
</span></span><span class="line"><span class="cl">20256 20246 pts/4    Z    [examplesrv] &lt;defunct&gt;      -
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 Unix 系统上，这种父进程没有处理回收的进程就是僵尸进程，系统不会释放其占用的资源。当僵尸进程过多时，系统就会出现问题，如进程号不足、内存不足等问题。因此需要及时清理，另外当父进程死亡时，僵尸子进程被过继到 init 进程，此时 init 进程会将负责僵尸进程的资源回收工作。</p>
<p>如果想主动终止服务端进程，可以使用 kill 命令对进程发送相应的信号，以此来终止进程。此时服务器就会作为连接的主动关闭方。</p>
<h2 id="posix-信号处理" class="headerLink">
    <a href="#posix-%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86" class="header-mark"></a>POSIX 信号处理</h2><p>信号 (signal) 就是告知某个进程发生某事的通知，或称为 <strong>软件中断</strong> (software
interrupt)，signal 发生通常是 <strong>异步</strong> 的，信号由内核发送或一个进程向另一个进程发送。每个信号都有一个与之关联的 <strong>处置</strong> (disposition) 或称为 <strong>行为</strong> (action)，处理
sigaction 来设定一个信号的处理，并有三种选择</p>
<ol>
<li>提供回调函数，在特定信号发生时进行回调。这个函数被称为 <strong>信号处理函数</strong>
(signal handler)，这种行为也被称为 <strong>捕获</strong> (catching) 信号。其中信号
<code>SIGKILL</code> 与 <code>SIGSTOP</code> 不能被捕获。signal handler 原型如下
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>将信号设置为 <code>SIG_IGN</code> 对信号进行忽略，当然 SIGKILL 与 SIGSTOP 不能被忽略</li>
<li>将信号设置为 <code>SIG_DFL</code> 进行默认处理</li>
</ol>
<h3 id="信号" class="headerLink">
    <a href="#%e4%bf%a1%e5%8f%b7" class="header-mark"></a>信号</h3><p>信号的默认行为首先有以下几个大类：</p>
<dl>
<dt>Term (终止)</dt>
<dd>信号发生时终止进程</dd>
<dt>Ign (忽略)</dt>
<dd>信号发生时进程忽略该信号</dd>
<dt>Core (内存映像)</dt>
<dd>信号发生时终止进程并生成内存映像</dd>
<dt>Stop (停止)</dt>
<dd>信号发生时停止进程</dd>
<dt>Cont (继续)</dt>
<dd>如果进程已停止，信号发生时继续进程</dd>
</dl>
<p>现在说说都有哪些 POSIX 信号吧</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Signal</th>
          <th style="text-align: left">Standard</th>
          <th style="text-align: left">Value</th>
          <th style="text-align: left">Action</th>
          <th style="text-align: left">Comment</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">SIGHUP</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">终端结束时，通知进程不再与终端关联</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGINT</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">2</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">通过热键终止进程 (C-c)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGQUIT</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">3</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">通过热键终止进程并产生内存映像 (C-\)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGILL</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">4</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">执行了非法指令</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTRAP</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">5</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">追踪 / 断点陷阱</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGABRT</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">调用 abort(3) 产生的信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGFPE</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">8</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">浮点数异常</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGKILL</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">9</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">终结进程</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGBUS</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">10,7,10</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">总线错误 (内存错误)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSEGV</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">11</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">无效内存引用</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSYS</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">12,31,12</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">错误系统调用，见 seccomp(2)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGPIPE</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">13</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">管道破裂：写入无读者管道，见 pipe(7)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGALRM</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">14</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">时钟信号，见 alarm(2)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTERM</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">15</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">可捕获终止信号，要求程序自己正常退出</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGURG</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">16,23,21</td>
          <td style="text-align: left">Ign</td>
          <td style="text-align: left">套接字紧急情况</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSTOP</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">17,19,23</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">停止进程，不可被忽略或处理</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTSTP</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">18,20,24</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">停止进程，可以被忽略或处理</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGCONT</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">19,18,25</td>
          <td style="text-align: left">Cont</td>
          <td style="text-align: left">停止时继续进程</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGCHLD</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">20,17,18</td>
          <td style="text-align: left">Ign</td>
          <td style="text-align: left">子进程停止或终止</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTTIN</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">21,21,26</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">后台进程等待用户从终端输入</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGTTOU</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">22,22,27</td>
          <td style="text-align: left">Stop</td>
          <td style="text-align: left">后台进程等待写入终端</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGXCPU</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">24,24,30</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">超过 CPU 时间限制, 见 setrlimit(2)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGXFSZ</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">25,25,21</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">超过文件大小限制, 见 setrlimit(2)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGVTALRM</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">26,26,28</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">虚拟计时器时钟</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGPROF</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left">27,27,29</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">分析计时器过期</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGUSR1</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">30,10,16</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">用户自定义 1 号信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGUSR2</td>
          <td style="text-align: left">POSIX.1-1990</td>
          <td style="text-align: left">31,12,17</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">用户自定义 2 号信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGPOLL</td>
          <td style="text-align: left">POSIX.1-2001</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">可轮询事件，等价于 SIGIO</td>
      </tr>
  </tbody>
</table>
<p>有些信号的值可能有多个，这是由于不同架构对于信号的定义不同产生的，通常来说，第一列是 Alpha / SPARC，第二列是 x86 / ARM 或其他架构，第三列是 MIPS 架构。对应的值为 <code>-</code> 时表示该架构下没有此信号。</p>
<p>当然除了 POSIX 信号，在 Linux 的 <strong>signal(7)</strong> 用户手册中还可以找到以下信号</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Signal</th>
          <th style="text-align: left">Value</th>
          <th style="text-align: left">Action</th>
          <th style="text-align: left">Comment</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">SIGIOT</td>
          <td style="text-align: left">6</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">IOT 陷阱，等价于 SIGABRT</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGEMT</td>
          <td style="text-align: left">7,-,7</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">模拟器陷阱 (Emulator trap)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGSTKFLT</td>
          <td style="text-align: left">-,16,-</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">协处理器上的堆栈错误 (unused)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGIO</td>
          <td style="text-align: left">23,29,22</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">当前 IO 可用</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGCLD</td>
          <td style="text-align: left">-,-,18</td>
          <td style="text-align: left">Ign</td>
          <td style="text-align: left">等价于 SIGCHLD</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGPWR</td>
          <td style="text-align: left">29,30,19</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">断电信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGINFO</td>
          <td style="text-align: left">29,-,-</td>
          <td style="text-align: left"></td>
          <td style="text-align: left">等同于 SIGPWR</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGLOST</td>
          <td style="text-align: left">-,-,-</td>
          <td style="text-align: left">Term</td>
          <td style="text-align: left">文件锁丢失 (unused)</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGWINCH</td>
          <td style="text-align: left">28,28,20</td>
          <td style="text-align: left">Ign</td>
          <td style="text-align: left">窗口缩放信号</td>
      </tr>
      <tr>
          <td style="text-align: left">SIGUNUSED</td>
          <td style="text-align: left">-,31,-</td>
          <td style="text-align: left">Core</td>
          <td style="text-align: left">等同于 SIGSYS</td>
      </tr>
  </tbody>
</table>
<h3 id="信号处理" class="headerLink">
    <a href="#%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86" class="header-mark"></a>信号处理</h3><p>对信号处理的方式相对简单，即调用 POSIX 方法 sigaction，但是相对复杂的是需要分配并填写相关结构。有一个相对简单的方式即 <strong>signal</strong> 函数，第一个参数是信号名，第二个参数就是指向回调函数的指针，或者宏定义 <code>SIG_IGN</code> 或 <code>SIG_DFL</code>。</p>
<p>signal 函数的原型很复杂，不简化时是这个样子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先其参数为信号名 signo 与回调函数 handler，这个函数类型为无返回值的单参数为
int 的函数指针，signal 函数最终也返回这样的一个函数指针。简化如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// signal.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="kt">sighandler_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">sighandler_t</span> <span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">,</span> <span class="kt">sighandler_t</span> <span class="n">handler</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>捕获信号成功时将返回该处理函数，而失败时会返回常量 <code>SIG_ERR</code>。</p>
<p>现在回过头来看一看 POSIX 函数 sigaction</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// signal.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="n">oldact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// return 0 if OK, -1 on error
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>说实话 sigaction 虽然麻烦但是函数原型好看很多。act 即将要修改的信号的新行为，
oldact 会将旧行为用参数 oldact 返回给用户。</p>
<p>再来看看 sigaction 核心的 struct sigaction</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">sigaction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span>     <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span>     <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">sigset_t</span>   <span class="n">sa_mask</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span>        <span class="n">sa_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span>     <span class="p">(</span><span class="o">*</span><span class="n">sa_restorer</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>sa_handler 即信号处理函数，用法同 signal 中的 handler</li>
<li>sa_sigaction 同样也是信号处理函数</li>
<li>sa_mask 指定需要阻塞的信号集，即捕获发生时将其进行屏蔽</li>
<li>sa_flags 指定修改信号行为的选项集合，不过其很复杂，常用的一些选项如下
<ul>
<li>SA_NODEFER: 在自己的信号处理内不对该信号做屏蔽</li>
<li>SA_RESETHAND: 执行信号处理函数后，将信号操作恢复默认值</li>
<li>SA_RESTART: 通过使某些系统调用可跨信号重新启动，提供与 BSD 信号语义兼容的行为。简单解释就是由信号中断的系统调用由内核自动重启</li>
<li>SA_INTERRUPT: 与 SA_RESTART 互补的操作，信号中断的系统调用不会自动重启</li>
<li>SA_SIGINFO: 提供附加信息，信号捕获行为由 sa_handler 改为 sa_sigaction。
struct siginfo_t 是一个复杂的结构，提供了大量字段来描述相关信息，过于复杂暂时不做讨论</li>
</ul>
</li>
</ul>
<p>这里简单的使用 signal 处理一下之前提到的子进程资源回收的问题。在父进程中，我们应该实现针对 SIGCHLD 的回调函数，在该回调事件中，信号 SIGCHLD 发生时应在父进程内调用 wait 函数用以等待子进程结束并清理资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sig_chld</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="nf">wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child %d terminated&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于这个回调函数非常简单，也能达到我们的目的：清理终止的子进程所占用的资源。当然需要一个合适的位置来调用 signal 注册这个行为，只要在 main 函数的 while 循环之前注册都行，只需要简单的添加一句 <code>signal(SIGCHLD, sig_chld);</code> 即可。</p>
<p>当然你会发现这是不行的，因为这里有一个 <strong>慢系统调用</strong> (slow system call)，即系统调用阻塞进程后不保证返回，服务端中典型的慢系统调用是 accept，当无客户连接时，主进程将永远阻塞在 accept。当进程阻塞在慢系统调用中，捕获信号并在相应行为返回后，这个系统调用可能返回一个 EINTR 错误，或者有些实现中会自动重启被中断的系统调用。因此为了方便在 POSIX 系统之间移植，对慢系统调用的 EINTR 错误处理很重要。</p>
<p>可以将符合 POSIX 的系统上的信号处理总结为以下几点</p>
<ul>
<li>一旦注册了信号处理函数，该行为将一直存在于进程中</li>
<li>在一个信号处理函数运行期间，正在被捕获的信号是阻塞的，sigaction 中的 sa_mask
信号集在此时也是阻塞的</li>
<li>如果信号在阻塞期间产生了一次或多次，那么该信号在唤醒后仅被提交一次，也就是说
Unix 信号默认是不排队的</li>
<li>sigprocmask 函数可以选择性地阻塞或唤醒一组信号</li>
</ul>
<h2 id="意外情况下的程序终止" class="headerLink">
    <a href="#%e6%84%8f%e5%a4%96%e6%83%85%e5%86%b5%e4%b8%8b%e7%9a%84%e7%a8%8b%e5%ba%8f%e7%bb%88%e6%ad%a2" class="header-mark"></a>意外情况下的程序终止</h2><ul>
<li>
<p>accept 函数返回前连接终止</p>
<p>即服务器准备从内核取出连接并处理，但连接中断，收到客户端发送的 RST 请求。这种情况依赖于实现，Berkeley 实现完全在内核中处理中止连接，服务器进程无法看到；
SVR4 实现大多返回错误给进程，一些 SVR4 实现返回 EPROTO (protocol error)，但
POSIX 支持必须返回 ECONNABORTED 错误，因为在某些流子系统中发生某些致命的协议相关事件时也会返回 EPROTO，服务器可能无法分辨这些错误。因此为了让服务器可以忽略该非致命性错误，从而继续调用 accept。</p>
</li>
<li>
<p>SIGPIPE 信号</p>
<p>当客户端 read 返回错误时，客户不理会而是继续写入更多数据，会发生什么？这是内核默认发送一个 SIGPIPE 信号，无论是否捕获或忽略该信号，read 都将返回一个
EPIPE 错误。</p>
<p>将客户端 str_cli 稍加修改，就可以观察到 SIGPIPE 的行为：改为两次调用 write，第一次将文本数据第一个字节写入，引发 RST，暂停 1s 后进行第二次写入，将产生
SIGPIPE。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">str_cli</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">sendline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">recvline</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nf">fgets</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">sendline</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">sendline</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">fgets</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">sockfd_fp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nf">err_quit</span><span class="p">(</span><span class="s">&#34;str_cli: server terminated prematurely&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fputs</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bzero</span><span class="p">(</span><span class="n">sendline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bzero</span><span class="p">(</span><span class="n">recvline</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理 SIGPIPE 信号取决于发生时进程想做什么，如果没有特殊的事则直接忽略，并在后续的操作中检查 EPIPE 错误并终止。</p>
</li>
<li>
<p>服务器主机崩溃</p>
<p>在服务器主机崩溃时，已有的连接上无法发送数据。客户端为连接写入数据，并阻塞于
read 操作等待服务器响应，服务器不会对任何请求进行响应，从而 TCP 连接请求超时，客户端会收到 ETIMEDOUT 错误；如果在某个中间路由上检测到服务器不可达，则会返回 &ldquo;destination unreachable&rdquo; (目的地不可达) 的 ICMP 消息，并返回
EHOSTUNREACH 或 ENETUNREACH 错误。</p>
</li>
<li>
<p>服务器主机崩溃后重启</p>
<p>服务器主机崩溃，上一点简单的描述了崩溃没有恢复的情况，现在讨论一下服务器主机恢复的情况。</p>
<p>此时客户端发送请求到服务器上，由于已崩溃重启，客户端并不知道服务器有重启，但服务器并没有客户端的连接相关数据，此时客户端 TCP 收到 RST，read 调用返回
ECONNRESET 错误。</p>
</li>
<li>
<p>服务器主机关机</p>
<p>当 Unix 系统关机时，init 进程会给所有进程发送 SIGTERM 信号，并等待一段时间
(一般是 5 ~ 20 秒)，然后对仍在运行的进程发送 SIGKILL 信号。这么做是为了让进程得知将要关机，而捕获 SIGTERM 信号做相关的数据保存工作，相应的 SIGKILL 则是强制所有进程结束，进入关机状态。之后的情况与服务端主动断开类似。</p>
</li>
</ul>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 04-07</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/2022/unixnetworkprogramming_004/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span><span>|&nbsp;<a class="link-to-report" href=https://gitlab.com/GinShio/ginshio.gitlab.io/issues/new?issue[title]=[BUG]%20%E5%9F%BA%E6%9C%AC+TCP+%E7%BC%96%E7%A8%8B&issue[description]=[POST](https://blog.ginshio.org/2022/unixnetworkprogramming_004/)%0A%0A##%20Isseus%0A target="_blank" rel="noopener noreferrer">报告问题</a>
                    </span></div>
            <div class="post-info-share">
                <span><a href="#" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程" data-hashtags="Note,Unix,Network,Posix,TCP"><i class="fab fa-twitter fa-fw"></i></a><a href="#" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-hashtag="Note"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/"><i class="fab fa-linkedin fa-fw"></i></a><a href="#" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="#" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" title="分享到 Telegram" data-sharer="telegram" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程" data-web><i class="fab fa-telegram-plane fa-fw"></i></a><a href="#" class="weixin" title="分享到 微信" data-sharer="weixin" data-url="https://blog.ginshio.org/2022/unixnetworkprogramming_004/" data-title="基本 TCP 编程" data-web><i class="fab fa-weixin fa-fw"></i><img src="https://api.oick.cn/qrcode/api.php?size=256&amp;text=https://blog.ginshio.org/2022/unixnetworkprogramming_004/" title="基本 TCP 编程">
    </a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/unix/">Unix</a>,&nbsp;<a href="/tags/network/">Network</a>,&nbsp;<a href="/tags/posix/">Posix</a>,&nbsp;<a href="/tags/tcp/">TCP</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2022/unixnetworkprogramming_003/" class="prev" rel="prev" title="Unix 套接字 API"><i class="fas fa-angle-left fa-fw"></i>Unix 套接字 API</a>
            <a href="/2022/unixnetworkprogramming_005/" class="next" rel="next" title="I/O 复用">I/O 复用<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.134.2">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank" rel="noopener noreferrer">GinShio</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.b82a526943533d0dde3eceea68e6d3879e8f766339a17d2c57bbde5421167ddeafa4734202e9950c16842cc6d27753b4.css" integrity="sha384-uCpSaUNTPQ3ePs7qaObTh56PdmM5oX0sV7veVCEWfd6vpHNCAumVDBaELMbSd1O0"><link rel="stylesheet" href="/lib/katex/katex.min.bcaaee8fe6b5dd4f321c8900c8680ad49dc0ad32f3ac51816c1734b43a7869dfc4c9ec0449e5c4fc8bfaec08fc80a674.css" integrity="sha384-vKruj&#43;a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"96cbbb15f26bebd9141b","clientSecret":"29c7df99d6e1806113996333163a9476027ff1fa","id":"2022-02-19T15:31:05+08:00","owner":"GinShio","repo":"ginshio.github.io","title":"基本 TCP 编程"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"ABF13CGNA0","algoliaIndex":"ginshio_blog","algoliaSearchKey":"51cf3425aba132c091b477c3d5e06eea","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"sharerjs":true,"table":{"sort":true}};</script><script type="text/javascript" src="/lib/gitalk/gitalk.min.1420a0c0459673bc6824e7ba713f1e0ec1540e86491daf1b6149a7af9cd3f396c86b9182d03e4c727faefae17b746033.js" integrity="sha384-FCCgwEWWc7xoJOe6cT8eDsFUDoZJHa8bYUmnr5zT85bIa5GC0D5Mcn&#43;u&#43;uF7dGAz"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.d120034e53740430f5243f8e25b646e7bdcca97780e02962c37e3adefb264c1b457f8fc397698851f42e32d7168bdd1e.js" integrity="sha384-0SADTlN0BDD1JD&#43;OJbZG573MqXeA4Cliw3463vsmTBtFf4/Dl2mIUfQuMtcWi90e"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/katex/katex.min.3f04544ff62a6e71239193b4cd9c4da9cc400ab5defa3efae94d9a997720320e78e7baef7b663b23a6494a6d80d264b8.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe&#43;j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f95071777afa5e0511c9caad675d7b9d8c38e0e39c21ac79e99e1d09159bc723edd0aa1a875b87a0ad28e3efd1444d39.js" integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.c30ff9f376878715a4cf90c4567e8e2ad36221a2e2da20513595df251898d408bbb6727d517a44b32bce2135694e5e00.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.453374f1ad005c88a83c1715a2c12a3d47ca2beacfa7e875c7f8b347bc4c91d332bb091c64259dc4ef914b0205b495cd.js" integrity="sha384-RTN08a0AXIioPBcVosEqPUfKK&#43;rPp&#43;h1x/izR7xMkdMyuwkcZCWdxO&#43;RSwIFtJXN" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-J5NHMZLLDX', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-J5NHMZLLDX" async></script><script>
			var _hmt = _hmt || [];
			(function() {
			  var hm = document.createElement("script");
			  hm.src = "https://hm.baidu.com/hm.js?9370523af547bac6b97e9c3b1461cd16";
			  var s = document.getElementsByTagName("script")[0]; 
			  s.parentNode.insertBefore(hm, s);
			})();
		</script></div>
</body>

</html>