

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>词法分析软件 Flex 及语法分析软件 Bison 的用法 - iris</title><meta name="Description" content="GinShio | 词法分析软件 Flex 及语法分析软件 Bison 的用法"><meta property="og:title" content="词法分析软件 Flex 及语法分析软件 Bison 的用法" />
<meta property="og:description" content="GinShio | 词法分析软件 Flex 及语法分析软件 Bison 的用法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.ginshio.org/2022/flex_and_bison/" /><meta property="og:image" content="https://blog.ginshio.org/avatar.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T15:29:43+08:00" />
<meta property="article:modified_time" content="2022-05-22T14:27:38+08:00" /><meta property="og:site_name" content="iris | GinShio的个人博客" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.ginshio.org/avatar.webp"/>

<meta name="twitter:title" content="词法分析软件 Flex 及语法分析软件 Bison 的用法"/>
<meta name="twitter:description" content="GinShio | 词法分析软件 Flex 及语法分析软件 Bison 的用法"/>
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2022/flex_and_bison/" /><link rel="prev" href="https://blog.ginshio.org/2022/compilerprinciple_006/" /><link rel="next" href="https://blog.ginshio.org/2022/compilerprinciple_007/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/color.34e5eb0ed3195c558eb6994b94f6ce01b4d7121bda08365c4f94b70d178301efdb761cb63c963c02c67c45152c3c9498.css" integrity="sha384-NOXrDtMZXFWOtplLlPbOAbTXEhvaCDZcT5S3DReDAe/bdhy2PJY8AsZ8RRUsPJSY"><link rel="stylesheet" href="/css/style.min.71903c93e482438bcb694a21934b32795f3f9dc2c7076dadfa66ca836805f90335eae546d168ddaa1c5de8eda3532d79.css" integrity="sha384-cZA8k&#43;SCQ4vLaUohk0syeV8/ncLHB22t&#43;mbKg2gF&#43;QM16uVG0Wjdqhxd6O2jUy15"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <meta name="google-site-verification" content="fbzw9fQcZyEFrrrUtxLfzYW-qhZ5TMEZKHHSp9NeLBw" /><meta name="msvalidate.01" content="EC9CEC799D42793C414AE7BDB0D0205C" /><meta name="yandex-verification" content="c0b808dd3e49f730" /><meta name="baidu-site-verification" content="code-RhPhu2ccLc" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "词法分析软件 Flex 及语法分析软件 Bison 的用法",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2022\/flex_and_bison\/"
        },"image": ["https:\/\/blog.ginshio.org\/screenshot.png"],"genre": "posts","keywords": "Applications, SyntacticAnalysis, LexicalAnalysis","wordcount":  26082 ,
        "url": "https:\/\/blog.ginshio.org\/2022\/flex_and_bison\/","datePublished": "2022-05-01T15:29:43+08:00","dateModified": "2022-05-22T14:27:38+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/avatar.webp"},"authors": [{
                        "@type": "Person",
                        "name": "GinShio"                    
                    }],"description": "GinShio | 词法分析软件 Flex 及语法分析软件 Bison 的用法"
    }
    </script><script src="//instant.page/5.1.1" defer type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>
</head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme; }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="#" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#flex">Flex</a>
      <ul>
        <li><a href="#flex-输入文件的格式">Flex 输入文件的格式</a>
          <ul>
            <li><a href="#flex-s-definitions-格式">Flex&rsquo;s definitions 格式</a></li>
            <li><a href="#flex-s-rules-格式">Flex&rsquo;s rules 格式</a></li>
            <li><a href="#flex-s-code-格式">Flex&rsquo;s code 格式</a></li>
          </ul>
        </li>
        <li><a href="#flex-匹配">Flex 匹配</a>
          <ul>
            <li><a href="#flex-匹配规则">Flex 匹配规则</a></li>
            <li><a href="#flex-匹配动作">Flex 匹配动作</a></li>
            <li><a href="#eof-规则">EOF 规则</a></li>
          </ul>
        </li>
        <li><a href="#开始条件">开始条件</a></li>
        <li><a href="#多输入缓冲区">多输入缓冲区</a></li>
        <li><a href="#flex-的各种奇奇怪怪的定义">Flex 的各种奇奇怪怪的定义</a>
          <ul>
            <li><a href="#奇奇怪怪的宏定义">奇奇怪怪的宏定义</a></li>
            <li><a href="#奇奇怪怪的变量">奇奇怪怪的变量</a></li>
          </ul>
        </li>
        <li><a href="#扫描器操作">扫描器操作</a>
          <ul>
            <li><a href="#指定文件名操作">指定文件名操作</a></li>
            <li><a href="#影响扫描器行为的选项">影响扫描器行为的选项</a></li>
            <li><a href="#代码级和-api-操作">代码级和 API 操作</a></li>
            <li><a href="#生成扫描器速度和大小的选项">生成扫描器速度和大小的选项</a></li>
            <li><a href="#flex-debugging-选项">Flex Debugging 选项</a></li>
          </ul>
        </li>
        <li><a href="#flex-的性能考虑">Flex 的性能考虑</a></li>
        <li><a href="#可重入-c-扫描器">可重入 C 扫描器</a>
          <ul>
            <li><a href="#flex-可重入扫描器的用途">Flex 可重入扫描器的用途</a></li>
            <li><a href="#可重入-api-概述">可重入 API 概述</a></li>
            <li><a href="#一个-flex-可重入扫描器的示例">一个 Flex 可重入扫描器的示例</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#gnu-bison">GNU Bison</a>
      <ul>
        <li><a href="#bison-概念">Bison 概念</a>
          <ul>
            <li><a href="#从形式规则到-bison-语法">从形式规则到 Bison 语法</a></li>
            <li><a href="#语义值">语义值</a></li>
            <li><a href="#语义行为">语义行为</a></li>
            <li><a href="#编写-glr-解析器">编写 GLR 解析器</a></li>
          </ul>
        </li>
        <li><a href="#bison-语法文件">Bison 语法文件</a>
          <ul>
            <li><a href="#bison-语法--grammar">Bison 语法 (Grammar)</a></li>
            <li><a href="#定义语言语义">定义语言语义</a></li>
            <li><a href="#追踪位置">追踪位置</a></li>
            <li><a href="#名称引用">名称引用</a></li>
            <li><a href="#声明">声明</a></li>
          </ul>
        </li>
        <li><a href="#解析器-c-语言接口">解析器 C 语言接口</a>
          <ul>
            <li><a href="#解析器函数-yyparse">解析器函数 yyparse</a></li>
            <li><a href="#词法分析函数-yylex">词法分析函数 yylex</a></li>
            <li><a href="#错误处理函数-yyerror">错误处理函数 yyerror</a></li>
            <li><a href="#解析器-i18n">解析器 i18n</a></li>
          </ul>
        </li>
        <li><a href="#bison-解析器算法">Bison 解析器算法</a>
          <ul>
            <li><a href="#向前看符号">向前看符号</a></li>
            <li><a href="#移入归约冲突">移入归约冲突</a></li>
            <li><a href="#操作符优先级">操作符优先级</a></li>
            <li><a href="#归约归约冲突">归约归约冲突</a></li>
            <li><a href="#神秘冲突">神秘冲突</a></li>
            <li><a href="#调整-lr">调整 LR</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#main-函数示例">main 函数示例</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">词法分析软件 Flex 及语法分析软件 Bison 的用法</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/compilerprinciple/"><i class="far fa-folder fa-fw"></i>CompilerPrinciple</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="05-01">05-01</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="05-22">05-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 26082 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 53 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#flex">Flex</a>
      <ul>
        <li><a href="#flex-输入文件的格式">Flex 输入文件的格式</a>
          <ul>
            <li><a href="#flex-s-definitions-格式">Flex&rsquo;s definitions 格式</a></li>
            <li><a href="#flex-s-rules-格式">Flex&rsquo;s rules 格式</a></li>
            <li><a href="#flex-s-code-格式">Flex&rsquo;s code 格式</a></li>
          </ul>
        </li>
        <li><a href="#flex-匹配">Flex 匹配</a>
          <ul>
            <li><a href="#flex-匹配规则">Flex 匹配规则</a></li>
            <li><a href="#flex-匹配动作">Flex 匹配动作</a></li>
            <li><a href="#eof-规则">EOF 规则</a></li>
          </ul>
        </li>
        <li><a href="#开始条件">开始条件</a></li>
        <li><a href="#多输入缓冲区">多输入缓冲区</a></li>
        <li><a href="#flex-的各种奇奇怪怪的定义">Flex 的各种奇奇怪怪的定义</a>
          <ul>
            <li><a href="#奇奇怪怪的宏定义">奇奇怪怪的宏定义</a></li>
            <li><a href="#奇奇怪怪的变量">奇奇怪怪的变量</a></li>
          </ul>
        </li>
        <li><a href="#扫描器操作">扫描器操作</a>
          <ul>
            <li><a href="#指定文件名操作">指定文件名操作</a></li>
            <li><a href="#影响扫描器行为的选项">影响扫描器行为的选项</a></li>
            <li><a href="#代码级和-api-操作">代码级和 API 操作</a></li>
            <li><a href="#生成扫描器速度和大小的选项">生成扫描器速度和大小的选项</a></li>
            <li><a href="#flex-debugging-选项">Flex Debugging 选项</a></li>
          </ul>
        </li>
        <li><a href="#flex-的性能考虑">Flex 的性能考虑</a></li>
        <li><a href="#可重入-c-扫描器">可重入 C 扫描器</a>
          <ul>
            <li><a href="#flex-可重入扫描器的用途">Flex 可重入扫描器的用途</a></li>
            <li><a href="#可重入-api-概述">可重入 API 概述</a></li>
            <li><a href="#一个-flex-可重入扫描器的示例">一个 Flex 可重入扫描器的示例</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#gnu-bison">GNU Bison</a>
      <ul>
        <li><a href="#bison-概念">Bison 概念</a>
          <ul>
            <li><a href="#从形式规则到-bison-语法">从形式规则到 Bison 语法</a></li>
            <li><a href="#语义值">语义值</a></li>
            <li><a href="#语义行为">语义行为</a></li>
            <li><a href="#编写-glr-解析器">编写 GLR 解析器</a></li>
          </ul>
        </li>
        <li><a href="#bison-语法文件">Bison 语法文件</a>
          <ul>
            <li><a href="#bison-语法--grammar">Bison 语法 (Grammar)</a></li>
            <li><a href="#定义语言语义">定义语言语义</a></li>
            <li><a href="#追踪位置">追踪位置</a></li>
            <li><a href="#名称引用">名称引用</a></li>
            <li><a href="#声明">声明</a></li>
          </ul>
        </li>
        <li><a href="#解析器-c-语言接口">解析器 C 语言接口</a>
          <ul>
            <li><a href="#解析器函数-yyparse">解析器函数 yyparse</a></li>
            <li><a href="#词法分析函数-yylex">词法分析函数 yylex</a></li>
            <li><a href="#错误处理函数-yyerror">错误处理函数 yyerror</a></li>
            <li><a href="#解析器-i18n">解析器 i18n</a></li>
          </ul>
        </li>
        <li><a href="#bison-解析器算法">Bison 解析器算法</a>
          <ul>
            <li><a href="#向前看符号">向前看符号</a></li>
            <li><a href="#移入归约冲突">移入归约冲突</a></li>
            <li><a href="#操作符优先级">操作符优先级</a></li>
            <li><a href="#归约归约冲突">归约归约冲突</a></li>
            <li><a href="#神秘冲突">神秘冲突</a></li>
            <li><a href="#调整-lr">调整 LR</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#main-函数示例">main 函数示例</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>正正规规地开始写实现一个编译器感觉压力还是蛮大的。初步选型是</p>
<ul>
<li>基础工具
<ul>
<li>Git</li>
<li>CMake</li>
<li>gcc</li>
</ul>
</li>
<li>编译器生成工具
<ul>
<li>Flex</li>
<li>GNU Bison</li>
</ul>
</li>
<li>其他工具
<ul>
<li>Clang Format</li>
<li>CppLint</li>
<li>EditConfig</li>
</ul>
</li>
</ul>
<p><code>C++</code> 支持 17 简直太棒了！！！还不知道毕昇杯能不能用 CMake 去构建。</p>
<p>由于是多人合作项目，代码风格暂时定的是 Google，估计啥都不知道。想想到时候 review
代码就头大。</p>
<p>这篇主要是记录下从 <a href="https://en.wikipedia.org/wiki/Info_%28Unix%29" target="_blank" rel="noopener noreferrer">info</a> (Emacs 看 info 真方便) 中学习的 Flex 和 GNU Bison 相关用法。</p>
<p><strong>TL;DR.</strong>
<a href="#main-%e5%87%bd%e6%95%b0%e7%a4%ba%e4%be%8b" rel="">main 函数示例</a> 或 <a href="https://pku-minic.github.io/online-doc" target="_blank" rel="noopener noreferrer">北大编译实践</a></p>
<h2 id="flex" class="headerLink">
    <a href="#flex" class="header-mark"></a>Flex</h2><p>Flex 可以理解为词法分析器生成工具 Lex 的开源版本，意为 fast lexical analyzer
generator。根据描述的正则表达式与 C 代码 (这些被称为 <strong>规则</strong>)，来生成对应的分析器代码 (文件名默认为 <strong>lex.yy.c</strong>)，其中定义了接口 <code>yylex()</code> 用来启动分析器，函数原型如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Flex 默认会生成标准的 C99 代码，而非 <code>K&amp;R</code> 风格代码。在调用 yylex 时，它会持续从全局输入文件 yyin 中扫描 token，直到遇到 EOF 或 action 执行返回语句。如果 yylex
因 return 停止扫描，可以再次调用扫描器，从中断处继续扫描。当扫描到 EOF 时，只有
<code>yywrap()</code> 返回 0 才继续读取其他文件，返回非零时扫描器会终止并返回 0。如果你不实现 <code>yywrap()</code>,需要使用 <code>%option noyywrap</code> 或链接 <code>-lfl</code> 使用总返回 1 的默认版本。</p>
<p>话说回来，学习词法分析最大的收获应该是知道了正则是怎么运作的，自己哪天心血来潮了说不定就手撕一个。</p>
<h3 id="flex-输入文件的格式" class="headerLink">
    <a href="#flex-%e8%be%93%e5%85%a5%e6%96%87%e4%bb%b6%e7%9a%84%e6%a0%bc%e5%bc%8f" class="header-mark"></a>Flex 输入文件的格式</h3><p>输入文件被分为三个部分，两个部分之间使用 <code>%%</code> 分隔。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">definitions
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">rules
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">user code
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="flex-s-definitions-格式" class="headerLink">
    <a href="#flex-s-definitions-%e6%a0%bc%e5%bc%8f" class="header-mark"></a>Flex&rsquo;s definitions 格式</h4><p>定义部分会声明一些 <strong>name</strong> 方便后续使用，或者声明开始条件。</p>
<p>name 是以字母或下划线 (<code>_</code>) 开头，并在后面跟随零或多个字母、数字、下划线、短线
(<code>-</code>)。声明通常是一个正则表达式，可以看作是 name 的值。语法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">name definition
</span></span></code></pre></td></tr></table>
</div>
</div><p>有点难懂？那就看一个示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">DIGIT   [0-9]
</span></span><span class="line"><span class="cl">ID      [a-z][a-z0-9]*
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里定义了两个 name，当然我们可以在其他 name 中使用已声明的 name，比如声明 FLOAT</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">FLOAT   {DIGIT}+&#34;.&#34;{DIGIT}*
</span></span><span class="line"><span class="cl">FLOAT2  ([0-9])+&#34;.&#34;([0-9])*
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个例子中 <code>FLOAT</code> 与 <code>FLOAT2</code> 的声明是完全等价的。</p>
<p>注释与 C 的多行注释相同。lex 中可以直接写 C 代码，当然要用 <code>%{</code> 和 <code>%}</code> 包裹起来，这个块将在生成代码时被完全复制。另外 <strong>top</strong> 块是很重要的一个语法，它会被生成在文件的顶端，在所有的代码之前，因此你可以在 top 块中定义一些感兴趣的宏或文件。top 块示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%top{
</span></span><span class="line"><span class="cl">    /* This code goes at the &#34;top&#34; of the generated file. */
</span></span><span class="line"><span class="cl">    #include &lt;stdint.h&gt;
</span></span><span class="line"><span class="cl">    #include &lt;inttypes.h&gt;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="flex-s-rules-格式" class="headerLink">
    <a href="#flex-s-rules-%e6%a0%bc%e5%bc%8f" class="header-mark"></a>Flex&rsquo;s rules 格式</h4><p>规则部分每个规则一行，同样地你可以在 <code>%{</code> 和 <code>%}</code> 之间的块中写 C 语言代码，Flex
会帮你完全一致的复制到生成文件中。语法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">pattern   action
</span></span></code></pre></td></tr></table>
</div>
</div><p>pattern 相当于给定的正则表达式，当输入与 pattern 匹配时将执行 action 所对应的动作。详细说明一下支持的 pattern 用法</p>
<dl>
<dt>x</dt>
<dd>字符 x</dd>
<dt>.</dt>
<dd>除换行外的任意字符</dd>
<dt>[xyz]</dt>
<dd>一个字符集，可以匹配其中一个字符，示例可以匹配 x 或 y 或 z</dd>
<dt>[abj-oZ]</dt>
<dd>一个带范围的字符集，匹配其中一个字符。示例可以匹配 a 或 b 或 j 到 o
之间的字符或 Z</dd>
<dt>[^A-Z]</dt>
<dd>一个否定字符集，匹配其中没有出现的字符。示例可以匹配除了大写字母外的任意字符</dd>
<dt>[a-z]{-}[aeiou]</dt>
<dd>一个带除外集的字符集，匹配除了后面集合外的所有出现在集合中的字符。示例可以匹配小写辅音字母</dd>
<dt>r*</dt>
<dd>匹配零或多个 r</dd>
<dt>r+</dt>
<dd>匹配一或多个 r</dd>
<dt>r?</dt>
<dd>匹配零或一个 r</dd>
<dt>r{2,5}</dt>
<dd>匹配二到五个 r</dd>
<dt>r{2,}</dt>
<dd>匹配二或更多 r</dd>
<dt>r{4}</dt>
<dd>正好四个 r</dd>
<dt>{name}</dt>
<dd>匹配第一节中定义的 name</dd>
<dt>[xyz]\[foo</dt>
<dd>转义字符</dd>
<dt>\123</dt>
<dd>字符的八进制表示。示例为大写字母 S</dd>
<dt>\x53</dt>
<dd>字符的十六进制表示。示例为大写字母 S</dd>
<dt>(r)</dt>
<dd>利用 <code>()</code> 优先级修改匹配优先级</dd>
<dt>(?r-s:pattern)</dt>
<dd>对 pattern 应用 r 模式但不应用 s 模式。其中可选模式如下
<ul>
<li><strong>i</strong>: 不区分大小写</li>
<li><strong>s</strong>: 修改 <code>.</code> 语义，匹配任意字符 (包括换行)</li>
<li><strong>x</strong>: 忽略 pattern 中的注释与空白符。空白符依旧可以出现在 <code>&quot;&quot;</code> 中、转义字符、或字符集中。</li>
<li>示例
<table>
<thead>
<tr>
<th>示例</th>
<th>等价表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>\((?:foo)\)</td>
<td>\((foo)\)</td>
</tr>
<tr>
<td>\((?i:ab7)\)</td>
<td>\(([aA][bB]7)\)</td>
</tr>
<tr>
<td>\((?-i:ab)\)</td>
<td>\((ab)\)</td>
</tr>
<tr>
<td>\((?s:.)\)</td>
<td>\(([\backslash{}x00-\backslash{}xFF])\)</td>
</tr>
<tr>
<td>\((?ix-s:\ a\ .\ b)\)</td>
<td>\(([Aa][\^\backslash{}n][bB])\)</td>
</tr>
<tr>
<td>\((?x:a\ b)\)</td>
<td>\((&ldquo;ab&rdquo;)\)</td>
</tr>
<tr>
<td>\((?x:a\backslash\ b)\)</td>
<td>\((&ldquo;a\ b&rdquo;)\)</td>
</tr>
<tr>
<td>\((?x:a&quot;\ &ldquo;b)\)</td>
<td>\((&ldquo;a\ b&rdquo;)\)</td>
</tr>
<tr>
<td>\((?x:a[\ ]b)\)</td>
<td>\((&ldquo;a\ b&rdquo;)\)</td>
</tr>
<tr>
<td>\(\begin{aligned}(?x: &amp; a\\ &amp; /* comment */\\ &amp; b\\ &amp; c)\end{aligned}\)</td>
<td>\((abc)\)</td>
</tr>
</tbody>
</table>
</li>
</ul>
</dd>
<dt>(?# comment)</dt>
<dd>忽略 <code>()</code> 中的所有内容，且可以跨多行，但是注释不能有 <code>)</code> 字符</dd>
<dt>rs</dt>
<dd>cat</dd>
<dt>r|s</dt>
<dd>or</dd>
<dt>r/s</dt>
<dd>尾随上下文 (trailing context)，只有在 s 之前的情况下匹配 r，但只进行 r
的行为</dd>
<dt>^r</dt>
<dd>仅在行首匹配 r</dd>
<dt>r$</dt>
<dd>仅在行尾匹配 r</dd>
<dt>&lt;s&gt;r</dt>
<dd>仅以 s 开始的 r</dd>
<dt>&lt;s1,s2,s3&gt;r</dt>
<dd>仅以 s1 或 s2 或 s3 开始的 r</dd>
<dt>&lt;*&gt;r</dt>
<dd>以任意条件开始的 r</dd>
<dt>&lt;&lt;EOF&gt;&gt;</dt>
<dd>文件末尾</dd>
<dt>&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;</dt>
<dd>以条件 s1 或 s2 开始的文件末尾</dd>
</dl>
<p>在字符串中，除了转义符 (<code>\</code>)、字符集运算符 (<code>-</code> 和 <code>]]</code>) 以及行首标记 (<code>^</code>)，其他特殊字符均失去了其特殊意义。</p>
<p>另外上面的 pattern 是根据优先级排列的，最上面的优先级最高。比如表达式
\(foo|bar*\) 与表达式 \((foo)|(ba(r*))\) 相同。如果想要改为重复 foo 或 bar 数次，可以写为表达式 \((foo|bar)*\)。</p>
<p>Flex 支持 POSIX Bracket Expressions，但是没找到相应的 Shorthand 支持。不过从
info 上看，支持了，但没全支持。</p>
<table>
<thead>
<tr>
<th>POSIX</th>
<th>Description</th>
<th>ASCII</th>
<th>Shorthand</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[:alnum:]</code></td>
<td>字母和数字</td>
<td>\([a-zA-Z0-9]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:alpha:]</code></td>
<td>字母</td>
<td>\([a-zA-Z]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:ascii:]</code></td>
<td>ASCII 字符</td>
<td>\([\backslash{}x00-\backslash{}xFF]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:blank:]</code></td>
<td>空格及 Tab</td>
<td>\([ \backslash{}t]\)</td>
<td><code>\h</code></td>
</tr>
<tr>
<td><code>[:cntrl:]</code></td>
<td>控制字符</td>
<td>\([\backslash{}x00-\backslash{}x1F\backslash{}x7F]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:digit:]</code></td>
<td>数字</td>
<td>\([0-9]\)</td>
<td><code>\d</code></td>
</tr>
<tr>
<td><code>[:graph:]</code></td>
<td>可见字符</td>
<td>\([\backslash{}x21-\backslash{}x7E]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:lower:]</code></td>
<td>小写字符</td>
<td>\([a-z]\)</td>
<td><code>\l</code></td>
</tr>
<tr>
<td><code>[:print:]</code></td>
<td>可见字符及空格</td>
<td>\([\backslash{}x20-\backslash{}x7E]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:punct:]</code></td>
<td>标点字符</td>
<td>\([!&quot;\backslash\#\$\%\&amp;&rsquo;()*+,\backslash-./:;&lt;=&gt;?@\backslash[\backslash\backslash\backslash]\verb!^!\_\verb!`!\{\mid\}\verb!~!]\)</td>
<td></td>
</tr>
<tr>
<td><code>[:space:]</code></td>
<td>空白字符</td>
<td>\([\ \backslash{}t\backslash{}r\backslash{}n\backslash{}v\backslash{}f]\)</td>
<td><code>\s</code></td>
</tr>
<tr>
<td><code>[:upper:]</code></td>
<td>大写字符</td>
<td>\([A-Z]\)</td>
<td><code>\u</code></td>
</tr>
<tr>
<td><code>[:word:]</code></td>
<td>单词字符</td>
<td>\([a-zA-Z0-9\_]\)</td>
<td><code>\w</code></td>
</tr>
<tr>
<td><code>[:xdigit:]</code></td>
<td>十六进制字符</td>
<td>\([a-fA-F0-9]\)</td>
<td></td>
</tr>
</tbody>
</table>
<p>其中 Flex 不支持 <code>[:ascii:]</code> 和 <code>[:word:]</code> 两个字符集。</p>
<p>在 Flex 配置文件中，字符集将被立即展开，这意味着 flex 环境对字符集感兴趣。</p>
<ul>
<li>
<p>如果添加了大小写不敏感标记，那么 <code>[:upper:]</code> 和 <code>[:lower:]</code> 与 <code>[:alpha:]</code> 等价</p>
</li>
<li>
<p>有范围的字符类在跨越大小写字符时 (比如 <code>[a-Z]</code>)，在不区分大小写的扫描器上应该慎用。此时 Flex 并不知道你是想将所有的大小写字符折叠在一起，还是要指定 ASCII
数值范围。在出现此类问题时，Flex 优先指定数值范围，并发出一个警告。</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>结果</th>
<th>数值范围</th>
<th>二义性范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[a-t]</code></td>
<td>ok</td>
<td>\([a-tA-T]\)</td>
<td></td>
</tr>
<tr>
<td><code>[A-T]</code></td>
<td>ok</td>
<td>\([a-tA-T]\)</td>
<td></td>
</tr>
<tr>
<td><code>[A-t]</code></td>
<td>二义性</td>
<td>\([A-Z\backslash[\backslash\backslash\backslash]\verb!_!\verb!`!a-t]\)</td>
<td>\([a-tA-T]\)</td>
</tr>
<tr>
<td><code>[_-{]</code></td>
<td>二义性</td>
<td>\(\verb!_!\verb!`!a-z\{\)</td>
<td>\(\verb!_!\verb!`!a-zA-Z\{\)</td>
</tr>
<tr>
<td><code>[@-C]</code></td>
<td>二义性</td>
<td>\(@ABC\)</td>
<td>\(@A-Z\backslash[\backslash\backslash\backslash]\verb!_!\verb!`!abc\)</td>
</tr>
</tbody>
</table>
</li>
</ul>
<!--listend-->
<ul>
<li>
<p>Flex 允许否定 POSIX 字符集，只需要在字符类名称前加上 <code>^</code>，但是大小写不敏感的扫描器上 <code>[:^upper:]</code> 和 <code>[:^lower:]</code> 会被跳过，它们的含义不清。</p>
</li>
<li>
<p>操作符 <code>{-}</code> 可以为两个字符集做差，但小心生成一个永远不会被匹配的空集。不过做差的两个集合不必是包含关系，比如 <code>[a-c]{-}[b-z]</code> 的结果为 <code>[a]</code>。</p>
</li>
<li>
<p>操作符 <code>{+}</code> 求两个字符集的并集。比如 <code>[[:alpha:]]{-}[[:lower:]]{+}[q]</code> 的结果为 <code>[A-Zq]</code>。</p>
</li>
<li>
<p>一个 pattern 最多有一个尾随上下文 (<code>/</code> 或 <code>$</code>)，开始条件、<code>^</code> 和 <code>&lt;&lt;EOF&gt;&gt;</code> 只能出现在 pattern 的开头。这些内容均不能出现在 <code>()</code> 的优先级分组中。另外 <code>^</code> 与
<code>$</code> 没有出现在相应位置的情况下，将被视为普通字符。</p>
</li>
</ul>
<h4 id="flex-s-code-格式" class="headerLink">
    <a href="#flex-s-code-%e6%a0%bc%e5%bc%8f" class="header-mark"></a>Flex&rsquo;s code 格式</h4><p>最后一部分即代码段，用来写 C 语言代码，并完全复制到生成文件的末尾部分。主要是用来定义一些辅助函数，或单独使用 Flex 时的入口函数。</p>
<h3 id="flex-匹配" class="headerLink">
    <a href="#flex-%e5%8c%b9%e9%85%8d" class="header-mark"></a>Flex 匹配</h3><h4 id="flex-匹配规则" class="headerLink">
    <a href="#flex-%e5%8c%b9%e9%85%8d%e8%a7%84%e5%88%99" class="header-mark"></a>Flex 匹配规则</h4><p>Flex 的匹配原则是最长匹配，且按优先级匹配。即多个同时匹配的规则，采用匹配到文本最长的规则；多个同时匹配且长度相同的规则，采用第一个列出的规则 (最上面的优先级最高)。长度包含尾随上下文的尾随部分。</p>
<p>当匹配成功时，匹配的文本将可以使用全局指针 <strong>yytext</strong> 获取，长度可以通过全局整型
<strong>yyleng</strong> 获取。之后开始执行匹配模式相应的 action，然后再扫描剩余的输入。但是没有匹配时，将执行默认规则：输入的下一个字符将被当作匹配并复制到标准输出。</p>
<p>需要注意，<strong>yytext</strong> 可以用两种不同的方式定义：字符指针或字符数组。在定义部分，你可以用 <code>%pointer</code> 或 <code>%array</code> 来指定用何种方式，当然默认使用指针的方式，如果有
lex 兼容选项默认使用数组。使用指针带来的劣势是：修改 yytext 将会受限，且调用
<code>unput()</code> 会破坏其中的内容，也可能出现 lex 的移植性问题。</p>
<p>遗憾的是，生成 C++ 扫描器类是不能使用 <code>%pointer</code> 方式的。</p>
<h4 id="flex-匹配动作" class="headerLink">
    <a href="#flex-%e5%8c%b9%e9%85%8d%e5%8a%a8%e4%bd%9c" class="header-mark"></a>Flex 匹配动作</h4><p>每一个匹配都有一个想对应的动作，在匹配成功时将执行这个动作。pattern 在第一个非转义空白处结尾，这行剩下的则是 action 部分，action 由任意的 C 代码片段组成。</p>
<p>比如下面这个程序，压缩空白符到一个空格，并丢弃所有行末空白符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">[ \t]+     putchar(&#39; &#39;);
</span></span><span class="line"><span class="cl">[ \t]+$    /* ignore this token */
</span></span></code></pre></td></tr></table>
</div>
</div><p>action 可以用 <code>{</code> 和 <code>}</code> 包括起来，在里面写多行 C 语言代码，类似于 C 的代码块。Flex 会甄别字符串和注释中括号，更好的方式是用 <code>%{</code> 和 <code>%}</code> 来定义代码块。</p>
<p>如果 action 是一个 \(\mid\)，意思是同下一个规则的 action 相同。</p>
<p>之前说了可以包含 <strong>return</strong> 语句，它将返回值给名为 <strong>yylex</strong> 的函数，这个函数每次在上次停止的地方继续向下处理，直到到达文件末尾或执行返回。</p>
<p>action 可以自由修改 yytext，除了延长它 (末尾添加字符将覆盖之后的字符，在使用
array 方式时不能修改)。action 还可以自由修改 yyleng，除非 action 还包括使用
<code>yymore()</code>。</p>
<p>还为 action 定义了一些预设指令</p>
<dl>
<dt>ECHO</dt>
<dd>复制 yytext 到扫描器输出</dd>
<dt>BEGIN</dt>
<dd>将扫描器重定位在开始条件末尾</dd>
<dt>REJECT</dt>
<dd>拒绝当前的最优匹配，采用次优匹配。如果你的 action 由其他动作，需要放在 REJECT 之前，否则不会执行。以下代码，在匹配 &lsquo;abcd&rsquo; 时会输出 &lsquo;abcdabcaba&rsquo;
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">a      |
</span></span><span class="line"><span class="cl">ab     |
</span></span><span class="line"><span class="cl">abc    |
</span></span><span class="line"><span class="cl">abcd   ECHO; REJECT;
</span></span><span class="line"><span class="cl">.|\n   /* */
</span></span></code></pre></td></tr></table>
</div>
</div></dd>
<dt>yymore()</dt>
<dd>告诉扫描器下次匹配到规则时，将当前的 token 放在 yytext 的首部。比如以下代码，在匹配 &lsquo;mega-kludge&rsquo; 时会输出 &lsquo;mega-mega-kludge&rsquo;
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">mega-    ECHO; yymore();
</span></span><span class="line"><span class="cl">kludge   ECHO;
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 yymore 的时候需要注意两点</p>
<ul>
<li>yymore 依赖于 yyleng，因此不要在使用时修改 yyleng</li>
<li>yymore 会导致扫描器的匹配速度略微下降</li>
</ul>
</dd>
<dt>yyless(n)</dt>
<dd>当前 token 将使用开始的 n 个字符，扫描会从匹配的 n 个字符之后继续扫描。在使用 yyless 之后，yytext 与 yyleng 将会被调整 (yyleng 将等于 n)。比如以下代码，匹配 &lsquo;foobar&rsquo; 时会输出 &lsquo;foobarbar&rsquo;
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">foobar   ECHO; yyless(3);
</span></span><span class="line"><span class="cl">[a-z]+   ECHO;
</span></span></code></pre></td></tr></table>
</div>
</div><p>要十分注意 yyless() 的使用，如果参数为 0 时，扫描器将陷入无限循环中。</p>
</dd>
<dt>unput(c)</dt>
<dd>将字符 c 重新放入输入中，它会是下一个带扫描的字符。如果使用
<code>%pointer</code> 情况下会导致 yytext 被破坏，从最右端开始每次吞一个字符。如果需要调用 unput()，需要使用 <code>%array</code> 构建或者先将 yytext 复制到其他地方
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">/* Copy yytext because unput() trashes yytext */
</span></span><span class="line"><span class="cl">char* yycopy = strdup(yytext);
</span></span><span class="line"><span class="cl">unput(&#39;)&#39;);
</span></span><span class="line"><span class="cl">for (int i = yyleng - 1; i &gt;= 0; --i) {
</span></span><span class="line"><span class="cl">    unput(yycopy[i]);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">unput(&#39;(&#39;);
</span></span><span class="line"><span class="cl">free(yycopy);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div></dd>
<dt>input()</dt>
<dd>从输入流中读取下一个字符。比如 C 风格注释，将全部注释丢弃。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&#34;/*&#34;        {
</span></span><span class="line"><span class="cl">            int c;
</span></span><span class="line"><span class="cl">            while (1) {
</span></span><span class="line"><span class="cl">                while ((c = input()) != &#39;*&#39; &amp;&amp; c != EOF) {
</span></span><span class="line"><span class="cl">                    continue;
</span></span><span class="line"><span class="cl">                }  /* eat up text of comment */
</span></span><span class="line"><span class="cl">                if (c == &#39;*&#39;) {
</span></span><span class="line"><span class="cl">                    while ((c = input()) == &#39;*&#39;) {
</span></span><span class="line"><span class="cl">                        continue;
</span></span><span class="line"><span class="cl">                    }
</span></span><span class="line"><span class="cl">                    if (c == &#39;/&#39;) {
</span></span><span class="line"><span class="cl">                        break;
</span></span><span class="line"><span class="cl">                    }  /* found the end */
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">                if (c == EOF) {
</span></span><span class="line"><span class="cl">                    error( &#34;EOF in comment&#34; );
</span></span><span class="line"><span class="cl">                    break;
</span></span><span class="line"><span class="cl">                }
</span></span><span class="line"><span class="cl">            }  /* end of while */
</span></span><span class="line"><span class="cl">            }
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意一点，如果用 C++ 编译，则需要使用 <code>yyinput()</code> 防止 input 和 C++ 的
stream 冲突。</p>
</dd>
<dt>YY_FLUSH_BUFFER</dt>
<dd>清空内部缓冲区，在下次匹配是先使用 <code>YY_INPUT()</code> 重填缓冲区。这个方法会在之后解释。</dd>
<dt>yyterminate()</dt>
<dd>替代 action 中的返回语句并返回 0 表示<strong>全部完成</strong>。通常在遇到
EOF 时使用该函数。</dd>
</dl>
<h4 id="eof-规则" class="headerLink">
    <a href="#eof-%e8%a7%84%e5%88%99" class="header-mark"></a>EOF 规则</h4><p><code>&lt;&lt;EOF&gt;&gt;</code> 是个特殊规则，表示遇到文件末尾且 yywrap 返回非零值时 (表示没有其他文件要处理) 要执行的操作，好像并不是每个文件的 EOF 规则。该 action 通常执行以下操作之一：</p>
<ul>
<li>将 <code>yyin</code> 分配给新的输入文件；</li>
<li>执行返回语句；</li>
<li>或，使用 <code>yy_switch_to_buffer</code> 切换到新的缓冲区 (见 <a href="#%e5%a4%9a%e8%be%93%e5%85%a5%e7%bc%93%e5%86%b2%e5%8c%ba" rel="">多输入缓冲区</a>)</li>
</ul>
<p>EOF 只能与开始条件一起使用，不合格的 EOF 将适用于所有没有 EOF 的开始动作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%x quote
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...other rules for dealing with quotes...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
</span></span><span class="line"><span class="cl">         error( &#34;unterminated quote&#34; );
</span></span><span class="line"><span class="cl">         yyterminate();
</span></span><span class="line"><span class="cl">         }
</span></span><span class="line"><span class="cl">&lt;&lt;EOF&gt;&gt;  {
</span></span><span class="line"><span class="cl">         if ( *++filelist )
</span></span><span class="line"><span class="cl">             yyin = fopen( *filelist, &#34;r&#34; );
</span></span><span class="line"><span class="cl">         else
</span></span><span class="line"><span class="cl">            yyterminate();
</span></span><span class="line"><span class="cl">         }
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="开始条件" class="headerLink">
    <a href="#%e5%bc%80%e5%a7%8b%e6%9d%a1%e4%bb%b6" class="header-mark"></a>开始条件</h3><p>开始条件 (sc) 相当于一种激活机制，用 <code>BEGIN</code> 触发 sc，在下次 BEGIN 前，给定 sc
都是激活状态，而其他 sc 都是屏蔽状态。</p>
<p>在<code>定义</code>部分声明，有 <code>%s</code> (兼容性) 或 <code>%x</code> (排他性) 两种 sc，后跟随名称列表。兼容性 sc 激活时不会屏蔽非 sc 规则，但排他性 sc 激活时不但屏蔽其他 sc 规则，还屏蔽非 sc 规则。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%s example
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">&lt;example&gt;foo  do_something();
</span></span><span class="line"><span class="cl">bar           something_else();
</span></span></code></pre></td></tr></table>
</div>
</div><p>等价于</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%x example
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">&lt;example&gt;foo            do_something();
</span></span><span class="line"><span class="cl">&lt;INITIAL,example&gt; bar   something_else();
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于下面这个代码，如果没有 <code>&lt;INITIAL,example&gt;</code> 那么 bar 会被屏蔽；而如果只使用
<code>&lt;example&gt;</code> sc，只有在 example sc 被激活时才能匹配 bar。</p>
<p>另外有一个特殊的sc <code>&lt;*&gt;</code> 可以在任何 sc 激活时被匹配。使用 <code>BEGIN(0)</code> 或
<code>BEGIN(INITIAL)</code> 可以回到初始状态，即非 sc 状态。如果你希望</p>
<p>BEGIN 动作也可以在 rules 开头作为 action 给出，直接进入指定的 sc 激活状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">         int enter_special;
</span></span><span class="line"><span class="cl">%x SPECIAL
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">         if ( enter_special )
</span></span><span class="line"><span class="cl">             BEGIN(SPECIAL);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;SPECIAL&gt;blahblahblah
</span></span><span class="line"><span class="cl">......
</span></span></code></pre></td></tr></table>
</div>
</div><p>给出一个示例，这个示例将检测整数和浮点数，但是浮点数可能以整数开头被认为是一个整数，因此，这个例子采用 sc 来扫描整数或浮点数。一行一个数字，如果是浮点数将以
<code>expect-floats</code> 开头。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#include &lt;math.h&gt;
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">%s expect
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">expect-floats        BEGIN(expect);
</span></span><span class="line"><span class="cl">&lt;expect&gt;[0-9]+.[0-9]+      {
</span></span><span class="line"><span class="cl">            printf( &#34;found a float, = %f\n&#34;,
</span></span><span class="line"><span class="cl">                    atof( yytext ) );
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">&lt;expect&gt;\n           {
</span></span><span class="line"><span class="cl">            /* that&#39;s the end of the line, so
</span></span><span class="line"><span class="cl">             * we need another &#34;expect-number&#34;
</span></span><span class="line"><span class="cl">             * before we&#39;ll recognize any more
</span></span><span class="line"><span class="cl">             * numbers
</span></span><span class="line"><span class="cl">             */
</span></span><span class="line"><span class="cl">            BEGIN(INITIAL);
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">[0-9]+      {
</span></span><span class="line"><span class="cl">            printf( &#34;found an integer, = %d\n&#34;,
</span></span><span class="line"><span class="cl">                    atoi( yytext ) );
</span></span><span class="line"><span class="cl">            }
</span></span><span class="line"><span class="cl">&#34;.&#34;         printf( &#34;found a dot\n&#34; );
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然用 sc 来扫描注释是更加简便的一种方式，相比之前介绍的 <code>input()</code> 方式，这很简单。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%x comment
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">        int line_num = 1;
</span></span><span class="line"><span class="cl">&#34;/*&#34;         BEGIN(comment);
</span></span><span class="line"><span class="cl">&lt;comment&gt;[^*\n]*        /* eat anything that&#39;s not a &#39;*&#39; */
</span></span><span class="line"><span class="cl">&lt;comment&gt;&#34;*&#34;+[^*/\n]*   /* eat up &#39;*&#39;s not followed by &#39;/&#39;s */
</span></span><span class="line"><span class="cl">&lt;comment&gt;\n             ++line_num;
</span></span><span class="line"><span class="cl">&lt;comment&gt;&#34;*&#34;+&#34;/&#34;        BEGIN(INITIAL);
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你希望得到一个高性能的扫描器，那就需要每个规则尽可能多的匹配文本。</p>
<p>另外，sc 的存储方式实际是 int，因此你可以采用如此方式记录上一个状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%x comment foo
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">        int line_num = 1;
</span></span><span class="line"><span class="cl">        int comment_caller;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;/*&#34;         {
</span></span><span class="line"><span class="cl">             comment_caller = INITIAL;
</span></span><span class="line"><span class="cl">             BEGIN(comment);
</span></span><span class="line"><span class="cl">             }
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">&lt;foo&gt;&#34;/*&#34;    {
</span></span><span class="line"><span class="cl">             comment_caller = foo;
</span></span><span class="line"><span class="cl">             BEGIN(comment);
</span></span><span class="line"><span class="cl">             }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;comment&gt;[^*\n]*        /* eat anything that&#39;s not a &#39;*&#39; */
</span></span><span class="line"><span class="cl">&lt;comment&gt;&#34;*&#34;+[^*/\n]*   /* eat up &#39;*&#39;s not followed by &#39;/&#39;s */
</span></span><span class="line"><span class="cl">&lt;comment&gt;\n             ++line_num;
</span></span><span class="line"><span class="cl">&lt;comment&gt;&#34;*&#34;+&#34;/&#34;        BEGIN(comment_caller);
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个更好的方式是，<code>YY_START</code> 可以记录当前的 sc 状态，因此写成 <code>comment_caller = YY_START;</code> 是更好的方式。如果你想兼容 lex 则可以用它的别名 <code>YYSTATE</code>。</p>
<p>最后，看一份 C 风格的字符串示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%x str
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">        char string_buf[MAX_STR_CONST];
</span></span><span class="line"><span class="cl">        char *string_buf_ptr;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">\&#34;      string_buf_ptr = string_buf; BEGIN(str);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;str&gt;\&#34;        { /* saw closing quote - all done */
</span></span><span class="line"><span class="cl">        BEGIN(INITIAL);
</span></span><span class="line"><span class="cl">        *string_buf_ptr = &#39;\0&#39;;
</span></span><span class="line"><span class="cl">        /* return string constant token type and
</span></span><span class="line"><span class="cl">         * value to parser
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">&lt;str&gt;\n        {
</span></span><span class="line"><span class="cl">        /* error - unterminated string constant */
</span></span><span class="line"><span class="cl">        /* generate error message */
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">&lt;str&gt;\\[0-7]{1,3} {
</span></span><span class="line"><span class="cl">        /* octal escape sequence */
</span></span><span class="line"><span class="cl">        int result;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        (void) sscanf( yytext + 1, &#34;%o&#34;, &amp;result );
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        if ( result &gt; 0xff )
</span></span><span class="line"><span class="cl">                /* error, constant is out-of-bounds */
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        *string_buf_ptr++ = result;
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">&lt;str&gt;\\[0-9]+ {
</span></span><span class="line"><span class="cl">        /* generate error - bad escape sequence; something
</span></span><span class="line"><span class="cl">         * like &#39;\48&#39; or &#39;\0777777&#39;
</span></span><span class="line"><span class="cl">         */
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">&lt;str&gt;\\n  *string_buf_ptr++ = &#39;\n&#39;;
</span></span><span class="line"><span class="cl">&lt;str&gt;\\t  *string_buf_ptr++ = &#39;\t&#39;;
</span></span><span class="line"><span class="cl">&lt;str&gt;\\r  *string_buf_ptr++ = &#39;\r&#39;;
</span></span><span class="line"><span class="cl">&lt;str&gt;\\b  *string_buf_ptr++ = &#39;\b&#39;;
</span></span><span class="line"><span class="cl">&lt;str&gt;\\f  *string_buf_ptr++ = &#39;\f&#39;;
</span></span><span class="line"><span class="cl">&lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];
</span></span><span class="line"><span class="cl">&lt;str&gt;[^\\\n\&#34;]+        {
</span></span><span class="line"><span class="cl">        char *yptr = yytext;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        while ( *yptr )
</span></span><span class="line"><span class="cl">                *string_buf_ptr++ = *yptr++;
</span></span><span class="line"><span class="cl">        }
</span></span></code></pre></td></tr></table>
</div>
</div><p>像上面的代码，在一个 sc 下可能有很多规则，你可以使用 Flex 提供的 scope 语法来将太们写在一起</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">&lt;str&gt;{
</span></span><span class="line"><span class="cl">    &#34;\\n&#34;  *string_buf_ptr++ = &#39;\n&#39;;
</span></span><span class="line"><span class="cl">    &#34;\\t&#34;  *string_buf_ptr++ = &#39;\t&#39;;
</span></span><span class="line"><span class="cl">    &#34;\\r&#34;  *string_buf_ptr++ = &#39;\r&#39;;
</span></span><span class="line"><span class="cl">    &#34;\\b&#34;  *string_buf_ptr++ = &#39;\b&#39;;
</span></span><span class="line"><span class="cl">    &#34;\\f&#34;  *string_buf_ptr++ = &#39;\f&#39;;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>当启用 <code>%option stack</code> 之后，你也可以使用内建的 sc 栈，可能你需要用到以下函数</p>
<ul>
<li>将状态压入栈 (即切换到状态)
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yy_push_state</span><span class="p">(</span><span class="kt">int</span> <span class="n">new_state</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>将状态弹出栈 (即回到上一个状态)
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yy_pop_state</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>获取栈顶元素 (即获取当前状态的值)
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yy_top_state</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>sc 栈是动态增长的，也没有内建大小限制，但是内存用尽时程序将退出。</p>
<h3 id="多输入缓冲区" class="headerLink">
    <a href="#%e5%a4%9a%e8%be%93%e5%85%a5%e7%bc%93%e5%86%b2%e5%8c%ba" class="header-mark"></a>多输入缓冲区</h3><p>一些扫描器 (如 C/C++ 支持的 include) 需要从多个输入流中读取，因此无用简单地通过到达文件末尾才读取下一个输入的 <code>YY_INPUT</code> 来控制，因为可能从使用 include 到文件末尾需要很长时间。</p>
<p>针对这一问题，Flex 给出了多个缓冲区之间的创建和切换机制。连带的是更多的 flex 函数。</p>
<ul>
<li>
<p>创建缓冲区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">YY_BUFFER_STATE</span> <span class="nf">yy_create_buffer</span><span class="p">(</span><span class="n">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>  <span class="c1">// c style
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">YY_BUFFER_STATE</span> <span class="nf">yy_new_buffer</span><span class="p">(</span><span class="n">FILE</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>     <span class="c1">// c++ style (use new and delete)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>YY_BUFFER_STATE</code> 是不透明结构 <code>struct yy_buffer_state</code> 的指针。如果重定义了没有使用 yyin 的 YY_INPUT，需要可以安全地将 NULL 传给 file。</p>
</li>
<li>
<p>切换缓冲区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yy_switch_to_buffer</span><span class="p">(</span><span class="n">YY_BUFFER_STATE</span> <span class="n">new_buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将扫描器输入切换到新的缓冲区上，但并不会改变 sc。</p>
</li>
<li>
<p>删除缓冲区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yy_delete_buffer</span><span class="p">(</span><span class="n">YY_BUFFER_STATE</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>压入状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yypush_buffer_state</span><span class="p">(</span><span class="n">YY_BUFFER_STATE</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将新的状态推送到 flex 维护的内部堆栈，推送的状态成为新的当前状态。</p>
</li>
<li>
<p>弹出状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yypop_buffer_state</span><span class="p">(</span><span class="n">YY_BUFFER_STATE</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将当前状态弹出栈，并删除缓冲区，并将堆栈的下一个状态 (如果有) 设置为新的当前状态。</p>
</li>
<li>
<p>丢弃缓冲区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yy_flush_buffer</span><span class="p">(</span><span class="n">YY_BUFFER_STATE</span> <span class="n">buffer</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>丢弃当前缓冲区的所有内容，扫描器的下次匹配将先调用 <code>YY_INPUT()</code> 重新填充缓冲区。</p>
</li>
</ul>
<p>最后还有一些宏，比如 <code>YY_CURRENT_BUFFER</code> 将返回当前缓冲区的 <code>YY_BUFFER_STATE</code> 句柄，但是请不要将它作为左值。</p>
<p>看下示例吧！<strong>Talk is cheap. Show me the code.</strong></p>
<p>首先示例是一个关于 <code>include</code> 功能的实现，使用 <code>yypush_buffer_state</code> 和
<code>yypop_buffer_state</code> 实现 (利用 Flex 自身维护堆栈)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/* the &#34;incl&#34; state is used for picking up the name
</span></span><span class="line"><span class="cl"> * of an include file
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">%x incl
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">include             BEGIN(incl);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[a-z]+              ECHO;
</span></span><span class="line"><span class="cl">[^a-z\n]*\n?        ECHO;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;incl&gt;[ \t]*      /* eat the whitespace */
</span></span><span class="line"><span class="cl">&lt;incl&gt;[^ \t\n]+   { /* got the include file name */
</span></span><span class="line"><span class="cl">        yyin = fopen(yytext, &#34;r&#34;);
</span></span><span class="line"><span class="cl">        if (!yyin) error(...);
</span></span><span class="line"><span class="cl">        yypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE));
</span></span><span class="line"><span class="cl">        BEGIN(INITIAL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;&lt;EOF&gt;&gt; {
</span></span><span class="line"><span class="cl">        yypop_buffer_state();
</span></span><span class="line"><span class="cl">        if (!YY_CURRENT_BUFFER) yyterminate();
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然也可以自己管理输入文件的堆栈，就比如下面这个等价的例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/* the &#34;incl&#34; state is used for picking up the name
</span></span><span class="line"><span class="cl"> * of an include file
</span></span><span class="line"><span class="cl"> */
</span></span><span class="line"><span class="cl">%x incl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#define MAX_INCLUDE_DEPTH 10
</span></span><span class="line"><span class="cl">YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
</span></span><span class="line"><span class="cl">int include_stack_ptr = 0;
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">include             BEGIN(incl);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[a-z]+              ECHO;
</span></span><span class="line"><span class="cl">[^a-z\n]*\n?        ECHO;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;incl&gt;[ \t]*      /* eat the whitespace */
</span></span><span class="line"><span class="cl">&lt;incl&gt;[^ \t\n]+   { /* got the include file name */
</span></span><span class="line"><span class="cl">        if (include_stack_ptr &gt;= MAX_INCLUDE_DEPTH) {
</span></span><span class="line"><span class="cl">            fprintf(stderr, &#34;Includes nested too deeply&#34;);
</span></span><span class="line"><span class="cl">            exit(1);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">        include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;
</span></span><span class="line"><span class="cl">        yyin = fopen( yytext, &#34;r&#34; );
</span></span><span class="line"><span class="cl">        if (!yyin) error(...);
</span></span><span class="line"><span class="cl">        yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
</span></span><span class="line"><span class="cl">        BEGIN(INITIAL);
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;&lt;EOF&gt;&gt; {
</span></span><span class="line"><span class="cl">        if (--include_stack_ptr == 0) {
</span></span><span class="line"><span class="cl">            yyterminate();
</span></span><span class="line"><span class="cl">        } else {
</span></span><span class="line"><span class="cl">            yy_delete_buffer(YY_CURRENT_BUFFER);
</span></span><span class="line"><span class="cl">            yy_switch_to_buffer(include_stack[include_stack_ptr]);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以在一个内存缓冲区上而非文件上进行缓冲区操作。当然只是在创建阶段有区别，其他阶段没有任何区别。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">YY_BUFFER_STATE</span> <span class="nf">yy_scan_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>  <span class="c1">// c style string
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">YY_BUFFER_STATE</span> <span class="nf">yy_scan_bytes</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>  <span class="c1">// string with end of non-NULL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">YY_BUFFER_STATE</span> <span class="nf">yy_scan_buffer</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">yy_size_t</span> <span class="n">size</span><span class="p">);</span>  <span class="c1">// no copy buffer
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>前两者会复制一份数据，这在希望修改缓冲区内容时是安全的，但你想避免复制时需要使用第三个函数。需要注意，它并不是末尾 non-NULL 字符串，它的最后两个字节必须是
<code>YY_END_OF_BUFFER_CHAR</code>。因此真正扫描的数据在 0 到 size-2。</p>
<h3 id="flex-的各种奇奇怪怪的定义" class="headerLink">
    <a href="#flex-%e7%9a%84%e5%90%84%e7%a7%8d%e5%a5%87%e5%a5%87%e6%80%aa%e6%80%aa%e7%9a%84%e5%ae%9a%e4%b9%89" class="header-mark"></a>Flex 的各种奇奇怪怪的定义</h3><h4 id="奇奇怪怪的宏定义" class="headerLink">
    <a href="#%e5%a5%87%e5%a5%87%e6%80%aa%e6%80%aa%e7%9a%84%e5%ae%8f%e5%ae%9a%e4%b9%89" class="header-mark"></a>奇奇怪怪的宏定义</h4><dl>
<dt>YY_USER_ACTION</dt>
<dd>提供了一种始终在匹配 action 之前执行的操作。当使用该宏时，变量 <code>yy_act</code> 用于指示当前动作的编号 (下标从 1 开始)，而 <code>YY_NUM_RULES</code> 指出了规则的总数。因此你可以这样统计每个规则被执行了多少次
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ctr</span><span class="p">[</span><span class="n">YY_NUM_RULES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define YY_USER_ACTION ++ctr[yy_act]
</span></span></span></code></pre></td></tr></table>
</div>
</div></dd>
<dt>YY_USER_INIT</dt>
<dd>提供了在第一次扫描之前或者内部初始化之前，执行的操作。比如说打开日志文件。</dd>
<dt>yy_set_interactive(is_interactive)</dt>
<dd>控制当前缓冲区是否是<strong>交互的</strong>。交互式的缓冲区性能差，但输入源是交互式的可以避免由于等待填充缓冲区导致的问题。也可以使用操作 <code>%option always-interactive</code> 或 <code>%option never-interactive</code> 指定是否为交互式缓冲区，但该宏会覆盖这两个操作。其值零表示为非交互的。</dd>
<dt>yy_set_bol(at_bol)</dt>
<dd>控制当前缓冲区是否开启行头的扫描上下文。零值表示为 <code>^</code> 规则无效。宏 <code>YY_AT_BOL</code> 可以给出当前的情况。</dd>
</dl>
<h4 id="奇奇怪怪的变量" class="headerLink">
    <a href="#%e5%a5%87%e5%a5%87%e6%80%aa%e6%80%aa%e7%9a%84%e5%8f%98%e9%87%8f" class="header-mark"></a>奇奇怪怪的变量</h4><dl>
<dt>char *yytext</dt>
<dd>当前 token 的文本。你可以修改它但不能增长它。另外 <code>%array</code> 模式不能在生成 C++ 版本扫描器时使用</dd>
<dt>int yyleng</dt>
<dd>当前 token 的文本长度。</dd>
<dt>FILE *yyin</dt>
<dd>当前读取文件的指针。如果想修改需要在扫描开始之前或遇到 EOF 之后，否则 UB，这种情况请使用 <code>yyrestart()</code>。</dd>
<dt>void yyrestart(FILE *new_file);</dt>
<dd>要求 yyin 指向新的输入文件。</dd>
<dt>FILE *yyout</dt>
<dd>当前输出的文件。</dd>
<dt>YY_CURRENT_BUFFER</dt>
<dd>当前缓冲区的 YY_BUFFER_STATE 句柄。</dd>
<dt>YY_START</dt>
<dd>当前 sc 的值，通常用于 <code>BEGIN</code> action。</dd>
</dl>
<h3 id="扫描器操作" class="headerLink">
    <a href="#%e6%89%ab%e6%8f%8f%e5%99%a8%e6%93%8d%e4%bd%9c" class="header-mark"></a>扫描器操作</h3><p>有很多 scanner option，但通常只需要指定一些就够了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%option   8bit reentrant bison-bridge
</span></span><span class="line"><span class="cl">%option   warn nodefault
</span></span><span class="line"><span class="cl">%option   yylineno
</span></span><span class="line"><span class="cl">%option   outfile=&#34;scanner.c&#34; header-file=&#34;scanner.h&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>flex 你可以在第一部分中写入 <code>%option</code>，大部分选项都以名称的形式给出，你可以在前面加上 no 来表示否形式。这些名称与相应的命令行选项相同。</p>
<p>如果你有些强迫症，需要将没用的过程全部关闭，不让 flex 生成相关过程。下列函数是默认生成的：</p>
<div class="verse">
<p>input, unput<br />
yy_push_state, yy_pop_state, yy_top_state<br />
yy_scan_buffer, yy_scan_bytes, yy_scan_string<br />
<br />
yyget_extra, yyset_extra, yyget_leng, yyget_text,<br />
yyget_lineno, yyset_lineno, yyget_in, yyset_in,<br />
yyget_out, yyset_out, yyget_lval, yyset_lval,<br />
yyget_lloc, yyset_lloc, yyget_debug, yyset_debug<br /></p>
</div>
<h4 id="指定文件名操作" class="headerLink">
    <a href="#%e6%8c%87%e5%ae%9a%e6%96%87%e4%bb%b6%e5%90%8d%e6%93%8d%e4%bd%9c" class="header-mark"></a>指定文件名操作</h4><ul>
<li>指定导出的头文件名称
<ul>
<li>long name: header-file</li>
<li>option name: header-file</li>
<li>param: FILE</li>
<li>comment: 与 <code>--c++</code> 选项不兼容</li>
</ul>
</li>
<li>指定导出的源文件名称
<ul>
<li>short name: o</li>
<li>long name: outfile</li>
<li>option name: outfile</li>
<li>param: FILE</li>
</ul>
</li>
<li>将生成的扫描器写入 stdout 而不是 lex.yy.c
<ul>
<li>short name: t</li>
<li>long name: stdout</li>
<li>option name: stdout</li>
</ul>
</li>
<li>修改构造扫描器模板
<ul>
<li>short name: S</li>
<li>long name: skel</li>
<li>param: FILE</li>
<li>comment: 除非你是 flex 的开发人员，否则不要使用此选项</li>
</ul>
</li>
<li>将序列化的扫描器 DFA 表写入文件
<ul>
<li>long name: tables-file</li>
<li>param: FILE</li>
<li>comment: 生成的扫描器将不会包含该表，并在运行时加载</li>
</ul>
</li>
<li>检查序列化表的一致性
<ul>
<li>long name: tables-verify</li>
<li>comment: 开发选项。序列化 DFA 表，并在运行时与代码内表进行匹配验证，而不是加载序列化表</li>
</ul>
</li>
</ul>
<h4 id="影响扫描器行为的选项" class="headerLink">
    <a href="#%e5%bd%b1%e5%93%8d%e6%89%ab%e6%8f%8f%e5%99%a8%e8%a1%8c%e4%b8%ba%e7%9a%84%e9%80%89%e9%a1%b9" class="header-mark"></a>影响扫描器行为的选项</h4><ul>
<li>不区分大小写
<ul>
<li>short name: i</li>
<li>long name: case-insensitive</li>
<li>option name: case-insensitive</li>
<li>comment: 虽然匹配将忽略大小写，但 yytext 获得的数据还是保留了大小写</li>
</ul>
</li>
<li>AT&amp;T lex 兼容
<ul>
<li>short name: l</li>
<li>long name: lex-compat</li>
<li>option name: lex-compat</li>
<li>comment: <strong>最大成度</strong>兼容 AT&amp;T lex，但不保证完全兼容。会拖慢扫描器性能，还会导致大量选项不可用。</li>
</ul>
</li>
<li>交互式扫描器
<ul>
<li>short name: I</li>
<li>long name: interactive</li>
<li>option name: interactive</li>
<li>comment: 以性能换取足够的交互性，默认采用这种模式，除非你使用了 <code>-Cf</code> 或
<code>-CF</code> 提高性能的选项。</li>
</ul>
</li>
<li>7 bit 扫描器
<ul>
<li>short name: 7</li>
<li>long name: 7bit</li>
<li>option name: 7bit</li>
<li>comment: 只能识别输入中的 7 bit 字符的扫描器。优点是器生成的表格的大小仅有
8bit 的一半，需要同时指定 <code>-Cf</code> 或 <code>-CF</code> 的表压缩选项才会有显著提升。但输入包含 8bit 字符将挂起或崩溃。</li>
</ul>
</li>
<li>8 bit 扫描器
<ul>
<li>short name: 8</li>
<li>long name: 8bit</li>
<li>option name: 8bit</li>
</ul>
</li>
<li>生成默认规则
<ul>
<li>long name: default</li>
<li>option name: default</li>
</ul>
</li>
<li>始终交互式扫描器
<ul>
<li>long name: always-interactive</li>
<li>option name: always-interactive</li>
<li>comment: 通常新的输入文件上，扫描器都会调用 <code>isatty()</code> 来确定扫描器的源是否是交互式的，因此一次读入一个字符。该选项会认为始终是交互式源，不会有相关调用。</li>
</ul>
</li>
<li>绝不交互式扫描器
<ul>
<li>long name: never-interactive</li>
<li>option name: never-interactive</li>
</ul>
</li>
<li>POSIX lex 兼容
<ul>
<li>short name: x</li>
<li>long name: posix</li>
<li>option name: posix</li>
<li>comment: <strong>最大成度</strong>兼容 POSIX 1003.2-1992 定义的 lex，由于最初实现是为 POSIX
定义所设计的，因此只有很少的行为不一致。已知的是 cat 与重复 <code>{}</code> 之间的优先级问题，大多数 POSIX 程序使用的扩展正则表达式 (ERE) 优先级与 flex 默认优先级一致，都是 cat 低于重复 (即 <code>ab{3}</code> 将产生 <code>abbb</code>)，而 POSIX 定义下是高于的
(即 <code>ab{3}</code> 将产生 <code>ababab</code>)。</li>
</ul>
</li>
<li>启用 sc 栈
<ul>
<li>long name: stack</li>
<li>option name: stack</li>
</ul>
</li>
<li>初始化输入输出为标准 IO
<ul>
<li>long name: stdinit</li>
<li>option name: stdinit</li>
</ul>
</li>
<li>读取行号
<ul>
<li>long name: yylineno</li>
<li>option name: yylineno</li>
</ul>
</li>
<li>文件结束判断
<ul>
<li>long name: yywrap</li>
<li>option name: yywrap</li>
</ul>
</li>
</ul>
<h4 id="代码级和-api-操作" class="headerLink">
    <a href="#%e4%bb%a3%e7%a0%81%e7%ba%a7%e5%92%8c-api-%e6%93%8d%e4%bd%9c" class="header-mark"></a>代码级和 API 操作</h4><ul>
<li>GNU Bison 支持
<ul>
<li>long name: bison-bridge</li>
<li>option name: bison-bridge</li>
<li>comment: 指示扫描器将被 GNU Bison 调用，增加了对 Bison 兼容性，以及对一些
API 的修改</li>
</ul>
</li>
<li>GNU Bison locations 支持
<ul>
<li>long name: bison-locations</li>
<li>option name: bison-locations</li>
<li>comment: 指示扫描器正在使用 GNU Bison <code>%locations</code>，yylex 将而额外增加一个
yylloc 参数。这个选项意味着启用了上一个选项。</li>
</ul>
</li>
<li>不生成 <code>#line</code> 指令
<ul>
<li>short name: L</li>
<li>long name: noline</li>
<li>option name: noline</li>
<li>comment: 不加这个选项时，Flex 生成的 action 错误消息将相对原始，有助于错误定位</li>
</ul>
</li>
<li>生成可重入的 C 扫描器
<ul>
<li>short name: R</li>
<li>long name: reentrant</li>
<li>option name: reentrant</li>
<li>comment: 生成可重入的扫描器，该扫描器可能是线程安全的。但是 API 可能与非可重入扫描器有所区别。因此可能需要修改代码，另外 <code>--c++</code> 选项与该选项不兼容。</li>
</ul>
</li>
<li>生成 C++ 扫描器
<ul>
<li>short name: +</li>
<li>long name: c++</li>
<li>option name: c++</li>
</ul>
</li>
<li>yytext 使用数组实现
<ul>
<li>long name: array</li>
<li>option name: array</li>
</ul>
</li>
<li>yytext 使用指针实现
<ul>
<li>long name: pointer</li>
<li>option name: pointer</li>
</ul>
</li>
<li>修改默认的前缀名称
<ul>
<li>
<p>short name: P</p>
</li>
<li>
<p>long name: prefix</p>
</li>
<li>
<p>option name: prefix</p>
</li>
<li>
<p>param: PREFIX</p>
</li>
<li>
<p>comment: 将全局可见变量和函数名称默认的 yy 前缀修改为指定前缀，比如
<code>prefix=foo</code> 将 yytext 变为了 footext，另外默认生成的源文件也会从 lex.yy.c
改为 lex.foo.c。以下是所有受影响的名称</p>
<ul>
<li>yy_create_buffer</li>
<li>yy_delete_buffer</li>
<li>yy_flex_debug</li>
<li>yy_init_buffer</li>
<li>yy_flush_buffer</li>
<li>yy_load_buffer_state</li>
<li>yy_switch_to_buffer</li>
<li>yyin</li>
<li>yyleng</li>
<li>yylex</li>
<li>yylineno</li>
<li>yyout</li>
<li>yyrestart</li>
<li>yytext</li>
<li>yywrap</li>
<li>yyalloc</li>
<li>yyrealloc</li>
<li>yyfree</li>
</ul>
<p>但是，如果是 C++ 扫描器只会影响到 <code>yywrap</code> 和 <code>yyFlexLexer</code>。另外你需要自己实现对应名称的 yywrap。</p>
</li>
</ul>
</li>
<li>生成一个默认的 main
<ul>
<li>long name: main</li>
<li>optino name: main</li>
<li>comment: 为扫描器生成一个默认的、简单调用 yylex 的 main 函数，此选项会开启
noyywrap 选项。</li>
</ul>
</li>
<li>禁止使用 unistd.h
<ul>
<li>long name: nounistd</li>
<li>optino name: nounistd</li>
<li>comment: 针对不存在 POSIX 的环境，flex 将不包含头文件 <code>unistd.h</code>。但某些选项可能依赖于该头文件。</li>
</ul>
</li>
<li>C++ 类名称
<ul>
<li>long name: nounistd</li>
<li>optino name: nounistd</li>
<li>param: NAME</li>
<li>comment: 告诉 Flex 你将使用 NAME 作为 yyFlexLexer 派生的子类名称。代码将生成在子类中的 yylex() 中，如果你调用 <code>yyFlexLexer::yylex()</code> 将会发生运行时错误。</li>
</ul>
</li>
</ul>
<h4 id="生成扫描器速度和大小的选项" class="headerLink">
    <a href="#%e7%94%9f%e6%88%90%e6%89%ab%e6%8f%8f%e5%99%a8%e9%80%9f%e5%ba%a6%e5%92%8c%e5%a4%a7%e5%b0%8f%e7%9a%84%e9%80%89%e9%a1%b9" class="header-mark"></a>生成扫描器速度和大小的选项</h4><p>压缩表的程度在以下选项中，通常被认为是在小型表和高性能扫描器之间的选择</p>
<ul>
<li>不适用等价类或元等价类的压缩表
<ul>
<li>short name: C</li>
</ul>
</li>
<li>以表的大小空间换取性能
<ul>
<li>short name: Ca</li>
<li>long name: align</li>
<li>option name: align</li>
<li>comment: 利用表的元素更好地内存对齐与计算，但可能将表格大小增加四倍。某些
RISC 架构上获取和操作长字比使用较小尺寸的短字更有效。</li>
</ul>
</li>
<li>为扫描表构造等价类
<ul>
<li>short name: Ce</li>
<li>long name: ecs</li>
<li>option name: ecs</li>
<li>comment: 等价类会显著减小最终表 / 目标文件的大小 (通常是 2 ~ 5 倍)，并且不会付出太多额外性能。</li>
</ul>
</li>
<li>构造完整的扫描表
<ul>
<li>short name: Cf</li>
<li>comment: 不通过利用不同状态的类似转换函数来压缩表</li>
</ul>
</li>
<li>构造快速扫描表
<ul>
<li>short name: CF</li>
<li>comment: 不应与 <code>--c++</code> 一起使用</li>
</ul>
</li>
<li>构造元等价表
<ul>
<li>short name: Cm</li>
<li>long name: meta-ecs</li>
<li>option name: meta-ecs</li>
<li>comment: 通常元等价表更为小巧，且对性能影响适中。但没有压缩的表无法启用该选项，因此不能与 <code>-Cf</code> 或 <code>-CF</code> 一起使用。</li>
</ul>
</li>
<li>绕开标准 IO 库的输入
<ul>
<li>short name: Cr</li>
<li>long name: read</li>
<li>option name: read</li>
<li>comment: Flex 直接使用 syscall <code>read()</code> 进行输入，而非标准 IO 库的 <code>fread()</code>
或 <code>getc()</code>。除非你还使用 <code>-Cf</code> 或 <code>-CF</code>，否则其性能提升可以忽略不计。</li>
</ul>
</li>
</ul>
<p>表格的压缩选项可以组合起来，比如默认的表格选项是 <code>-Cem</code>，Flex 默认开启了等价类和元等价类选项，这是最慢的一种情况，但是表格最小的情况。可以理解的是，Flex 支持以生成表格的大小来换取扫描器的性能，从表格最小到扫描器性能最高的选项依次是 <code>-Cem</code>、<code>-Cm</code>、<code>-Ce</code>、<code>-C</code>、<code>-C{f,F}e</code>、<code>-C{f,F}e</code>、<code>-C{f,F}a</code>。往往越小的表格生成和编译也就越快，而 <code>-Cfe</code> 选项通常是在压缩大小与性能之间比较好的权衡。</p>
<ul>
<li>构造完整扫描表
<ul>
<li>short name: f</li>
<li>long name: full</li>
<li>option name: full</li>
<li>comment: 等价于 <code>-Cfr</code></li>
</ul>
</li>
<li>构造快速扫描器
<ul>
<li>short name: F</li>
<li>long name: fast</li>
<li>option name: fast</li>
<li>comment: 等价于 <code>-CFr</code></li>
</ul>
</li>
</ul>
<h4 id="flex-debugging-选项" class="headerLink">
    <a href="#flex-debugging-%e9%80%89%e9%a1%b9" class="header-mark"></a>Flex Debugging 选项</h4><ul>
<li>备份信息到 lex.backup
<ul>
<li>short name: b</li>
<li>long name: backup</li>
<li>option name: backup</li>
<li>comment: 备份扫描器的状态列表和需要备份输入字符。如果消除所有的备份状态并使用 <code>-Cf</code> 或 <code>-CF</code>，生成的扫描器将运行得更快。</li>
</ul>
</li>
<li>debug 模式
<ul>
<li>short name: d</li>
<li>long name: debug</li>
<li>option name: debug</li>
<li>comment: 当匹配到规则并全局变量 <code>yy_flex_debug</code> 不为零时，将给 stderr 中写入如下形式
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">-accepting rule at line 53 (&#34;the matched text&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>性能报告
<ul>
<li>short name: p</li>
<li>long name: perf-report</li>
<li>option name: perf-report</li>
<li>comment: 获得导致扫描器性能严重下降的功能注释，如果包含两次该选项，还会报告轻微性能损失。使用 <code>REJECT</code>、可变尾随上下文会导致严重的性能损失，而
<code>yymore()</code>、<code>^</code> 运算符和 <code>--interactive</code> 会导致轻微性能下降。</li>
</ul>
</li>
<li>抑制默认规则
<ul>
<li>short name: s</li>
<li>long name: nodefault</li>
<li>option name: nodefault</li>
<li>comment: 将不匹配的输入回显到 stdout。</li>
</ul>
</li>
<li>追踪模式
<ul>
<li>short name: T</li>
<li>long name: trace</li>
<li>option name: trace</li>
<li>comment: 在 stderr 中生成更多关于 NFA 与 DFA 的消息，通常用于维护 Flex。</li>
</ul>
</li>
<li>不生成警告消息
<ul>
<li>short name: w</li>
<li>long name: nowarn</li>
<li>option name: nowarn</li>
</ul>
</li>
<li>详细消息
<ul>
<li>short name: v</li>
<li>long name: verbose</li>
<li>option name: verbose</li>
<li>comment: 在 stderr 中生成更多有关生成扫描器的统计信息。但是大多数信息对于临时使用 Flex 的用户没什么用。</li>
</ul>
</li>
<li>警告信息
<ul>
<li>long name: warn</li>
<li>option name: warn</li>
<li>comment: 如果可以匹配默认规则但没有给出默认规则，则 flex 会发出警告。建议始终使用此选项。</li>
</ul>
</li>
</ul>
<h3 id="flex-的性能考虑" class="headerLink">
    <a href="#flex-%e7%9a%84%e6%80%a7%e8%83%bd%e8%80%83%e8%99%91" class="header-mark"></a>Flex 的性能考虑</h3><p>Flex 的首要目标是构造高性能扫描器，因此已经针对大量规则进行了优化。但是除了表格与性能的取舍外，还有很多操作会降低性能，这里列出从严重影响性能到轻微影响性能的操作：</p>
<ul>
<li><code>REJECT</code></li>
<li>可变的尾随上下文</li>
<li>需要备份的模式集</li>
<li><code>%option yylineno</code></li>
<li><code>%array</code></li>
<li><code>%option interactive</code></li>
<li><code>%option always-interactive</code></li>
<li><code>^</code> 运算符</li>
<li><code>yymore()</code></li>
</ul>
<p>另外需要注意，unput 的实现可能会有大量的调用，而 yyless 很轻量，因此只是放回扫描的多余文本，请使用后者。</p>
<h3 id="可重入-c-扫描器" class="headerLink">
    <a href="#%e5%8f%af%e9%87%8d%e5%85%a5-c-%e6%89%ab%e6%8f%8f%e5%99%a8" class="header-mark"></a>可重入 C 扫描器</h3><p>flex 具有生成可移植的可重入 C 扫描器的能力。简单地说，即可以不需要与其他线程同步的情况下，创建多线程并行的扫描器。另外根据 info 的描述，所有的 C++ 扫描器都是可重入的。</p>
<h4 id="flex-可重入扫描器的用途" class="headerLink">
    <a href="#flex-%e5%8f%af%e9%87%8d%e5%85%a5%e6%89%ab%e6%8f%8f%e5%99%a8%e7%9a%84%e7%94%a8%e9%80%94" class="header-mark"></a>Flex 可重入扫描器的用途</h4><p>你可以同时扫描两个或多个文件来对比 token 级别的差异，而非字符串级别的差异，比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Example of maintaining more than one active scanner. */</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tok1</span> <span class="o">=</span> <span class="nf">yylex</span><span class="p">(</span><span class="n">scanner_1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">tok2</span> <span class="o">=</span> <span class="nf">yylex</span><span class="p">(</span><span class="n">scanner_2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tok1</span> <span class="o">!=</span> <span class="n">tok2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Files are different.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">tok1</span> <span class="o">&amp;&amp;</span> <span class="n">tok2</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一个用途是创建递归扫描器，虽然也可以通过不可重入扫描器和缓冲区状态实现。下面是一个 eval 的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/* Example of recursive invocation. */
</span></span><span class="line"><span class="cl">%option reentrant
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">&#34;eval(&#34;.+&#34;)&#34;  {
</span></span><span class="line"><span class="cl">                  yyscan_t scanner;
</span></span><span class="line"><span class="cl">                  YY_BUFFER_STATE buf;
</span></span><span class="line"><span class="cl">                  yylex_init( &amp;scanner );
</span></span><span class="line"><span class="cl">                  yytext[yyleng-1] = &#39; &#39;;
</span></span><span class="line"><span class="cl">                  buf = yy_scan_string( yytext + 5, scanner );
</span></span><span class="line"><span class="cl">                  yylex( scanner );
</span></span><span class="line"><span class="cl">                  yy_delete_buffer(buf,scanner);
</span></span><span class="line"><span class="cl">                  yylex_destroy( scanner );
</span></span><span class="line"><span class="cl">             }
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">%%
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="可重入-api-概述" class="headerLink">
    <a href="#%e5%8f%af%e9%87%8d%e5%85%a5-api-%e6%a6%82%e8%bf%b0" class="header-mark"></a>可重入 API 概述</h4><p>可重入扫描器与不可重入扫描器有一定区别。</p>
<ul>
<li>所有的函数需要加上参数 <code>yyscanner</code></li>
<li>所有的全局变量被它们的相应的等价宏替代，比如 yytext 被替换为
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define yytext (((struct yyguts_t*)yyscanner)-&gt;yytext_r)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li><code>yylex_init</code> 和 <code>yylex_destroy</code> 必须分别在 yylex 之前和之后调用
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex_init</span><span class="p">(</span><span class="kt">yyscan_t</span> <span class="o">*</span><span class="n">ptr_yy_globals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex_init_extra</span><span class="p">(</span><span class="n">YY_EXTRA_TYPE</span> <span class="n">user_defined</span><span class="p">,</span> <span class="kt">yyscan_t</span> <span class="o">*</span><span class="n">ptr_yy_globals</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex</span><span class="p">(</span><span class="kt">yyscan_t</span> <span class="n">yyscanner</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex_destroy</span><span class="p">(</span><span class="kt">yyscan_t</span> <span class="n">yyscanner</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>使用访问器方法 (get/set) 对常见的 flex 变量进行访问，格式为 <code>yyget_NAME</code> 或
<code>yyset_NAME</code>，另外还有额外的参数 yyscanner
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Set the last character of yytext to NULL. */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">chop</span><span class="p">(</span><span class="kt">yyscan_t</span> <span class="n">scanner</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">yyget_leng</span><span class="p">(</span><span class="n">scanner</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">yyget_text</span><span class="p">(</span><span class="n">scanner</span><span class="p">)[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>用户特定的数据可以存储在 <code>yyextra</code> 中。可重入场景下，不能直接访问全局变量，因此用户的全局状态可以存储于 yyextra 中。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define YY_EXTRA_TYPE  void*
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">YY_EXTRA_TYPE</span>  <span class="nf">yyget_extra</span><span class="p">(</span><span class="kt">yyscan_t</span> <span class="n">scanner</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span>           <span class="nf">yyset_extra</span><span class="p">(</span><span class="n">YY_EXTRA_TYPE</span> <span class="n">arbitrary_data</span><span class="p">,</span> <span class="kt">yyscan_t</span> <span class="n">scanner</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="一个-flex-可重入扫描器的示例" class="headerLink">
    <a href="#%e4%b8%80%e4%b8%aa-flex-%e5%8f%af%e9%87%8d%e5%85%a5%e6%89%ab%e6%8f%8f%e5%99%a8%e7%9a%84%e7%a4%ba%e4%be%8b" class="header-mark"></a>一个 Flex 可重入扫描器的示例</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">/* This scanner prints &#34;//&#34; comments. */
</span></span><span class="line"><span class="cl">%option reentrant stack noyywrap
</span></span><span class="line"><span class="cl">%x COMMENT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;//&#34;                 yy_push_state(COMMENT, yyscanner);
</span></span><span class="line"><span class="cl">.|\n
</span></span><span class="line"><span class="cl">&lt;COMMENT&gt;\n          yy_pop_state(yyscanner);
</span></span><span class="line"><span class="cl">&lt;COMMENT&gt;[^\n]+      fprintf(yyout, &#34;%s\n&#34;, yytext);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">int main(int argc, char *argv[]) {
</span></span><span class="line"><span class="cl">    yyscan_t scanner;
</span></span><span class="line"><span class="cl">    yylex_init(&amp;scanner);
</span></span><span class="line"><span class="cl">    yylex(scanner);
</span></span><span class="line"><span class="cl">    yylex_destroy(scanner);
</span></span><span class="line"><span class="cl">    return 0;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="gnu-bison" class="headerLink">
    <a href="#gnu-bison" class="header-mark"></a>GNU Bison</h2><p>GNU Bison 与 Flex 一样，都是遵循 GPL 协议发布的软件，不同的是，它是 GNU 项目！</p>
<p>GNU Bison 是一个通用的语法分析生成器，它可以将上下文无关文法生成使用 LALR(1) 分析表的确定性 LR 或通用 LR (GLR) 解析器。另外还可以生成实验性的 IELR(1) 或规范
LR(1) 分析表。</p>
<p>Bison 兼容 Yacc 项目，因此无需任何修改 Yacc 语法就能在 Bison 上运行。你可以使用
C 或 C++ 进行编写程序，但 Bison 现在实现性的增添了 Java 支持。</p>
<h3 id="bison-概念" class="headerLink">
    <a href="#bison-%e6%a6%82%e5%bf%b5" class="header-mark"></a>Bison 概念</h3><h4 id="从形式规则到-bison-语法" class="headerLink">
    <a href="#%e4%bb%8e%e5%bd%a2%e5%bc%8f%e8%a7%84%e5%88%99%e5%88%b0-bison-%e8%af%ad%e6%b3%95" class="header-mark"></a>从形式规则到 Bison 语法</h4><p>形式语言是数学表达，因此 Bison 需要定义自己的语法来生成相关的分析器。</p>
<p>非终结符，即表达式左边的标识符，在 Bison 中用小写表示，比如 epxr, stmt 等。终结符或 token 在 BISON 中用大写表示，如 INTEGRE, RETURN 等。需要额外注意的是
<code>error</code> 作为保留标识用于错误处理。还有一种标记终结符的方法是使用 C 字符串常量的形式。示例 C 语言 return 语句的 Bison 语法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">stmt: RETURN expr &#39;;&#39; ;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="语义值" class="headerLink">
    <a href="#%e8%af%ad%e4%b9%89%e5%80%bc" class="header-mark"></a>语义值</h4><p>如果一条规则表示的终结符是整数常量，那么<code>任意</code>整数常量都是有效的。也就是说，解析输入与具体的值是无关的：可以解析 <code>x+4</code> 的语法，也可以解析 <code>x+1</code> 或 <code>x+5452</code>。</p>
<p>但是对于被解析之后，精确值是十分重要的。无法区分精确值的编译器不是好的编译器！因此对每个 token，Bison 都会有一个 token 类型和一个语义值。</p>
<p>一般来说 token 类型是一个语法的终结符，比如说 INTEGER、IDENTIFIER 或 <code>','</code> 等。它可以提供决定 token 是否出现得正确和怎样组织其他 token 的所需的一切，比如整数字面量的值，或标识符的名称。而语法规则除了 token 类型外什么都不必知道。</p>
<p>每个分组还可以具有语义值以及非终结符。比如计算器程序，表达式通常是数字语义值，而编译器中语义值描述的是树结构。</p>
<h4 id="语义行为" class="headerLink">
    <a href="#%e8%af%ad%e4%b9%89%e8%a1%8c%e4%b8%ba" class="header-mark"></a>语义行为</h4><p>同样地不止需要解析输入，还要对输入有一些对应的行为，Bison 对文法规则的行为
(action) 也是 C 代码段，每次解析器发现匹配的规则时都会执行相应的行为。</p>
<p>更多时候 action 的目的是根据部分语义值计算真个构造的语义值。比如说有一个规则是加法规则</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr: expr &#39;+&#39; expr   { $$ = $1 + $3; };
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个 action 说明了如何用两个子表达式的值生成 sum 表达式的语义值。</p>
<h4 id="编写-glr-解析器" class="headerLink">
    <a href="#%e7%bc%96%e5%86%99-glr-%e8%a7%a3%e6%9e%90%e5%99%a8" class="header-mark"></a>编写 GLR 解析器</h4><p>Bison 的确定性 LR(1) 解析算法无法在某些语法上决定如何在这个操作点上给出确定的操作，即产生了 <code>归约/归约</code> 冲突或 <code>移入/归约</code> 冲突。</p>
<p>有时需要更通用的解析文法，你的文件中声明 <code>%glr-parser</code> 就能生成 <strong>GLR</strong>
(Generalized LR) 解析器。GLR 解析器与确定性解析器处理普通 Bison 文法相同，只有在发生冲突时，GLR 采用两者兼顾的权宜之计，有效复刻出解析器以遵循这两种方式。每个复刻的解析器可以继续复刻，因此可以尝试任意可能的结果。解析器也同步进行，它们都消耗给定的符号才进入下一阶段。每个复刻出的解析器在发生错误时就将消亡，而没有错误的解析器则会和其他解析器合并，因为已经将输入减少到了同一组相同的符号。</p>
<p>期间的所有解析器只会记录 action 而不会操作，如果解析器消亡那么 action 也随之消亡。只有合并时根据记录的 action，根据语法的优先级，或执行所有 action 后在结果值上调用用户定义的函数产生合并结果。</p>
<p>更多有关 GLR 的内容，可以查看 Scott 在 2000 年发表的 <a href="https://www.cs.rhul.ac.uk/research/languages/publications/tomita_style_1.ps" target="_blank" rel="noopener noreferrer">Tomita-Style Generalised LR
Parsers</a>。</p>
<!--list-separator-->
<ul>
<li>
<p>无二义性 GLR 解析器示例</p>
<p>这个简单的示例是用 GLR 解析无二义性但无法成为 LR(1) 的文法，这种文法是典型需要向前看不止一个符号的文法。考虑在 Pascal 语言中出现的枚举声明与 subrange 类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type subrange = lo .. hi;
</span></span><span class="line"><span class="cl">type enum = (a, b, c);
</span></span></code></pre></td></tr></table>
</div>
</div><p>原始的语言标准只允许数字字面量或常量标识符出现在 subrange 中，但扩展 Pascal
(ISO/IEC 10206) 和更多的 Pascal 实现都允许任意表达式。这就可以比如这样的表达式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type subrange = (a) .. b;
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是枚举类型的声明与这很类似</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type enum = (a);
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>..</code> 之前这都是相同的，当 LR(1) 文法解析到这里时不可能在两种形式上做出决定，但解析器必须做出这一点。如果是 subrange 的话 a 可以是一个常量或函数调用，而枚举的话则必须是一个标识符。如果将 <code>(a)</code> 解析成未指定的标识符从而稍后解决，但这通常需要在语义动作和大部分语法中进行大量扭曲。</p>
<p>你可能希望通过 lex 为当前定义和未定义的标识符返回不同的标记来区分两种状态。但声明出现在 local 但 a 为 extern 定义，那么需要重新定义 a 或使用 extern 的 a。所以这是行不通的。</p>
<p>简单的方法就是使用 GLR 算法，分裂成两个分支，同时解析两个语法规则，迟早会有一个分支因错误而消亡。在下一个 <code>;</code> 之前有一个 <code>..</code> 会导致枚举规则的分支解析失败，否则导致 subrange 的分支解析失败。因此只有一个分支会保存下来。如果两个分支都失败，
GLR 则会像往常一样发出一个语法错误。所有的一切影响是解析器似乎猜到正确的分支，或者说这似乎比底层使用的 LR(1) 支持了更多的向前看符号。虽然示例是个 LR(2) 的文法，但 GLR 也可以针对 LR(k) 的情况做正确的处理。</p>
<p>一般来说 GLR 解析器可以采用二到三次最坏的情况时间，但 GLR 的某些语法解析可能需要指数的时间与空间，实际上这种情况对于许多语法来说不会发生。示例中仅在两个规则之间发生了冲突，且这两个冲突的类型声明上下文不能嵌套。因此任意时间存在的分支被限制在两个，解析时间依然是线性的。</p>
<p>虽然用户可以不加修改语法文件的情况下，将 LR 解析器替换为 GLR 解析器，用户甚至不会注意解析器在何时分叉。但需要注意的是， LR 解析器在冲突中会静态选择错误的替代方案，GLR 则会进行分叉继续向下分析，从而导致问题不那么明显。另外需要小心地与词法分析器进行交互，分叉后解析器不进行任何执行动作，因此无法通过解析器获取操作信息。好在 Bison 可以将复杂性从与词法分析器的交互转移到 GLR 解析器，但仍要检查其余情况的正确性。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>二义性文法 GLR 解析器示例</p>
<p>从一个简化的 C++ 语法示例看起</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">  #include &lt;stdio.h&gt;
</span></span><span class="line"><span class="cl">  #define YYSTYPE char const *
</span></span><span class="line"><span class="cl">  int yylex (void);
</span></span><span class="line"><span class="cl">  void yyerror (char const *);
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%token TYPENAME ID
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%right &#39;=&#39;
</span></span><span class="line"><span class="cl">%left &#39;+&#39;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%glr-parser
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">prog:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| prog stmt                          { printf (&#34;\n&#34;); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">stmt:
</span></span><span class="line"><span class="cl">  expr &#39;;&#39;  %dprec 1
</span></span><span class="line"><span class="cl">| decl      %dprec 2
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">expr:
</span></span><span class="line"><span class="cl">  ID                                 { printf (&#34;%s &#34;, $$); }
</span></span><span class="line"><span class="cl">| TYPENAME &#39;(&#39; expr &#39;)&#39;              { printf (&#34;%s &lt;cast&gt; &#34;, $1); }
</span></span><span class="line"><span class="cl">| expr &#39;+&#39; expr                      { printf (&#34;+ &#34;); }
</span></span><span class="line"><span class="cl">| expr &#39;=&#39; expr                      { printf (&#34;= &#34;); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">decl:
</span></span><span class="line"><span class="cl">  TYPENAME declarator &#39;;&#39;            { printf (&#34;%s &lt;declare&gt; &#34;, $1); }
</span></span><span class="line"><span class="cl">| TYPENAME declarator &#39;=&#39; expr &#39;;&#39;   { printf (&#34;%s &lt;init-declare&gt; &#34;, $1); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">declarator:
</span></span><span class="line"><span class="cl">  ID                                 { printf (&#34;\&#34;%s\&#34; &#34;, $1); }
</span></span><span class="line"><span class="cl">| &#39;(&#39; declarator &#39;)&#39;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果解析一个二义性程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">T</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个语法将在 x 被解释为 ID 后 (假设 T 被解释成 TYPENAME) 分叉，因为规则 <code>expr: ID</code> 和 <code>declarator: ID</code> 都可以归约，这里产生归约/归约冲突。之后随着进行 expr 分支被归约为 <code>stmt: expr ';'</code> 而 decl 分支被归约为 <code>stmt: decl</code>，之后两个解析器都看到了 <code>prog stmt</code> 以及剩余相同的未处理输入，这里需要进行合并。但 bison 语法定义的 <code>%dprec</code> 声明将优先将示例解析为 decl。</p>
<p>当然 <code>%dprec</code> 仅在多个解析器存在的时候有效，比如以下这个例子，这里没有歧义，在看到 <code>+</code> 时 decl 分支将消亡，因此 bison 不会看 %dprec 定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">T</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你不想解决歧义，而是像查看所有可能性，那就必须合并分支，而不是选择一个分支。因此需要更改 stmt 声明为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">stmt:
</span></span><span class="line"><span class="cl">  expr &#39;;&#39;   %merge &lt;stmtMerge&gt;
</span></span><span class="line"><span class="cl">| decl       %merge &lt;stmtMerge&gt;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>并定义以下函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">YYSTYPE</span> <span class="nf">stmtMerge</span><span class="p">(</span><span class="n">YYSTYPE</span> <span class="n">x0</span><span class="p">,</span> <span class="n">YYSTYPE</span> <span class="n">x1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;&lt;OR&gt; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然还要进行 C 声明 (类似 flex)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#define YYSTYPE char const *
</span></span><span class="line"><span class="cl">static YYSTYPE stmtMerge(YYSTYPE x0, YYSTYPE x1);
</span></span><span class="line"><span class="cl">%}
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bison 要求参与合并的产生体都要有相同的 merge 句柄，否则将无法处理歧义，解析器也会因存在不合法合并而报错。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>GLR 语义行为</p>
<p>GLR 解析的性质与解析器的结构为语义值与行为产生了一些限制。</p>
 <!--list-separator-->
<ul>
<li>
<p>延迟语义行为</p>
<p>延迟行为不会与关联的归约一同执行，这可能会对在 GLR 解析器的语义行为中使用某行功能产生影响。</p>
<ul>
<li><strong>yychar</strong> 可以确定相关归约出现时的向前看 token 的类型。</li>
<li><strong>yylval</strong> 与 <strong>yylloc</strong> 可以在 yychar 不为 <code>YYEMPTY</code> 或 <code>YYEOF</code> 时，确定向前看
token 的语义值与位置。</li>
</ul>
<p>非延迟行为你可以修改这些变量来影响语法分析结果，但延迟语义即使修改变量也意味着语法分析已经结束。另外延迟行为中，它们被设置为相关归约时具有的值的浅拷贝，因此修改它们是十分危险的。修改的结果是一个 UB。</p>
</li>
</ul>
 <!--list-separator-->
<ul>
<li>
<p>YYERROR</p>
<p>可以在语义行为中调用 YYERROR 来进行错误恢复，但延迟行为导致错误的精确点不再确定，因此会重新恢复到确定性解析，选择一个未指定的栈继续处理语法错误，YYERROR 会静默调用测试。</p>
</li>
</ul>
 <!--list-separator-->
<ul>
<li>
<p>限制语义值和位置</p>
<p>GLR 解析器会要求在使用 C++ 代码时，为语义值与位置使用 POD 类型。</p>
</li>
</ul>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>位置</p>
<p>解释器或编译器需要对错误信息进行详尽、有用的反馈，这就需要可以追踪源代码的文本位置。好在 Bison 在每个 token 都关联了位置，但位置类型是所有 token 或分组完全相同的。</p>
<p>比如示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr: expr &#39;+&#39; expr   { $$ = $1 + $3; } ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当前分组的位置为 <code>$$</code>，而子表达式的位置为 <code>$1</code> 和 <code>$3</code>。通常不用为每个规则描述其
<code>$$</code> 如何形成的，默认行为是采用第一个符号的开头和最后一个符号的结尾。</p>
</li>
</ul>
<h3 id="bison-语法文件" class="headerLink">
    <a href="#bison-%e8%af%ad%e6%b3%95%e6%96%87%e4%bb%b6" class="header-mark"></a>Bison 语法文件</h3><p>Bison 输入上下文无关的语法，并生成识别语法的 C 语言代码。</p>
<p>语法文件类似于以下结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">PROLOGUE
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">BISON DECLARATIONS
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">GRAMMAR RULES
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">EPILOGUE
</span></span></code></pre></td></tr></table>
</div>
</div><p>并且可以使用 C 和 C++ 样式的注释。</p>
<p>序言 (Prologue) 部分可以包含宏定义以及函数与变量的声明，这将拷贝到生成文件的开头。这部分内容存放在 <code>%{</code> 与 <code>%}</code> 块中。这与 Flex 类似。序言可以与 Bison 的声明混在一起，可以与 C 与 Bison 相互引用。但是通常将序言放在所有 Bison 声明之前更安全。比如任何的功能测试宏的定义 <code>_GNU_SOURCE</code> 和 <code>_POSIX_C_SOURCE</code> 都应如此。</p>
<p>声明 (Declaration) 部分包含定义终结符、非终结符、指定优先级等。一些简单的语法可能不需要声明。声明主要定义用于指定语法的符号和语义值的数据类型。</p>
<p>规则 (Rule) 部分至少有一个规则，用来编写语法分析处理行为。</p>
<p>结尾 (Epilogue) 会将所有代码复制到生成的解析器的末尾，和之前 Flex 的结尾一样。</p>
<h4 id="bison-语法--grammar" class="headerLink">
    <a href="#bison-%e8%af%ad%e6%b3%95--grammar" class="header-mark"></a>Bison 语法 (Grammar)</h4><!--list-separator-->
<ul>
<li>
<p>Bison 语法规则</p>
<p>语法规则很简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">RESULT: COMPONENTS ...;
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 RESULT (结果) 是该规则的非终结符，COMPONENTS (组件) 是有改规则组合在一起的各种终结符和非终结符。散布在组件之间的可以是确定规则的语义行为，通常是 C 语言行为，但 Bison 不会检查其正确性，只会完完整整地复制代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">{ C STATEMENTS }
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用 <code>|</code> 连接多个规则。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">RESULT:
</span></span><span class="line"><span class="cl">  RULE1-COMPONENTS ...
</span></span><span class="line"><span class="cl">| RULE2-COMPONENTS ...
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果一个规则的 COMPONENTS 为空，则称为 <code>empty</code>。那么 RESULT 可以匹配空字符串。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">RUSULT: | &#34;;&#34; ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>上一个写法可能不那么好看，有个更好的写法是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">RUSULT:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| &#34;;&#34;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果添加 <code>-Wempty-rule</code> 将警告没有 <code>%empty</code> 的空规则，如果想关掉则使用
<code>-Wno-empty-rule</code>。另外这是 Bison 的扩展，如果想兼容 POSIX Yacc，则写法是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">RUSULT:
</span></span><span class="line"><span class="cl">  /* empty */
</span></span><span class="line"><span class="cl">| &#34;;&#34;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Bison 递归规则</p>
<p>当一个规则的非终结符也出现在右部时，这就是递归。递归几乎是 Bison 语法必须的部分，因为这是定义任意数量的特定事物序列的唯一方法。下面示例中，expseq1 是左递归的，而
expseq2 是右递归的，但这两个非终结符是等价的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expseq1:
</span></span><span class="line"><span class="cl">  exp
</span></span><span class="line"><span class="cl">| expseq1 &#39;,&#39; exp
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">expseq2:
</span></span><span class="line"><span class="cl">  exp
</span></span><span class="line"><span class="cl">| exp &#39;,&#39; expseq2
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是在编写时，应该更多地使用左递归，即迭代，它可以在有限堆栈空间上解析任意数量的元素，但右递归 (递归) 所用堆栈空间与元素数量成正比。</p>
<p>另外还有<code>间接</code>或<code>相互</code>执行的递归。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr:
</span></span><span class="line"><span class="cl">  primary
</span></span><span class="line"><span class="cl">| primary &#39;+&#39; primary
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">primary:
</span></span><span class="line"><span class="cl">  constant
</span></span><span class="line"><span class="cl">| &#39;(&#39; expr &#39;)&#39;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="定义语言语义" class="headerLink">
    <a href="#%e5%ae%9a%e4%b9%89%e8%af%ad%e8%a8%80%e8%af%ad%e4%b9%89" class="header-mark"></a>定义语言语义</h4><p>语言的语法规则仅约定语法，语义是由各种标记和分组相关的语义值，以及在识别各个分组时所采取的动作确定的。</p>
<!--list-separator-->
<ul>
<li>
<p>语义值的数据类型</p>
<p>一个简单的程序中，语义值采用相同的类型就够了，比如计算器。Bison 通常将其设置为
<code>int</code>，如果要指定其他类型，则需要</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.value.type {double}
</span></span></code></pre></td></tr></table>
</div>
</div><p>或者使用 C/C++ 的预处理器来定义 <code>YYSEYPE</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define YYSTYPE double
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这个宏必须写在 Prologue 中，如果需要对 POSIX Yacc 的兼容性，则需要使用它。</p>
<p>但是你可能需要不止一种语义值的数据类型，但是想用多数据类型就要做两件事</p>
<ol>
<li>指定数据类型的整个集合，有以下几种选择
<ul>
<li>让 Bison 根据分配的标签计算</li>
<li>使用 Bison 的 <code>%union</code> 声明</li>
<li>使用 <code>%define</code> 将变量 <code>api.value.type</code> 定义为联合类型</li>
<li>使用 <code>typedef</code> 或 <code>#define</code> 将 YYSTYPE 定义为联合类型，其成员名称是类型标签</li>
</ul>
</li>
<li>使用语义值的每个符号选择其中一种类型</li>
</ol>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>生成语义值类型</p>
<p>用 <code>%define</code> 定义变量 <code>api.value.type</code> 为 <code>union</code>，用 Bison 提供的 <code>%type</code> 与
<code>%token</code> 定义真正的类型。如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.value.type union
</span></span><span class="line"><span class="cl">%token &lt;int&gt; INT &#34;integer&#34;
</span></span><span class="line"><span class="cl">%token &lt;int&gt; &#39;n&#39;
</span></span><span class="line"><span class="cl">%type &lt;int&gt; expr
</span></span><span class="line"><span class="cl">%token &lt;char const *&gt; ID &#34;identifier&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>生成适当的 YYSTYPE 值来支持每种符号类型。由 token 声明的标识符 (如上面的 INT 和
ID)，在 YYSTYPE 中以字段名称的形式出现。而 &rsquo;n&rsquo; 并不是指定名称的字段，因此编写代码时不应依赖它们</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// For an &#34;integer&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">yylval</span><span class="p">.</span><span class="n">INT</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">INT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// For an &#39;n&#39;, also declared as int
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">yylval</span><span class="p">)</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="sc">&#39;n&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// For an &#34;identifier&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">yylval</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="s">&#34;42&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">ID</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了避免名称冲突，来可以用 <code>%define</code> 来指定 <code>api.token.prefix</code> 来定义前缀。当然这又是个 Bison 扩展，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// %define api.token.prefix {TOK_}
</span></span></span><span class="line"><span class="cl"><span class="c1">// For an &#34;integer&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">yylval</span><span class="p">.</span><span class="n">TOK_INT</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">TOK_INT</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Union 声明</p>
<p><code>%union</code> 声明语义值指定了可能包含的数据类型的集合，其中包含与 C 的 union 中的内容相同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%union {
</span></span><span class="line"><span class="cl">    double val;
</span></span><span class="line"><span class="cl">    symrec *tptr;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以为 union 加上 <code>vaule</code> 标签，在定义了 <code>api.vaule.union.name</code> 时可以生成类型的名称，在不定义时默认使用 YYSTYPE。由于 POSIX 可以多次声明 union，最终将这些
union 串联起来，因此只有第一个 union 定义可以加 value 标签。</p>
<p>如果语法至少包含一个 <code>&lt;type&gt;</code> 标签，则可以使用自己定义的 YYSTYPE，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// parser.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">union</span> <span class="n">YYSTYPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">symrec</span> <span class="o">*</span><span class="n">tptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并修改为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%{
</span></span><span class="line"><span class="cl">#include &#34;parser.h&#34;
</span></span><span class="line"><span class="cl">%}
</span></span><span class="line"><span class="cl">%define api.value.type {union YYSTYPE}
</span></span><span class="line"><span class="cl">%type &lt;val&gt; expr
</span></span><span class="line"><span class="cl">%token &lt;tptr&gt; ID
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Bison 行为</p>
<p>每个行为都可以在识别时带有一个 C 代码行为，这些行为的任务多是根据与标记或较小分组关联的语义值计算由规则构建的分组的语义值。</p>
<p>之前也见到了，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr : | expr &#39;+&#39; expr { $$ = $1 + $3; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然还可以给每个位置命名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr[result]: | expr[left] &#39;+&#39; expr[right] { $result = $left + $right; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果没为规则指定操作，Bison 会使用默认的 <code>$$ = $1</code>，空规则应该具有显式的行为，除非规则的值无关紧要。</p>
<p>另外指定位置为 0 或负数是十分危险的行为，除非你确定上下文的规则了，否则不要使用它。比如下面这个示例，<code>$0</code> 总是指 foo 中定义在 bar 之前的 <code>expr</code>，如果存在还可以通过 yylval 访问前瞻语义值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">foo:
</span></span><span class="line"><span class="cl">  expr bar &#39;+&#39; expr { ... }
</span></span><span class="line"><span class="cl">| expr bar &#39;0&#39; expr { ... }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">bar:
</span></span><span class="line"><span class="cl">  %empty { previsous_expr = $0; }
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>行为中值的数据类型</p>
<p>如果语义值是单一数据类型，那么 <code>$$</code> 与 <code>$N</code> 始终是相同的数据类型；但多种类型的语义值，必须为每个可以具有语义值的终结符、非终结符选择类型，每次使用 <code>$$</code> 和 <code>$N</code>
时，它的数据类型由规则的引用符号决定。比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr : | expr &#39;+&#39; expr { $$ = $1 + $3; }
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然也可以在引用值时指明数据类型，比如说写成 <code>$&lt;INT&gt;1</code>。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>规则中行为</p>
<p>有时将行为放在规则中间很有用，它可以在解析器识别下一个组件前执行。</p>
<p>中间规则只能引用之前的 <code>$N</code>，而不能引用之后的位置。规则中行为往往算作规则的组成部分，并且也具有语义值，另外行为可以通过给 <code>$$</code> 设置值，规则后面的行为可以用
<code>$N</code> 引用这个值，由于没有符号来命名行为，因此无法提前为该值声明数据类型，每次引用都需要指定数据类型 <code>$&lt;TYPE&gt;N</code>。并无法通过规则中行为设置整体的值，唯一的方法就是规则末尾的行为。示例处理一个 <code>let (VARIABLE) STATEMENT</code> 的 let 语句，需要在
STATEMENT 期间临时创建一个名为 VARIABLE 的变量，在解析 STATEMENT 时必须将
VARIABLE 放入符号表，并在之后将其删除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">stmt:
</span></span><span class="line"><span class="cl">  &#34;let&#34; &#39;(&#39; var &#39;)&#39;
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      $&lt;context&gt;$ = push=context();
</span></span><span class="line"><span class="cl">      declare_variable($3);
</span></span><span class="line"><span class="cl">    }/* [let] */
</span></span><span class="line"><span class="cl">  stmt
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      $$ = $6;
</span></span><span class="line"><span class="cl">      pop_context($&lt;context&gt;5/* let */);
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果解析器启动错误恢复程序时，可能丢弃之前的上下文而不恢复它，那么 <code>$&lt;context&gt;5</code>
就泄漏了，需要一个析构函数来完成中间行为的释放。解决方法是将中间行为放在非终结符的行为中，并为该非终结符定义一个析构函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%type &lt;context&gt; let
</span></span><span class="line"><span class="cl">%destructor { pop_context($$); } let
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">stmt:
</span></span><span class="line"><span class="cl">  let stmt
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      $$ = $2;
</span></span><span class="line"><span class="cl">      pop_context($let);
</span></span><span class="line"><span class="cl">    };
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">let:
</span></span><span class="line"><span class="cl">  &#34;let&#34; &#39;(&#39; var &#39;)&#39;
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      $let = push_context();
</span></span><span class="line"><span class="cl">      declare_variable($3);
</span></span><span class="line"><span class="cl">    };
</span></span></code></pre></td></tr></table>
</div>
</div><p>在编译 bison 语法时，如果使用了中间行为，加上 <code>-Wmidrule-value</code> 是一个不错的选择，它可以帮我们检查中间行为中的一些问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">bison -fcaret -Wmidrule-value mid.y
</span></span><span class="line"><span class="cl">     mid.y:2.6-13: warning: unset value: $$
</span></span><span class="line"><span class="cl">      exp: { a(); } &#34;b&#34; { $$ = c(); } { d(); } &#34;e&#34; { f = $1; };
</span></span><span class="line"><span class="cl">           ^^^^^^^^
</span></span><span class="line"><span class="cl">     mid.y:2.19-31: warning: unused value: $3
</span></span><span class="line"><span class="cl">      exp: { a(); } &#34;b&#34; { $$ = c(); } { d(); } &#34;e&#34; { f = $1; };
</span></span><span class="line"><span class="cl">                        ^^^^^^^^^^^^^
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="追踪位置" class="headerLink">
    <a href="#%e8%bf%bd%e8%b8%aa%e4%bd%8d%e7%bd%ae" class="header-mark"></a>追踪位置</h4><p>尽管语法规则和语义行为足以编写一个功能齐全的解析器，但处理一些额外的信息，尤其是符号位置可能很有用。处理位置的方式是通过提供数据类型和匹配规则时要采取的行为来定义的。</p>
<!--list-separator-->
<ul>
<li>
<p>位置的数据类型</p>
<p>位置定义的数据类型比语义值简单很多，毕竟所有标记与分组都是相同的类型。通过
YYLTYPE 定义位置的类型，默认 Bison 指定的类型为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">YYLTYPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">first_line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">first_column</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_column</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">YYLTYPE</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些字段在解析开始时被初始化为 yylloc 的 <code>1</code>。自定义位置类型的话，需要使用
<code>%initial-action</code> 操作。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>位置与行为</p>
<p>与访问规则类似，访问位置使用表达式 <code>@N</code>，而左边的非终结符位置为 <code>@$</code>。位置也可以用命名位置 <code>@[NAME]</code> 或 <code>@NAME</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exp:
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">| exp &#39;/&#39; exp
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      @$.first_column = @1.first_column;
</span></span><span class="line"><span class="cl">      @$.first_line = @1.first_line;
</span></span><span class="line"><span class="cl">      @$.last_column = @3.last_column;
</span></span><span class="line"><span class="cl">      @$.last_line = @3.last_line;
</span></span><span class="line"><span class="cl">      if ($3)
</span></span><span class="line"><span class="cl">        $$ = $1 / $3;
</span></span><span class="line"><span class="cl">      else
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">          $$ = 1;
</span></span><span class="line"><span class="cl">          fprintf (stderr, &#34;%d.%d-%d.%d: division by zero&#34;,
</span></span><span class="line"><span class="cl">                   @3.first_line, @3.first_column,
</span></span><span class="line"><span class="cl">                   @3.last_line, @3.last_column);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>每次匹配规则时，都会运行位置的默认操作，将 <code>@$</code> 的开头设置为第一个符号的开头，将
<code>@$</code> 的结尾指向最后一个符号的结尾。当然这是自动执行的，因此上下两个代码等价</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exp:
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">| exp &#39;/&#39; exp
</span></span><span class="line"><span class="cl">    {
</span></span><span class="line"><span class="cl">      if ($3)
</span></span><span class="line"><span class="cl">        $$ = $1 / $3;
</span></span><span class="line"><span class="cl">      else
</span></span><span class="line"><span class="cl">        {
</span></span><span class="line"><span class="cl">          $$ = 1;
</span></span><span class="line"><span class="cl">          fprintf (stderr, &#34;%d.%d-%d.%d: division by zero&#34;,
</span></span><span class="line"><span class="cl">                   @3.first_line, @3.first_column,
</span></span><span class="line"><span class="cl">                   @3.last_line, @3.last_column);
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>位置的默认行为</p>
<p>由于位置比语义值更通用，因此行为并不是计算位置的最佳位置。在每次匹配规则时运行相关操作之前都会调用 <code>YYLLOC_DEFAULT</code>，处理语法错误实惠调用它来计算错误位置。在报告无法解决的语法歧义之前，GLR 也会递归调用它来计算歧义的位置。大多数时候该宏就足够通用了。</p>
<p>YYLLOC_DEFAULT 有三个参数，即分组的位置 (计算结果)、元素位置、右边的大小。当 GLR
报告歧义时，将多个未定义的候选传递给 YYLLOC_DEFAULT；在错误处理时，第二个参数表示在错误处理期间被丢弃的符号位置，第三个参数时丢弃的符号数量。默认定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp"># define YYLLOC_DEFAULT(Cur, Rhs, N)                      \
</span></span></span><span class="line"><span class="cl"><span class="cp">do                                                        \
</span></span></span><span class="line"><span class="cl"><span class="cp">  if (N) {                                                \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).first_line   = YYRHSLOC(Rhs, 1).first_line;   \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).first_column = YYRHSLOC(Rhs, 1).first_column; \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).last_line    = YYRHSLOC(Rhs, N).last_line;    \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).last_column  = YYRHSLOC(Rhs, N).last_column;  \
</span></span></span><span class="line"><span class="cl"><span class="cp">    } else {                                              \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).first_line   = (Cur).last_line   =            \
</span></span></span><span class="line"><span class="cl"><span class="cp">        YYRHSLOC(Rhs, 0).last_line;                       \
</span></span></span><span class="line"><span class="cl"><span class="cp">      (Cur).first_column = (Cur).last_column =            \
</span></span></span><span class="line"><span class="cl"><span class="cp">        YYRHSLOC(Rhs, 0).last_column;                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">    }                                                     \
</span></span></span><span class="line"><span class="cl"><span class="cp">while (0)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>YYRHSLOC(rhs, k)</code> (k 为正时，表示 RHS 的第 k 个符号)，当 k 和 N 都为零时，符号在归约之前的位置。定义 YYLLOC_DEFAULT 之前应该考虑：</p>
<ul>
<li>所有的参数都没有副作用。只有第一个 (结果) 可以被宏修改</li>
<li>为与语义行为保持一致，右侧的有效索引范围为 1 到 N。当 N 为 0 时只有 0 时有效索引，指归约前的符号。在错误处理期间 N 始终为正。</li>
</ul>
</li>
</ul>
<h4 id="名称引用" class="headerLink">
    <a href="#%e5%90%8d%e7%a7%b0%e5%bc%95%e7%94%a8" class="header-mark"></a>名称引用</h4><p>用编号指定位置或规则一点也不好用还容易出错，因此使用名称引用更有可读性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">invocation: op &#39;(&#39; args &#39;)&#39; { $$ = new_invocation ($op, $args, @$); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是有时候一个递归语法，可能出现二义性。但是又不想用编号的情况下，可以用
<code>[NAME]</code> 来指定名称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exp: exp &#39;/&#39; exp { $exp = $exp / $exp; }  // $exp is ambiguous.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">exp: exp &#39;/&#39; exp { $$ = $1 / $exp; }      // One usage is ambiguous.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">exp: exp &#39;/&#39; exp { $$ = $1 / $3; }        // No error.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">exp[result]: exp[left] &#39;/&#39; exp[right]
</span></span><span class="line"><span class="cl">  { $result = $left / $right }            // No error.
</span></span></code></pre></td></tr></table>
</div>
</div><p>在使用点、破折等字符时，需要显式括号语法。这是由于 Bison 通常将 <code>$name.suffix</code>
解析为 <code>$name</code> 与语义值字段 <code>suffix</code>。为识别整体必须用此语法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if-stmt: &#34;if&#34; &#39;(&#39; expr &#39;)&#39; &#34;then&#34; then.stmt &#39;;&#39;
</span></span><span class="line"><span class="cl">  { $[if-stmt] = new_if_stmt ($expr, $[then.stmt]); }
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然中间行为也可以使用命名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exp[res]: exp[x] &#39;+&#39; {$left = $x;}[left] exp[right]
</span></span><span class="line"><span class="cl">  { $res = $left + $right; }
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="声明" class="headerLink">
    <a href="#%e5%a3%b0%e6%98%8e" class="header-mark"></a>声明</h4><p>Bison 声明部分用于指定语法的符号和语义值的数据类型。通常必须声明所有的 token (除了像 &lsquo;+&rsquo; 这种单字符字面量 token)。如果指定语义值的数据类型，那么就必须声明非终结符。</p>
<!--list-separator-->
<ul>
<li>
<p>Token 类型名</p>
<p>通常使用语法 <code>%token NAME</code> 来声明，这通常会被 Bison 在生成的解析器中用宏实现。当然还能指定其 token 的数字代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%token NUM 300
</span></span><span class="line"><span class="cl">%token XNUM 0x12d  // a GNU extension
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过更好的方式是让 Bison 自己选择数字代码，Bison 会保证其不冲突。就像之前提到的，使用自定义的语义值类型时需要自行定义其类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%union {          /* define stack type */
</span></span><span class="line"><span class="cl">    double val;
</span></span><span class="line"><span class="cl">    symrec *tptr;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">%token &lt;val&gt; NUM  /* define token NUM and its type */
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你需要将一些字符串字面量与标记类型相关联，可以用以下这种方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%token  &lt;operator&gt;  OR      &#34;||&#34;
</span></span><span class="line"><span class="cl">%token  &lt;operator&gt;  LE 134  &#34;&lt;=&#34;
</span></span><span class="line"><span class="cl">%left  OR  &#34;&lt;=&#34;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>声明运算符优先级</p>
<p>你可以使用 <code>%left</code>、<code>%right</code>、<code>%precedence</code> 或 <code>%nonassoc</code> 来替换 token，来指定其关联性和优先级，它们和 <code>%token</code> 一致，区别就在于指定了关联性和优先级：</p>
<ul>
<li>运算符 OP 的关联性取决于运算法嵌套的方式，即有些语言中说的<strong>左结合</strong>与<strong>右结合</strong>。比如表达式 <code>X OP Y OP Z</code>，左结合即运算符从左向右依次计算表达式，即 <code>(X OP Y) OP Z</code>；右结合正好相反，即<code>X OP (Y OP Z)</code>。而 <code>%nonassoc</code> 指定为无关联性，意思是 <code>X OP Y OP Z</code> 被认为语法错误。</li>
<li><code>%precedence</code> 赋予了符号相对的优先级，但不赋予其任何关联性。比如表达式 <code>X OP1 Y OP2 Z</code>，如果 OP2 的优先级高于 OP1，那么将解析为 <code>X OP1 (Y OP2 Z)</code>。</li>
<li>在单个优先级声明中，所有符号的优先级相同，它们根据关联性进行分组。当两个不同优先级的符号，后一个声明的 token 优先级更高。</li>
</ul>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>声明非终结符的类型</p>
<p>当自定义语义值类型时，就必须声明每个非终结符的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%type &lt;TYPE&gt; NONTERMINAL...
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>解析前执行行为</p>
<p>解析器可能需要在解析之前执行一些初始化。<code>%initial-action</code> 指令允许这样的操作，其中可以执行任意的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%parse-param { char const *file_name };
</span></span><span class="line"><span class="cl">%initial-action {
</span></span><span class="line"><span class="cl">  @$.initialize (file_name);
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>释放符号</p>
<p>在错误恢复期间，以压入栈的符号和来自文件其余部分的 token 将被丢弃，直到解析器停止运行。如果解析器内存不足，或它通过 YYABORT 或 YYACCEPT 返回，则必须丢弃堆栈上的所有符号。即使解释器成功，也必须丢弃开始符号。如果丢弃的数据在堆上，会造成内存泄漏，这种行为对批处理解析器 (如传统编译器) 是没问题的，但无限期解析和执行的程序
(如 shell) 是不可接受的。</p>
<p><code>%destructor</code> 指定了自动丢弃符号时调用的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%union { char *string; }
</span></span><span class="line"><span class="cl">%token &lt;string&gt; STRING1 STRING2
</span></span><span class="line"><span class="cl">%type &lt;string&gt; string1 string2
</span></span><span class="line"><span class="cl">%union { char character; }
</span></span><span class="line"><span class="cl">%token &lt;character&gt; CHR
</span></span><span class="line"><span class="cl">%type &lt;character&gt; chr
</span></span><span class="line"><span class="cl">%token TAGLESS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%destructor {  } &lt;character&gt;
</span></span><span class="line"><span class="cl">%destructor { free($$); } &lt;*&gt;
</span></span><span class="line"><span class="cl">%destructor { free($$); printf(&#34;%d&#34;, @$.first_line); } STRING1 string1
</span></span><span class="line"><span class="cl">%destructor { printf(&#34;Discarding tagless symbol.\n&#34;); } &lt;&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，解析器丢弃 CHR 和 chr 时不会做任何行为，而其他符号都会调用 <code>free</code>
函数来释放内存。当然在释放 STRING1 和 string1 的符号时，只会调用第二个析构函数，保证只会释放依次内存。</p>
<p>Bison 生成的解析器只为用户定义的符号调用 <code>%destructor</code>，也不会为中间行为调用析构函数。</p>
<p>丢弃的符号类型如下：</p>
<ul>
<li>错误恢复的第一阶段弹出堆栈的符号</li>
<li>错误恢复的第二阶段写入终端</li>
<li>解析器立即返回时的当前向前看符号和整个堆栈 (除非当前是生成体符号)</li>
<li>解析器成功时的开始符号</li>
</ul>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>声明抑制冲突警告</p>
<p>如果语法存在冲突，Bison 会发出警告 (虽然大部分冲突都是无害的移入归约冲突)，因此可以使用声明来抑制这些冲突。声明移入规约冲突数量为 <code>%expect N</code>，而声明归约归约冲突的数量为 <code>%expect-rr N</code>。N 说明应该有 N 个预期的相应的冲突，如果数量不对 Bison
将会发出警告。</p>
<p>使用 <code>%expect</code> 时你应该确保：</p>
<ul>
<li>编译时不用 <code>%expect</code> 并且使用 <code>-v</code> 选项可以查看冲突发生的具体信息，还会打印冲突的数量。</li>
<li>检查每个冲突一确保 Bison 的默认解决方案是符合预期的。不符合预期的语法需要重写并重新检查信息。</li>
<li>添加 <code>%expect</code> 声明。</li>
</ul>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>声明开始符号</p>
<p>Bison 假定文法的开始符号时指定的第一个非终结符，你可以自己指定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%start SYMBOL
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>声明可重入解析器</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><pre><code>对于 **Pure** 解析器，或许可以考虑生成 **Pure** 函数式语言代码，比如 Haskell
</code></pre>
</div>
        </div>
    </div>
<p>通常 Bison 生成的是不可重入的，因为这是与 Yacc 兼容的最重要一步。但依然不影响你可以抛弃对 Yacc 的兼容性，采用 <code>%define api.pure</code> 来生成可重入解析器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.pure full
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是生成可重入代码需要付出相应的代价，那就是通信变量 yylval 与 yylloc 成为
yyparse 的局部变量，并且 yylex 生成了不同的调用约定。另外错误处理变量 yynerrs 在
pull 模式下是 yyparse 的局部变量，而 push 模式下时 yypstate 的成员。</p>
<p>幸运的是，是否可重入并不影响语法规则，可以从任何有效的语法规则生成可重入或不可重入的解析器。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Push 解析器</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><pre><code>从 GNU Bison **3.1** 开始 push parsers 不再是实验性功能
</code></pre>
</div>
        </div>
    </div>
<p>Pull 解析器每调用一次，它都会控制直到所有输入都被解析。另一方面，每次有新 token
可用时都会被推送到解析器。客户端应用是主事件循环的一部分时，Push 解析器将很有用。需要在特定时间内触发事件循环，这通常是 GUI 的要求。</p>
<p>通常 Bison 会生成的是 Pull 解析器，如果希望生成 Push 解析器，可以声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.push-pull push
</span></span></code></pre></td></tr></table>
</div>
</div><p>在几乎所有情况下，Push 解析器应该都是<strong>纯</strong>解析器，除非直到自已在做什么</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.pure full
</span></span><span class="line"><span class="cl">%define api.push-pull push
</span></span></code></pre></td></tr></table>
</div>
</div><p>纯的 Push 解析器和不纯的 Push 解析器之间存在主要的功能差异。纯 Push 解析器可以同时在内存中拥有许多相同类型解析器的实例，相反不纯的只能使用一个解析器。</p>
<p><strong>yypstate</strong> 是生成的解析器用来存储解析器状态的结构，<code>yypstate_new</code> 是创建新解析器实例的函数，<code>yypstate_delete</code> 将释放相应解析器实例相关联的资源，而
<code>yypush_parse</code> 是当令牌可用于提供解析器时应该调用的函数。简单的调用示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">yypstate</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nf">yypstate_new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="nf">yypush_parse</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="nf">yylex</span><span class="p">(),</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">YYPUSH_MORE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">yypstate_delete</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用户决定使用不纯的 Push 解析器，则生成的解析器会发生一些变化。比如 yychar，将是一个全局变量而非 yypush_parse 中的局部变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">yychar</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">yypstate</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nf">yypstate_new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">yychar</span> <span class="o">=</span> <span class="nf">yylex</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="nf">yypush_parse</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">YYPUSH_MORE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">yypstate_delete</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bison 在同一个生成的解析器中还支持 Push 和 Pull 解析器接口。为获取此功能你可以使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define api.push-pull both
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了上述的符号，Bison 还会生成 yyparse (调用 pull 的解析器) 和 yypull_parse。可以使用 yypush_parse 来选择一个子语法，然后用 yypull_parse 解析输入流的其他部分。但如果想在 pull 和 push 之间来回切换需要自行编写 yypull_parse 函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">yypstate</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="nf">yypstate_new</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nf">yypull_parse</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">yypstate_delete</span><span class="p">(</span><span class="n">ps</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>%code 声明</p>
<p><code>%code</code> 可以比 <code>%{%}</code> 代码块提供更多的灵活性。通常情况下非限定的 <code>%code</code> 可以替换 <code>%{%}</code>。</p>
<p>重点主要放在限定代码块上。语法 <code>%code QUALIFIER { CODE }</code>。限定符有如下几种</p>
<ul>
<li>
<p>requires</p>
<p>通常在这里编写 YYSTYPE 与 YYLTYPE 依赖的代码，Bison 将这里的代码复制到头文件和源文件中的 YYSTYPE 与 YYLTYPE 的定义之前。</p>
</li>
<li>
<p>provides</p>
<p>通常在这里编写提供给其他模块的附加定义和声明。Bison 会将这些代码复制到
YYSTYPE、YYLTYPE 和 token 定义之后的头文件和源文件中。</p>
</li>
<li>
<p>top</p>
<p>需要在 Bison 生成的源代码文件中的顶部插入代码时，应该使用该限定符。</p>
</li>
</ul>
</li>
</ul>
<h3 id="解析器-c-语言接口" class="headerLink">
    <a href="#%e8%a7%a3%e6%9e%90%e5%99%a8-c-%e8%af%ad%e8%a8%80%e6%8e%a5%e5%8f%a3" class="header-mark"></a>解析器 C 语言接口</h3><p>Bison 的解析器实际上是名为 <strong>yyparse</strong> 的 C 函数。我们需要对其进行约定。请记住解析器出于内部的目的使用了很多 yy 或 YY 开头的 C 标识符，请小心冲突。</p>
<h4 id="解析器函数-yyparse" class="headerLink">
    <a href="#%e8%a7%a3%e6%9e%90%e5%99%a8%e5%87%bd%e6%95%b0-yyparse" class="header-mark"></a>解析器函数 yyparse</h4><p>你需要调用 yyparse 来进行解析。此函数读取标记、执行行为，并在遇到输入结束或不可恢复的语法错误时最终返回。你还可以编写一个行为，指示 yyparse 立即返回，而无需继续执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yyparse</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// RETURN YYACCEPT (0) if report success,
</span></span></span><span class="line"><span class="cl"><span class="c1">// RETURN YYABORT (1) if report failure,
</span></span></span><span class="line"><span class="cl"><span class="c1">// RETURN 2 if memory exhaustion.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>如果使用纯解析器，可以声明 <code>%parse-param</code> 为 yyparse 和 yyerror 定义额外的参数。比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%parse-param {int *nastiness} {int *randomness}
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明后，这两个的函数如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nastiness</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">randomness</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yyparse</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">nastiness</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">randomness</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然同时使用 <code>%define api.pure full</code> (或仅 <code>%define api.pure</code>) 和 <code>%locations</code>，
yyerror 将生成不一样的签名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="n">YYLTYPE</span> <span class="o">*</span><span class="n">llocp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">nastiness</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">randomness</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在调用时就可以这样使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">nastiness</span><span class="p">,</span> <span class="n">randomness</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">value</span> <span class="o">=</span> <span class="nf">yyparse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nastiness</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">randomness</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在语法的规则行为中，也可以使用由 yyparse 传入的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">exp: ... { ...; *randomness += 1; ... }
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="词法分析函数-yylex" class="headerLink">
    <a href="#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%87%bd%e6%95%b0-yylex" class="header-mark"></a>词法分析函数 yylex</h4><p>该函数从输入流中识别并返回 token，不会由 bison 创建，你可以使用 Flex 创建它。</p>
<!--list-separator-->
<ul>
<li>
<p>yylex 调用约定</p>
<p>yylex 必须返回 token 类型的整数值，零或负数表示输入结束。当然 token 只有一个字符时也可以直接返回该字符。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">INT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果语法使用字符串字面量 token，yylex 可以通过两种方式确定它们的标记类型代码：</p>
<ul>
<li>如果语法将符号 token 名称定义为字符串字面量别名，则 yylex 可以像所有其他符号一样使用这些符号名称。在这种情况下，在语法文件中使用字符串字面量 token 对
yylex 没有影响。</li>
<li>yylex 可以在 yytname 表中找到多字符 token，表中的索引是该 token 的编码，该
token 的名字用双引号 (&rdquo;) 包围并记录在表中。
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">YYNTOKENS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">yytname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">yytname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&#34;&#39;</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="o">!</span><span class="nf">strncmp</span><span class="p">(</span><span class="n">yytname</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">token_buffer</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">token_buffer</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">yytname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nf">strlen</span><span class="p">(</span><span class="n">token_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;&#34;&#39;</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">yytname</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nf">strlen</span><span class="p">(</span><span class="n">token_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>当使用 <code>%token-table</code> 声明时才会生成 yytname 表。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Token 的语义值</p>
<p>不可重入的解析器，所有语义值都存储在 yylval 中，如果使用单一语义值类型 (默认为
int)，可以用这种方式在 yylex 中使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">yylval</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>  <span class="c1">// 将值压入 Bison 栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="n">INT</span><span class="p">;</span>           <span class="c1">// 返回 token 类型
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当使用 <code>%union</code> 定义了多类型时，需要正确使用各个 union 字段。比如 union 如下定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%union {
</span></span><span class="line"><span class="cl">    int intval;
</span></span><span class="line"><span class="cl">    doubal val;
</span></span><span class="line"><span class="cl">    symrec *tptr;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>yylex 中需要如下使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">yylval</span><span class="p">.</span><span class="n">intval</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">INT</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>Token 的文本位置</p>
<p>如果在行为中使用 <code>@N</code> 功能来跟踪 token 和分组的文本位置，那么必须在 yylex 中提供此信息。但相对的，这会明显拖慢解析器的速度。</p>
<p>通常情况下只需要正确处理 yylloc 的成员即可，其类型通常为 YYLTYPE，定义通常如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">YYLTYPE</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">first_line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">first_column</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_line</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_column</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">YYLTYPE</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>纯解析器的调用约定</p>
<p>如果你用来可重入的解析器，那不能使用全局变量 yylloc 和 yylval，需要将这两个变量以参数的形式传递给 yylex。原型如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">yylex</span><span class="p">(</span><span class="n">YYSTYPE</span> <span class="o">*</span><span class="n">lvalp</span><span class="p">,</span> <span class="n">YYLTYPE</span> <span class="o">*</span><span class="n">llocp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果没有使用位置参数的话，将不会定义 YYSTYPE，也就不需要由参数 lvalp 了。如果还需要其他参数，可以使用 <code>%lex-param</code> 来声明其他参数，用法和之前的 <code>%parse-param</code>
一样。如果想对 yyparse 和 yylex 都传入某个参数可以使用 <code>%param</code>。</p>
</li>
</ul>
<h4 id="错误处理函数-yyerror" class="headerLink">
    <a href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0-yyerror" class="header-mark"></a>错误处理函数 yyerror</h4><p>每当 Bison 解析器读取不能满足任何语法规则的标记时，它就会检测到语法错误。语法中的行为也可以使用宏 YYERROR 显式声明错误。Bison 解析器希望通过调用名为 yyerror 的函数来报告错误，用户必须实现该函数。函数原型如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 yyerror 返回后，yyparse 还会尝试使用编写的错误恢复规则，如果无法恢复，yyparse
将返回 1。</p>
<p>当你使用纯解析器时 (<code>%define api.pure full</code>)，将会生成原型为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">yyerror</span><span class="p">(</span><span class="n">YYLTYPE</span> <span class="o">*</span><span class="n">locp</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="解析器-i18n" class="headerLink">
    <a href="#%e8%a7%a3%e6%9e%90%e5%99%a8-i18n" class="header-mark"></a>解析器 i18n</h4><p>Bison 支持解析器的国际化 (i18n)，我想这是个我用不上的功能。Bison 采用的 i18n 方案是通用的 <a href="https://www.gnu.org/software/gettext/" target="_blank" rel="noopener noreferrer">gettext</a>。</p>
<h3 id="bison-解析器算法" class="headerLink">
    <a href="#bison-%e8%a7%a3%e6%9e%90%e5%99%a8%e7%ae%97%e6%b3%95" class="header-mark"></a>Bison 解析器算法</h3><p>Bison 在读取 token 时，会将 token 及其语义值一起推送到名为 parser stack 的栈上，而这个行为被称为移入。但不会总是移入，当最后 N 个元素与语法规则相匹配时，元素将会组合，这个步骤称为归约。当解析器通过移入与归约，直到将整个输入串归约成单个分组时，我们将剩下的这个符号称作开始符号。而解析器的整个操作是自下而上的。</p>
<h4 id="向前看符号" class="headerLink">
    <a href="#%e5%90%91%e5%89%8d%e7%9c%8b%e7%ac%a6%e5%8f%b7" class="header-mark"></a>向前看符号</h4><p>就像之前的理论部分，解析器向前看一个符号，来确定下一个动作是什么。如果我们写下一个阶乘代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr:
</span></span><span class="line"><span class="cl">  term &#39;+&#39; expr
</span></span><span class="line"><span class="cl">| term
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">term:
</span></span><span class="line"><span class="cl">  &#39;(&#39; expr &#39;)&#39;
</span></span><span class="line"><span class="cl">| term &#39;!&#39;
</span></span><span class="line"><span class="cl">| &#34;number&#34;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在假设输入上的 <code>1+2</code> 已被读入并移入栈</p>
<ul>
<li>如果后面是 <code>)</code> 那么栈顶的三个元素将被归约为 expr，这是唯一有效的操作，因为移入之后没有规则继续</li>
<li>如果后面是 <code>!</code> 那么会移入符号，以便 <code>2!</code> 可以归约成一项。如果在移入之前归约，那么将没有规则可以继续</li>
</ul>
<p>可以通过 yychar 查看向前看符号。</p>
<h4 id="移入归约冲突" class="headerLink">
    <a href="#%e7%a7%bb%e5%85%a5%e5%bd%92%e7%ba%a6%e5%86%b2%e7%aa%81" class="header-mark"></a>移入归约冲突</h4><p>经典的悬空 else 问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if_stmt:
</span></span><span class="line"><span class="cl">  &#34;if&#34; expr &#34;then&#34; stmt
</span></span><span class="line"><span class="cl">| &#34;if&#34; expr &#34;then&#34; stmt &#34;else&#34; stmt
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当 else 成为向前看符号时，移入规则有效，归约规则也有效，这就产生了一个移入规约冲突。但是 Bison 解析器更喜欢采用移入规则解决这种冲突。</p>
<p>悬空 else 问题往往的解决方式是，通常原则是 else 匹配最近的 if，那么下面这两行代码等价</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if x then if y then win; else lose;
</span></span><span class="line"><span class="cl">if x then do; if y then win; else lose; end;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果选用归约规则，与通常原则将大相径庭。就是下面这两行例子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">if x then if y then win; else lose;
</span></span><span class="line"><span class="cl">if x then do; if y then win; end; else lose;
</span></span></code></pre></td></tr></table>
</div>
</div><p>既然移入/归约冲突都是移入优先，那用之前介绍的 <code>%expect N</code> 可以吗？</p>
<div class="details admonition warning open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-exclamation-triangle fa-fw"></i>警告<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">不建议使用 <code>%expect N</code> (除 <code>%expect 0</code>)，即使移入归约冲突的数量正确，不代表发生错误的原因是预期的</div>
        </div>
    </div>
<h4 id="操作符优先级" class="headerLink">
    <a href="#%e6%93%8d%e4%bd%9c%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7" class="header-mark"></a>操作符优先级</h4><p>算数表达式中也经常出现移入归约冲突，但这里移入不总是首选。优先级则是处理这类问题的一种解决方法。</p>
<p>想想这段代码，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">expr:
</span></span><span class="line"><span class="cl">  expr &#39;+&#39; expr
</span></span><span class="line"><span class="cl">| expr &#39;*&#39; expr
</span></span><span class="line"><span class="cl">| expr &#39;&lt;&#39; expr
</span></span><span class="line"><span class="cl">| &#39;(&#39; expr &#39;)&#39;
</span></span><span class="line"><span class="cl">| ...
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>遇到 <code>1+2*5</code> 和 <code>1+1+1</code> 时，移入归约冲突，此时应该怎么选择，这就是优先级和结合性的作用。至于定义已经在<a href="#%e5%a3%b0%e6%98%8e%e8%bf%90%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7" rel="">声明运算符优先级</a>中介绍过了。</p>
<p>当然也可以使用优先级去解决悬空 else 问题。比如说，token ELSE 的优先级总是高于
token THEN，这样在悬空 else 问题上，每次都优先移入 else 而非归约。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%precedence THEN
</span></span><span class="line"><span class="cl">%precedence ELSE
</span></span></code></pre></td></tr></table>
</div>
</div><p>有个很奇怪的地方就是，往往优先级是上下文相关的。最直接的例子是一元 &lsquo;-&rsquo; (负号) 与二元 &lsquo;-&rsquo; (减号)，比如 C 语言的定义中，符号的优先级为 2 (越小越优先)，而乘号为 3，减号为 4。但是减号与负号的区别在于上下文的不同。另一个问题，Bison 中的优先级声明只能一 token 一次，这时就需要 <code>%prec</code> 修饰符在规则中进行修饰。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%prec TERMINAL-SYMBOL
</span></span></code></pre></td></tr></table>
</div>
</div><p>首先在规则中声明这个上下文相关的符号为一个不存在的 (虚构的) token type，在声明部分声明这个 token type 的优先级。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">%left &#39;+&#39; &#39;-&#39;
</span></span><span class="line"><span class="cl">%left &#39;*&#39;
</span></span><span class="line"><span class="cl">%right UMINUS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">expr:
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">| expr &#39;-&#39; expr
</span></span><span class="line"><span class="cl">| ...
</span></span><span class="line"><span class="cl">| &#39;-&#39; expr %prec UMINUS
</span></span><span class="line"><span class="cl">| ...
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="归约归约冲突" class="headerLink">
    <a href="#%e5%bd%92%e7%ba%a6%e5%bd%92%e7%ba%a6%e5%86%b2%e7%aa%81" class="header-mark"></a>归约归约冲突</h4><p>如果有多个规则可以应用咋同一个输入上，会发生归约归约冲突，通常这是严重的语法错误。比如下面这个示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty         { printf (&#34;empty sequence\n&#34;); }
</span></span><span class="line"><span class="cl">| maybeword
</span></span><span class="line"><span class="cl">| sequence word  { printf (&#34;added word %s\n&#34;, $2); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">maybeword:
</span></span><span class="line"><span class="cl">  %empty    { printf (&#34;empty maybeword\n&#34;); }
</span></span><span class="line"><span class="cl">| word      { printf (&#34;single word %s\n&#34;, $1); }
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如现在栈顶是 word，word 可以被归约为 maybeword，也可以被归约为 sequence。Bison
会选择首先出现在语法中的规则进行归约，但这可能超出编码预期，因此尽量不要依赖这种方式，而是选择消除所有的归约归约冲突。比如将 sequence 修改为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty         { printf (&#34;empty sequence\n&#34;); }
</span></span><span class="line"><span class="cl">| sequence word  { printf (&#34;added word %s\n&#34;, $2); }
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然有可能有其他方式产生归约归约冲突，比如下面这个例子。虽然每个规则独立看是没有问题的，但三个规则放在一起将产生错误：空输入可以被无限多种方式解析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| sequence words
</span></span><span class="line"><span class="cl">| sequence redirects
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">words:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| words word
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">redirects:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| redirects redirect
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>稍加修改，你会得到一个看起来不错的方法，空输入再也不会产生冲突了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| sequence words
</span></span><span class="line"><span class="cl">| sequence redirects
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">words:
</span></span><span class="line"><span class="cl">  word
</span></span><span class="line"><span class="cl">| words word
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">redirects:
</span></span><span class="line"><span class="cl">  redirect
</span></span><span class="line"><span class="cl">| redirects redirect
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是，如果输入为 &ldquo;word word&rdquo;，很明显可以被归约 <code>words words</code> 或 <code>words</code>，这有一个二义性的移入归约冲突，第二个 word 是移入还是将栈中的 word 归约。</p>
<p>可以用优先级解决这个问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%precedence &#34;word&#34;
</span></span><span class="line"><span class="cl">%precedence &#34;sequence&#34;
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| sequence word      %prec &#34;sequence&#34;
</span></span><span class="line"><span class="cl">| sequence redirect  %prec &#34;sequence&#34;
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">words:
</span></span><span class="line"><span class="cl">  word
</span></span><span class="line"><span class="cl">| words &#34;word&#34;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然结合性也能解决这个问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%right &#34;word&#34; &#34;redirect&#34;
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">sequence:
</span></span><span class="line"><span class="cl">  %empty
</span></span><span class="line"><span class="cl">| sequence word      %prec &#34;word&#34;
</span></span><span class="line"><span class="cl">| sequence redirect  %prec &#34;redirect&#34;
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="神秘冲突" class="headerLink">
    <a href="#%e7%a5%9e%e7%a7%98%e5%86%b2%e7%aa%81" class="header-mark"></a>神秘冲突</h4><p>有些归约归约冲突看起来根本没什么依据。这在 info 中称为 <code>神秘</code> (Mysterious) 冲突。比如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">def: param_spec return_spec &#39;,&#39;;
</span></span><span class="line"><span class="cl">param_spec:
</span></span><span class="line"><span class="cl">  type
</span></span><span class="line"><span class="cl">| name_list &#39;:&#39; type
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">return_spec:
</span></span><span class="line"><span class="cl">  type
</span></span><span class="line"><span class="cl">| name &#39;:&#39; type
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type: &#34;id&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">name: &#34;id&#34;;
</span></span><span class="line"><span class="cl">name_list:
</span></span><span class="line"><span class="cl">  name
</span></span><span class="line"><span class="cl">| name &#39;,&#39; name_list
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个文法是一个 LR(1) 文法，从 param_spec 开始，如果 id 后面是一个 &lsquo;:&rsquo; 或 &lsquo;,&rsquo; 它将被归约为 name，如果后面是一个 id 则被归约为 type。但是问题在于这不是一个
LALR(1) 文法，看起来 param_spec 和 return_spec 太像了，以至于 Bison 无法处理。</p>
<p>对于许多语法 (特别是非 LR(1) 语法)，LALR(1) 的局限性造成了各种问题，因此最直接的解决方法是构造不那么高效的规范 LR(1) 分析表或 IELR(1) 分析表。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">从 GNU Bison <strong>3.1</strong> 开始 LR(LR,LALR,IELR) 分析表不再是实验性功能</div>
        </div>
    </div>
<p>如果只用 LALR(1) 解决这个问题，你可以添加一些东西，让这两个生成体不那么相同。以此来解决这个问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">return_spec:
</span></span><span class="line"><span class="cl">  type
</span></span><span class="line"><span class="cl">| name &#39;:&#39; type
</span></span><span class="line"><span class="cl">| &#34;id&#34; &#34;bogus&#34;  /* This rule is never used. */
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><p>很明显，yylex 不能解析出一个 bogus 的 token。在这个示例中，更好的解决方法是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">return_spec:
</span></span><span class="line"><span class="cl">  type
</span></span><span class="line"><span class="cl">| &#34;id&#34; &#39;:&#39; type
</span></span><span class="line"><span class="cl">;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="调整-lr" class="headerLink">
    <a href="#%e8%b0%83%e6%95%b4-lr" class="header-mark"></a>调整 LR</h4><p>构造 LR 解析器是因为历史原因的选择，现代化的 Bison 给出了一些更好的选择。</p>
<!--list-separator-->
<ul>
<li>
<p>LR 表构建</p>
<p>只要修改一下下声明，就可以从历史遗留的 LALR(1) 分析表切换到 IELR 或 canonical LR
分析表。当然，主要是由于 LALR(1) 文法不够强大，不能完全解析 LR(1) 文法。有些需要复杂重构的 LALR 文法，或许在切换到 LR(1) 文法后，就可以完全消除冲突。</p>
<p>先说说怎么指定不同的分析表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define lr.type TYPE
</span></span></code></pre></td></tr></table>
</div>
</div><p>可选值如下</p>
<ul>
<li><code>lalr</code> (default)</li>
<li><code>ielr</code></li>
<li><code>canonical-lr</code></li>
</ul>
<p>当然每种 LR 分析表都有其特点，在龙书中也详细讲了 Canonical LR 与 LALR，至于 IELR
以后有机会好好学习一下。在通常情况下，IELR 都可以应对，但某些情况下 LALR 或规范
LR 可能会很有用。</p>
<p>LALR
: 至少这两种情况下非常推荐使用
-   没有静态解决冲突的 GLR。开始静态解决冲突时，GLR 的行为更像是确定性解析器。
-   格式错误的语法 (Malformed grammars)。在一些含有重大缺陷的复杂语法上，可能会阻碍 IELR 和 Canonical LR 构造算法。因此 LALR 分析表可以快速构造并检查错误，同时忽略 IELR 和 Canonical LR 的细微差别。</p>
<p>IELR
: 这是一种最小 LR 算法，给定任何语法，IELR 和 Canonical LR 解析器总是接受相同的集合。通常 IELR 比 Canonical LR 的状态少一个数量级，而冲突数量往往也少一个数量级。这可以显著降低语法开发的复杂性。</p>
<p>Canonical LR
: 在不使用 <code>%nonassoc</code> 和禁用默认归约行为时，规范 LR 可以尽快检测出语法错误，且不需要执行不必要的归约。但 IELR 在开启 <a href="#lac" rel="">LAC</a> 的情况下可以没有限制的实现此效果。</p>
<p>关于更多的 IELR 和 LALR 神秘冲突的内容，可以阅读 <a href="https://dl.acm.org/doi/10.1145/1363686.1363747" target="_blank" rel="noopener noreferrer">Denny 2008 March</a> 和 <a href="https://www.sciencedirect.com/science/article/pii/S0167642309001191" target="_blank" rel="noopener noreferrer">Denny 2010
November</a>。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>默认归约</p>
<p>在构建好分析表后，Bison 使用每个解析器中设置的最大向前看值来进行归约。为了减少状态大小，Bison 默认删除该值，并使用默认解析器进行归约操作。这种行为被称为默认归约。默认归约不仅影响分析表的大小，还影响解析器的行为：</p>
<ul>
<li>
<p>延迟调用 yylex</p>
<p><strong>一致状态</strong>是只有一个可能的解析器操作。如果操作是归约且它被编码为默认归约，那么一致状态被称作<strong>默认状态</strong>。达到默认状态后，Bison 不会在执行归约操作之前调用 yylex。即当它在输入中达到该 token 时，或它需要前前看来决定下一个操作，此时调用 yylex。但默认开启默认归约时，将会改变解析器行为。yylex 的行为可能影响或受默认归约的影响。</p>
</li>
<li>
<p>延迟检测语法错误</p>
<p>当解析器获取新 token 时，会检查当前状态下是否有关于该 token 的操作。当且仅当</p>
<ol>
<li>没有操作</li>
<li>操作时错误操作</li>
</ol>
<p>这时才会检测到语法错误。但启用默认归约时，条件一将不成立，因为每个 token 都有归约操作。解析器将不能直接检测出语法错误，而是会在之后的状态中检测到。</p>
<p>虽然默认归约不会导致解析器接受含有错误语法的输入，但延迟检测语法可能导致意料之外的行为。另外延迟检测可能是由解析器合并，和使用 <code>%nonassoc</code> 引起的，这可以通过 <a href="#lac" rel="">LAC</a> 进行修复。</p>
</li>
</ul>
<p>对于 Canonical LR，唯一开启默认归约的状态是接受状态，但是这不会引起上述的两个延迟问题 (毕竟直接结束了，不再需要检测错误或找下一个 token 了)。</p>
<p>对于 IELR 和 LALR，默认对所有状态启用默认归约。除了</p>
<ul>
<li>对<code>错误</code> token 只有移入没有归约</li>
<li>GLR 解析器不会为存在冲突的向前看 token 设置默认规约</li>
</ul>
<p>如果想修改 Bison 的默认行为，可以声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define lr.default-reduction WHERE
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>most (default for LALR and IELR)</li>
<li>consistent</li>
<li>accepting (default for canonical LR)</li>
</ul>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>LAC</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><pre><code>从 GNU Bison **3.5** 开始 lookahead correction (C++) 不再是实验性功能

从 GNU Bison **3.8** 开始 lookahead correction (Java) 不再是实验性功能
</code></pre>
</div>
        </div>
    </div>
<p>解析器在发现语法错误前可能进行额外的规约，这些规约可能执行不符合预期的语义操作，并且可能导致错误恢复发生在其他文法上下文中。这个问题的根源通常是 <code>%nonassoc</code>、不一致状态下的默认规约以及 GLR 解析器合并。因此主要影响的是 IELR 和 LALR 解析器。</p>
<p>LAC (前瞻校正) 是一种解析的新机制，可以在不牺牲 <code>%nonassoc</code> 和默认规约或状态合并的功能的前提下，解决这个问题。只需要定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define parse.lac VALUE
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>none (default)</li>
<li>full</li>
</ul>
<p>使用 LAC 时需要考虑一些注意事项：</p>
<ul>
<li>
<p>无限的解析循环</p>
<p>IELR + LAC 的组合相对 Canonical LR 有一个缺点，即 Bison 可能生成一个无限循环的解析器，LAC 不会修复在遇到语法错误和检测到它之间发生的无限循环。</p>
</li>
<li>
<p>详细错误消息限制</p>
<p>一些 i18n 方面的考虑，Bison 限制了在错误消息中报告 token 列表的大小。超出限制时会简单的删除。但 LAC 会增加列表的大小。</p>
</li>
<li>
<p>性能</p>
<p>LAC 需要两次执行多解析行为，因此可能造成性能降低。但也不是所有解析操作都要执行两次。对于解析来说，最耗时的往往是文件 IO、词法分析器以及用户的语义行为，但这些不是在探索性解析期间执行的。并且探索性解析的堆栈直接指向正式堆栈，从而不会造成复制。因此，从经验来看，LAC 的性能损耗可以忽略不计。</p>
</li>
</ul>
<p>对于 LAC 的更多内容，可以查看 <a href="https://tigerprints.clemson.edu/all_dissertations/519/" target="_blank" rel="noopener noreferrer">Denny 2010 May</a>。</p>
</li>
</ul>
<!--list-separator-->
<ul>
<li>
<p>不可达状态</p>
<p>如果不存在从解析器的起始状态到某个状态 S 的转换序列，则 Bison 认为 S 是<strong>不可达状态</strong>。如果 Bison 禁用从前一个状态到该状态的转换操作，则该状态可能在冲突解决期间变得无法访问。</p>
<p>默认情况下，Bison 会在冲突解决后从解析器中删除无法访问的状态，因为它们在生成的解析器中是无用的。然而，当试图理解解析器和语法之间的关系时，保留不可达状态有时很有用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%define lr.keep-unreachable-state VALUE  // false (defaule) or true
</span></span></code></pre></td></tr></table>
</div>
</div><p>但需要考虑一下问题：</p>
<ul>
<li>
<p>缺少或无关的警告</p>
<p>不可达状态可能包含冲突，且可能使用在任何其他状态中未使用的规则。因此保留不可打状态可能引起解析器行为无关的警告，并可能消除相关警告。</p>
</li>
<li>
<p>其他无用的状态</p>
<p>虽然 Bison 能够移除无法到达的状态，但不能保证移除其他类型的无用状态。举例就是，当 Bison 在冲突解决期间禁用规约操作时，一些 goto 操作可能变得无用，因此一些附加状态可能变得无用。如果 Bison 要计算哪些 goto 操作是无用的，然后禁用这些操作，它可以将这些状态识别为不可达，然后删除这些状态。但是，Bison 不会计算哪些 goto 操作是无用的。</p>
</li>
</ul>
</li>
</ul>
<h2 id="main-函数示例" class="headerLink">
    <a href="#main-%e5%87%bd%e6%95%b0%e7%a4%ba%e4%be%8b" class="header-mark"></a>main 函数示例</h2><div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">本节学习自 <a href="https://pku-minic.github.io/online-doc" target="_blank" rel="noopener noreferrer">北大编译实践</a></div>
        </div>
    </div>
<p>sysy 采用扩展 Backus 范式 (EBNF)，CompUnit 作为开始符号。当然除了函数定义还有变量声明，但是现在我们跟着北大编译实践来学习，目前只处理 main 函数</p>
<div class="verse">
<p>CompUnit ::= FuncDef;<br />
<br />
FuncDef  ::= FuncType <strong>Ident</strong> &lsquo;(&rsquo; &lsquo;)&rsquo; Block;<br />
FuncType ::= <strong>int</strong>;<br />
<br />
Block    ::= &lsquo;{&rsquo; Stmt &lsquo;}&rsquo;;<br />
Stmt     ::= <strong>return</strong> Number &lsquo;;&rsquo; ;<br />
Number   ::= INT_CONST;<br /></p>
</div>
<p>根据这个我们先写一个 flex 词法分析文件 <code>sysy.l</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%option noyywrap nodefault noinput nounput noyy_top_state stack
</span></span><span class="line"><span class="cl">%top{
</span></span><span class="line"><span class="cl">#include &#34;sysy.tab.hh&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;stdlib.h&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#include &lt;string&gt;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">WhiteSpace     [[:space:]]*
</span></span><span class="line"><span class="cl">LineComment    &#34;//&#34;.*$
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Identifier     [[:alpha:]_][[:alnum:]_]*
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Decimal        [1-9][[:digit:]]*
</span></span><span class="line"><span class="cl">Octal          0[0-7]*
</span></span><span class="line"><span class="cl">Hexadecimal    0[xX][[:xdigit:]]+
</span></span><span class="line"><span class="cl">Binarydecimal  0[bB][01]+
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%x COMMENT
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{LineComment}    { /* ignore */ }
</span></span><span class="line"><span class="cl">&#34;/*&#34;             { yy_push_state(COMMENT); }
</span></span><span class="line"><span class="cl">&lt;COMMENT&gt;.|\n    { /* ignore */ }
</span></span><span class="line"><span class="cl">&lt;COMMENT&gt;&#34;*/&#34;    { yy_pop_state(); }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{WhiteSpace}     { /* ignore */ }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34;int&#34;            { return INT; }
</span></span><span class="line"><span class="cl">&#34;return&#34;         { return RETURN; }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Identifier}     { yylval.ident = new ::std::string(yytext); return IDENTIFIER; }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">{Decimal}        { yylval.int_val = strtol(yytext, nullptr, 10); return INT_CONST; }
</span></span><span class="line"><span class="cl">{Octal}          { yylval.int_val = strtol(yytext, nullptr, 8); return INT_CONST; }
</span></span><span class="line"><span class="cl">{Hexadecimal}    { yylval.int_val = strtol(yytext, nullptr, 16); return INT_CONST; }
</span></span><span class="line"><span class="cl">{Binarydecimal}  { yylval.int_val = strtol(yytext + 2, nullptr, 2); return INT_CONST; }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">.                { return yytext[0]; }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span></code></pre></td></tr></table>
</div>
</div><p>简单解释一下，词法分析器将忽略所有的行注释、块注释以及空白符，并且会将得到的标识符名称存入 <code>idnet</code> 中，解析到的整型变量存入 <code>int_val</code> 中。</p>
<p>既然有了词法分析器，我们还需要在在语法分析器中描述 sysy 的语法，即 <code>sysy.y</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">%code requires {
</span></span><span class="line"><span class="cl">#include &lt;memory&gt;
</span></span><span class="line"><span class="cl">#include &lt;string&gt;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%code {
</span></span><span class="line"><span class="cl">#include &lt;iostream&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">extern int yylex(void);
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void yyerror(::std::unique_ptr&lt;::std::string const&gt; &amp;ast, char const *s);
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%parse-param { ::std::unique_ptr&lt;::std::string const&gt; &amp;ast }
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%union {
</span></span><span class="line"><span class="cl">  ::std::string const *ident;
</span></span><span class="line"><span class="cl">  int int_val;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%token INT RETURN
</span></span><span class="line"><span class="cl">%token &lt;ident&gt; IDENTIFIER
</span></span><span class="line"><span class="cl">%token &lt;int_val&gt; INT_CONST
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%type &lt;ident&gt; FuncDef FuncType Block Stmt Number CompUnit
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">CompUnit:
</span></span><span class="line"><span class="cl">  FuncDef {
</span></span><span class="line"><span class="cl">      ast = ::std::unique_ptr&lt;::std::string const&gt;($1);
</span></span><span class="line"><span class="cl">      }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FuncDef:
</span></span><span class="line"><span class="cl">  FuncType IDENTIFIER &#39;(&#39; &#39;)&#39; Block {
</span></span><span class="line"><span class="cl">    auto type = ::std::unique_ptr&lt;::std::string const&gt;($1);
</span></span><span class="line"><span class="cl">    auto ident = ::std::unique_ptr&lt;::std::string const&gt;($2);
</span></span><span class="line"><span class="cl">    auto block = ::std::unique_ptr&lt;::std::string const&gt;($5);
</span></span><span class="line"><span class="cl">    $$ = new ::std::string(*type + &#34; &#34; + *ident + &#34;()&#34; + *block);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">FuncType:
</span></span><span class="line"><span class="cl">  INT { $$ = new ::std::string(&#34;int&#34;); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Block:
</span></span><span class="line"><span class="cl">  &#39;{&#39; Stmt &#39;}&#39; {
</span></span><span class="line"><span class="cl">    auto stmt = ::std::unique_ptr&lt;::std::string const&gt;($2);
</span></span><span class="line"><span class="cl">    $$ = new ::std::string(&#34;{ &#34; + *stmt + &#34; }&#34;);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Stmt:
</span></span><span class="line"><span class="cl">  RETURN Number &#39;;&#39; {
</span></span><span class="line"><span class="cl">    auto number = ::std::unique_ptr&lt;::std::string const&gt;($2);
</span></span><span class="line"><span class="cl">    $$ = new ::std::string(&#34;return &#34; + *number + &#34;;&#34;);
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Number:
</span></span><span class="line"><span class="cl">  INT_CONST { $$ = new ::std::string(::std::to_string($1)); }
</span></span><span class="line"><span class="cl">;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">%%
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">void yyerror(::std::unique_ptr&lt;::std::string const&gt; &amp;ast, const char *s) {
</span></span><span class="line"><span class="cl">  ::std::cerr &lt;&lt; &#34;error: &#34; &lt;&lt; s &lt;&lt; ::std::endl;
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>很明显语法分析器中，这个语法分析可以很好得解析我们在本节开始声明的 EBNF 文法，也就是 main 函数。需要注意的是，这里不能使用 <code>::std::make_unique</code>，因为其只能移动或者从参数构建智能指针，但我们的非终结符语义值都是用 <code>new</code> 构建好的指针 (非 POD
类型不能作为 union 成员)，因此我们需要用构造函数来构造 <code>::std::unique_ptr</code>，将之前构造的指针所有权移交给智能指针。</p>
<p>虽然词法分析与语法分析出来了，我们还要自己编写一个主文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">yyin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">yylex_destroy</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">yyparse</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ast</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="cm">/* argc */</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">input</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">yyin</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ast</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">yyparse</span><span class="p">(</span><span class="n">ast</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ast</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">fclose</span><span class="p">(</span><span class="n">yyin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">yylex_destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>主文件需要注意，在最后关闭 yyin 是必要操作，不然会造成资源泄漏 (虽然程序立即结束，操作系统会回收资源)。还有就是 <code>yylex_destroy</code> 必须在 <code>fclose</code> 之后关闭，否则会造成 crash。如果有兴趣可以自己写一个 deferer，然后做 RAII，保证资源的正确释放。</p>
<p>最后，写一个 CMake 就大功告成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.5</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">sysyc</span> <span class="s">LANGUAGES</span> <span class="s">CXX</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">17</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="s">ON</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_EXTENSIONS</span> <span class="s">OFF</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="s">CMAKE_BUILD_TYPE</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_BUILD_TYPE</span> <span class="s2">&#34;Debug&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_EXPORT_COMPILE_COMMANDS</span> <span class="s">ON</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">find_package</span><span class="p">(</span><span class="s">FLEX</span> <span class="s">REQUIRED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">find_package</span><span class="p">(</span><span class="s">BISON</span> <span class="s">REQUIRED</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB_RECURSE</span> <span class="s">L_SOURCES</span> <span class="s2">&#34;src/*.l&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">file</span><span class="p">(</span><span class="s">GLOB_RECURSE</span> <span class="s">Y_SOURCES</span> <span class="s2">&#34;src/*.y&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">if</span><span class="p">(</span><span class="s">NOT</span> <span class="p">(</span><span class="s">L_SOURCES</span> <span class="s">STREQUAL</span> <span class="s2">&#34;&#34;</span> <span class="s">AND</span> <span class="s">Y_SOURCES</span> <span class="s">STREQUAL</span> <span class="s2">&#34;&#34;</span><span class="p">))</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">string</span><span class="p">(</span><span class="s">REGEX</span> <span class="s">REPLACE</span> <span class="s2">&#34;.*/(.*)\\.l&#34;</span> <span class="s2">&#34;${CMAKE_CURRENT_BINARY_DIR}/\\1.lex.cc&#34;</span> <span class="s">L_OUTPUTS</span> <span class="s2">&#34;${L_SOURCES}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">string</span><span class="p">(</span><span class="s">REGEX</span> <span class="s">REPLACE</span> <span class="s2">&#34;.*/(.*)\\.y&#34;</span> <span class="s2">&#34;${CMAKE_CURRENT_BINARY_DIR}/\\1.tab.cc&#34;</span> <span class="s">Y_OUTPUTS</span> <span class="s2">&#34;${Y_SOURCES}&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">flex_target</span><span class="p">(</span><span class="s">Lexer</span> <span class="o">${</span><span class="nv">L_SOURCES</span><span class="o">}</span> <span class="o">${</span><span class="nv">L_OUTPUTS</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">bison_target</span><span class="p">(</span><span class="s">Parser</span> <span class="o">${</span><span class="nv">Y_SOURCES</span><span class="o">}</span> <span class="o">${</span><span class="nv">Y_OUTPUTS</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="nb">add_flex_bison_dependency</span><span class="p">(</span><span class="s">Lexer</span> <span class="s">Parser</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">${</span><span class="nv">FLEX_Lexer_OUTPUTS</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">${</span><span class="nv">BISON_Parser_OUTPUT_SOURCE</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/main.cc</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span>
</span></span><span class="line"><span class="cl">  <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/include</span>
</span></span><span class="line"><span class="cl">  <span class="o">${</span><span class="nv">CMAKE_CURRENT_BINARY_DIR</span><span class="o">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">target_sources</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="s">PRIVATE</span>
</span></span><span class="line"><span class="cl">  <span class="p">)</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>非常完美，我们编写了一个能解析主函数的最简单的编译器，并且没有任何资源泄漏。现在让我们从编译到运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cmake -S. -Bcmake_build_debug -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> cmake_build_debug/ <span class="o">&amp;&amp;</span> make -j
</span></span><span class="line"><span class="cl">./sysyc main.sy
</span></span></code></pre></td></tr></table>
</div>
</div></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 05-22</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/2022/flex_and_bison/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span><span>|&nbsp;<a class="link-to-report" href=https://gitlab.com/GinShio/ginshio.gitlab.io/issues/new?issue[title]=[BUG]%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6+Flex+%E5%8F%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6+Bison+%E7%9A%84%E7%94%A8%E6%B3%95&issue[description]=[POST](https://blog.ginshio.org/2022/flex_and_bison/)%0A%0A##%20Isseus%0A target="_blank" rel="noopener noreferrer">报告问题</a>
                    </span></div>
            <div class="post-info-share">
                <span><a href="#" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法" data-hashtags="Applications,SyntacticAnalysis,LexicalAnalysis"><i class="fab fa-twitter fa-fw"></i></a><a href="#" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-hashtag="Applications"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2022/flex_and_bison/"><i class="fab fa-linkedin fa-fw"></i></a><a href="#" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="#" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" title="分享到 Telegram" data-sharer="telegram" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法" data-web><i class="fab fa-telegram-plane fa-fw"></i></a><a href="#" class="weixin" title="分享到 微信" data-sharer="weixin" data-url="https://blog.ginshio.org/2022/flex_and_bison/" data-title="词法分析软件 Flex 及语法分析软件 Bison 的用法" data-web><i class="fab fa-weixin fa-fw"></i><img src="https://api.oick.cn/qrcode/api.php?size=256&amp;text=https://blog.ginshio.org/2022/flex_and_bison/" title="词法分析软件 Flex 及语法分析软件 Bison 的用法">
    </a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/applications/">Applications</a>,&nbsp;<a href="/tags/syntacticanalysis/">SyntacticAnalysis</a>,&nbsp;<a href="/tags/lexicalanalysis/">LexicalAnalysis</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2022/compilerprinciple_006/" class="prev" rel="prev" title="语法分析 3"><i class="fas fa-angle-left fa-fw"></i>语法分析 3</a>
            <a href="/2022/compilerprinciple_007/" class="next" rel="next" title="语法制导翻译">语法制导翻译<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.115.4">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank" rel="noopener noreferrer"> </a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.b250718923eb2b3c2ba2de589fcc7f623ebf3efa17f0e501e7de204156024b108524ffafaf0958fd09d3b68cf0412999.css" integrity="sha384-slBxiSPrKzwrot5Yn8x/Yj6/PvoX8OUB594gQVYCSxCFJP&#43;vrwlY/QnTtozwQSmZ"><link rel="stylesheet" href="/lib/katex/katex.min.bcaaee8fe6b5dd4f321c8900c8680ad49dc0ad32f3ac51816c1734b43a7869dfc4c9ec0449e5c4fc8bfaec08fc80a674.css" integrity="sha384-vKruj&#43;a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"96cbbb15f26bebd9141b","clientSecret":"29c7df99d6e1806113996333163a9476027ff1fa","id":"2022-05-01T15:29:43+08:00","owner":"GinShio","repo":"ginshio.github.io","title":"词法分析软件 Flex 及语法分析软件 Bison 的用法"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"ABF13CGNA0","algoliaIndex":"ginshio_blog","algoliaSearchKey":"51cf3425aba132c091b477c3d5e06eea","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"sharerjs":true,"table":{"sort":true}};</script><script type="text/javascript" src="/lib/gitalk/gitalk.min.1420a0c0459673bc6824e7ba713f1e0ec1540e86491daf1b6149a7af9cd3f396c86b9182d03e4c727faefae17b746033.js" integrity="sha384-FCCgwEWWc7xoJOe6cT8eDsFUDoZJHa8bYUmnr5zT85bIa5GC0D5Mcn&#43;u&#43;uF7dGAz"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.d120034e53740430f5243f8e25b646e7bdcca97780e02962c37e3adefb264c1b457f8fc397698851f42e32d7168bdd1e.js" integrity="sha384-0SADTlN0BDD1JD&#43;OJbZG573MqXeA4Cliw3463vsmTBtFf4/Dl2mIUfQuMtcWi90e"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/katex/katex.min.3f04544ff62a6e71239193b4cd9c4da9cc400ab5defa3efae94d9a997720320e78e7baef7b663b23a6494a6d80d264b8.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe&#43;j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f95071777afa5e0511c9caad675d7b9d8c38e0e39c21ac79e99e1d09159bc723edd0aa1a875b87a0ad28e3efd1444d39.js" integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.c30ff9f376878715a4cf90c4567e8e2ad36221a2e2da20513595df251898d408bbb6727d517a44b32bce2135694e5e00.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.453374f1ad005c88a83c1715a2c12a3d47ca2beacfa7e875c7f8b347bc4c91d332bb091c64259dc4ef914b0205b495cd.js" integrity="sha384-RTN08a0AXIioPBcVosEqPUfKK&#43;rPp&#43;h1x/izR7xMkdMyuwkcZCWdxO&#43;RSwIFtJXN" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-J5NHMZLLDX', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-J5NHMZLLDX" async></script><script>
			var _hmt = _hmt || [];
			(function() {
			  var hm = document.createElement("script");
			  hm.src = "https://hm.baidu.com/hm.js?9370523af547bac6b97e9c3b1461cd16";
			  var s = document.getElementsByTagName("script")[0]; 
			  s.parentNode.insertBefore(hm, s);
			})();
		</script></div>
</body>

</html>