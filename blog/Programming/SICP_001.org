#+hugo_categories: Programming
#+hugo_tags: Note SICP
#+hugo_draft: true
#+hugo_locale: zh
#+hugo_lastmod: 2020-11-07T15:05:00+08:00
#+hugo_auto_set_lastmod: nil
#+hugo_front_matter_key_replace: author>authors
#+hugo_custom_front_matter: :series ["SICP Note"] :series_weight 1
#+title: 构造过程抽象
#+author: GinShio
#+date: 2020-11-07T15:05:00+08:00
#+email: ginshio78@gmail.com
#+description: GinShio | SICP 第一章读书笔记
#+keywords: Programming Note SICP
#+export_file_name: SICP_001.zh-cn.txt


#+begin_quote
心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：

  1. 将若干简单认识组合为一个复杂认识，由此产生出各种复杂认识
  2. 将两个认识放在一起对照，不管它们如何简单或复杂，在这样做时并不将它们合二为
     一。由此得到有关它们相互关系的认识
  3. 将有关认识与那些实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有
     普遍性的认识都是这样得到的
#+end_quote

我们准备学习的是有关 *计算过程* 的认识。计算过程是存在于计算机里的一类抽象事物，
在其演化进程中，这些过程会去操作一些被成为 *数据* 的抽象事物。人们创造出一些名为
*程序* 的规则模式，以指导这类过程的进行。



* 程序设计的基本元素
一个强有力的程序设计语言不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，
使我们能够在其中组织自己有关计算过程的思维。当我们描述这个语言时，我们应该注意该
语言提供的，将简单思维组合成复杂思维的方式。为此提供了三种机制:
  - *基本表达形式*​：用于表示语言所关心的最简单的个体
  - *组合的方法*​：将较简单的元素构造为复杂元素
  - *抽象的方法*​：为复杂对象命名，将它们当作单元操作

数据是我们希望去操作的内容，过程是对操作这些数据的规则的描述，任何强有力的程序设
计语言都必须能表述基本的数据与基本的过程，还需要提供对过程和数据进行 ~组合~ 和
~抽象~ 的方法。

** 过程作为黑箱
我们将一个问题自然的分解为若干子问题，这些子问题每一个都通过独立的过程完成，它们
直接反映了原问题到子问题的分解。我们不需要关注子过程是如何实现计算过程的，将它看
作一个 *黑箱*​，只需要主要它最终可以完成原问题即可。

#+begin_src scheme
(define (square x) (* x x))
(define (square x)
  (exp (double (log x))))
(define (double x) (+ x x))
#+end_src

以上这两个 =square= 过程，当我们只考虑返回值，那么它们是不可区分的。由此可见，一
个过程应该能藏起一些细节，这将使过程的使用者不必自己去实现这些过程或弄清如何实现
过程，作为一个黑箱而接受它。

形式参数的名称是用户不必关心的细节之一，形式参数的具体名称是什么完全不重要，它们
也被成为 *约束变量*​，过程的定义不受约束变量名称的改变而改变，约束变量被定义的那
些表达式的集合称作 *作用域*​。

定义一个计算平方根的过程我们可能需要定义不同的子过程，最终将子过程组合起来完成最
终问题的求解。在一个相当大的系统中，我们可能需要定义一系列子过程，这些子过程的名
称可能发生冲突，我们希望将这些子过程局部化，将他们隐藏到主过程中。这种嵌套的定义
称为 *块结构*​，是最简单的一种解决冲突的方法。

#+begin_src scheme
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.000000000001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
#+end_src

可以发现，将过程定义在内部，因为x在sqrt的定义中是受约束的，其他过程也定义在sqrt
中，即x的作用域中，它们都可以直接使用x，这被称为 *词法作用域*​。



* 过程与它们所产生的计算
** 线性的递归和迭代
考虑阶乘的计算 $n! = n \cdot [(n - 1) \cdot (n - 2) \cdots 3 \cdot 2 \cdot 1] = n \cdot (n - 1)!$​，我们
可以翻译成以下过程
#+begin_src scheme
(define (factorial n)
  (if (or (= n 1) (= n 0))
      1
      (* n (factorial (- n 1)))))
#+end_src

这个计算过程中，通过代换模型可以看出计算是一种先逐步展开而后收缩的形状，计算过程
构造起一个 ~推迟进行的操作~ 所形成的链条，收缩阶段表现为这些运算的实际执行，这种
计算过程被称为 *递归计算过程*​。如果要执行这个过程，解释器就必须维护好以后要执行
的操作的轨迹，这个例子中推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息
量，这个长度随着n值的增加而线性增长，这个过程被称为 *线性递归计算*​。

#+begin_src scheme
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (fact-iter (* counter product) (+ counter 1) n)))
  (iter 1 1))
#+end_src

这个计算过程中没有任何增长或收缩，计算过程的每一步，需要保存的轨迹就是变量
~product~ 和 ~counter~ 的当前值，我们称这个过程为 *迭代计算过程*​。迭代计算过程
就是那种其状态可以用固定数目的状态变量描述的计算过程，同时又存在一套固定的规则描
述了计算过程从一个状态到另一个状态转换时状态变量的更新方式，还有一个结束状态的检
测用以描述计算过程如何终止。计算阶乘的这一计算过程中，所需计算步骤随着n增长而线
性增长，这个过程被称为 *线性迭代计算*​。

** 树形递归
树形递归是另一种常见的计算模式，斐波那契数列就是如此计算模式，每个fibonacci调用
中会有两次递归调用。
#+begin_src scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+end_src

[[file:../images/sicp-fibonacci-recursion.png]]

由于这种计算斐波那契数列的方法很糟糕，做了很多冗余计算，其递归次数跟随n的大小指
数增加，因此我们需要使用迭代的方法来优化这个求解过程
#+begin_src scheme
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (fib-iter 1 0 n))
#+end_src

树形递归计算过程并不是无用的，当考虑在层次结构性的数据上操作，而不是对数操作时，
树形递归计算过程是一种自然、威力强大的工具，可以帮助我们理解与设计程序。

** 增长的阶
不同的计算过程在消耗计算资源的速率上可能存在巨大差异，描述这种差异的方式采用 ~增
长的阶~​，以便对某一计算过程所需资源进行粗略度量。

另 n 是一个参数，它作为问题规模的一种度量，令 $R(n)$ 是一个计算过程在处理规模为n
的问题时所需要的资源量。我们称 $R(n)$ 具有 $\Theta(f(n))$ 的增长阶，记作 $R(n) =
\Theta(f(n))$ ，读作 *f(n)的theta*



* 用高阶函数做抽象
通过以上的学习，我们了解到，过程也是一类抽象，它们描述了一些对于数的复合操作，但
又不依赖与特定的数。人们总是对功能强大的程序设计语言有一个必然要求，即能为公共的
模块命名，建立抽象，然后直接在抽象的层次上工作。这就是为什么大部分程序设计语言都
包含定义过程的机制的原因。

即使在数值计算过程中，如果将过程限制为只能以数作为参数，那也将严重影响我们建立抽
象的能力。我们有时需要构造出以过程为参数，或以过程为返回值的过程，这类能操作过程
的过程称为 *高阶过程*​。

lambda方法可以使我们在需要的时候简便的创建出一个方法，而不用关系方法的名称。像任
何以过程为值的表达式一样，lambda表达式可用作组合式的运算符，或者更一般的，可以用
在任何通常使用过程名的上下文中。
#+begin_src scheme
((lambda (x y z) (+ x y (* z z))) 1 2 3)
#+end_src

高阶过程的重要性，就在于使我们能显示地用程序设计语言的要素去描述这些抽象，使我们
能像操作其他计算元素一样去操作它们。一般而言，程序设计语言总会对计算元素的可能使
用方式强加上某些限制，带上最少限制的元素被称为 *第一级* 的状态，第一级元素的某些
特权包括:
  - 可以使用变量命名
  - 可以提供给过程作为参数
  - 可以由过程作为结果返回
  - 可以包含在数据结构中
