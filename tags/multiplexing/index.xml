<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Multiplexing - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/multiplexing/</link>
        <description>Multiplexing - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/multiplexing/" rel="self" type="application/rss+xml" /><item>
    <title>I/O 复用</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</link>
    <pubDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</guid>
    <description><![CDATA[<p>在客户端阻塞在 read 等待用户输入时，服务器关闭会导致向客户端发送 FIN，这是客户端的另一个输入。但由于客户端阻塞在 read 从而无法立即接受这个输入，直到从套接字读入为止。这就需要进程提前告知内核，使得内核在进程指定的输入准备好后，或可以输出后，立即通知进程，这个能力被称为 I/O 复用 (I/O multiplexing)。</p>
<p>I/O 复用有多个 syscall 可以实现，Unix 古老的函数 select 与 poll，POSIX 有一个比较新的变种为 pselect，而 Linux 与 freeBSD 独立发展出了 <strong>epoll</strong> 与 <strong>kqueue</strong>。</p>
<p>I/O 复用典型适用于以下场合：</p>
<ul>
<li>当客户处理多个描述符时</li>
<li>客户同时处理多个套接字时，不过这种场景比较少见</li>
<li>如果 TCP 服务器既要监听套接字，又要处理已连接的套接字</li>
<li>如果一个服务器既要处理 TCP 又要处理 UDP，或同时处理多个不同协议，或多个服务</li>
</ul>
<p>需要注意的是，并非只有网络编程需要用到 I/O 复用，I/O 复用是对文件描述符状态的监听，因此其他场景下也有其适用的空间。</p>
<h2 id="i-o-模型" class="headerLink">
    <a href="#i-o-%e6%a8%a1%e5%9e%8b" class="header-mark"></a>I/O 模型</h2><p>在 Unix 系统上，一个输入操作通常包含两个不同的阶段</p>
<ol>
<li>数据准备完成</li>
<li>从内核向进程复制数据</li>
</ol>
<p>在等待数据准备到复制数据的过程，根据行为的不同，I/O 模型主要分为以下几种</p>
<ul>
<li>
<p><strong>blocking I/O</strong> (阻塞式 I/O)</p>
<p>阻塞式 I/O 模型是最常见、最简单、最好理解的 I/O 模型，目前为止所有的套接字函数都是阻塞式 I/O，另外 C 标准库所提供的 I/O 也是阻塞式 I/O，这样的模型符合初学函数时提及的运行流程。</p>
<figure>
    </figure>

<p>在 recvfrom 这个示例中，只有数据报到达且复制到进程缓冲区中或错误发生才返回，而这段时间内进程是被阻塞的，不再向下运行代码。</p>
</li>
<li>
<p><strong>nonblocking I/O</strong> (非阻塞式 I/O)</p>]]></description>
</item></channel>
</rss>
