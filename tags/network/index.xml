<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Network - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/network/</link>
        <description>Network - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/network/" rel="self" type="application/rss+xml" /><item>
    <title>I/O 复用</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</link>
    <pubDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</guid>
    <description><![CDATA[在客户端阻塞在 read 等待用户输入时，服务器关闭会导致向客户端发送 FIN，这是客户端的另一个输入。但由于客户端阻塞在 read 从而无法立即接受这个输入，直到从套接字读入为止。这就需要进程提前告知内核，使得内核在进程指定的输入准备好后，或可以输出后，立即通知进程，这个能力被称为 I/O 复用 (I/O multiplexing)。
I/O 复用有多个 syscall 可以实现，Unix 古老的函数 select 与 poll，POSIX 有一个比较新的变种为 pselect，而 Linux 与 freeBSD 独立发展出了 epoll 与 kqueue。
I/O 复用典型适用于以下场合：
当客户处理多个描述符时 客户同时处理多个套接字时，不过这种场景比较少见 如果 TCP 服务器既要监听套接字，又要处理已连接的套接字 如果一个服务器既要处理 TCP 又要处理 UDP，或同时处理多个不同协议，或多个服务 需要注意的是，并非只有网络编程需要用到 I/O 复用，I/O 复用是对文件描述符状态的监听，因此其他场景下也有其适用的空间。
I/O 模型在 Unix 系统上，一个输入操作通常包含两个不同的阶段
数据准备完成 从内核向进程复制数据 在等待数据准备到复制数据的过程，根据行为的不同，I/O 模型主要分为以下几种
blocking I/O (阻塞式 I/O)
阻塞式 I/O 模型是最常见、最简单、最好理解的 I/O 模型，目前为止所有的套接字函数都是阻塞式 I/O，另外 C 标准库所提供的 I/O 也是阻塞式 I/O，这样的模型符合初学函数时提及的运行流程。
在 recvfrom 这个示例中，只有数据报到达且复制到进程缓冲区中或错误发生才返回，而这段时间内进程是被阻塞的，不再向下运行代码。
nonblocking I/O (非阻塞式 I/O)]]></description>
</item><item>
    <title>基本 TCP 编程</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_004/</link>
    <pubDate>Sat, 19 Feb 2022 15:31:05 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_004/</guid>
    <description><![CDATA[基本 TCP 套接字函数 socket 函数在网络编程中第一步往往调用 socket 函数，以指定通讯协议的详情。
1 2 3 // sys/socket.h int socket(int domain, int type, int protocol); // return socket fd, or -1 and set errno on error domain 指协议族，type 是套接字类型，protocol 参数应该设置为某个协议类型常量，或者为 0 表示对 domain 与 type 的系统默认值。
domain AF_INET: IPv4 协议 AF_INET6: IPv6 协议 AF_UNIX or AF_LOCAL: Unix Domain Socket AF_ROUTE: 路由套接字 AF_KEY: 密钥套接字 type SOCK_STREAM: 字节流套接字 SOCK_DGRAM: 数据报套接字 SOCK_SEQPACKET: 有序分组套接字 SOCK_RAW: 原始套接字 protocol (for IPv4 and IPv6) IPPROTO_TCP IPPROTO_UDP IPPROTO_SCTP 需要注意的是，不是所有的组合都是有效的，下表总结了有效的 socket 函数参数组合，空白意味着无效。]]></description>
</item><item>
    <title>Unix 套接字 API</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_003/</link>
    <pubDate>Thu, 17 Feb 2022 14:28:37 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_003/</guid>
    <description><![CDATA[套接字地址数据结构套接字函数基本都需要一个指向套接字地址结构的指针作为参数，每个协议族都有自己的套接字定义，均以 sockaddr_ 开头，并有协议族的唯一后缀。
IPv4 套接字地址结构IPv4 套接字地址结构通常称之为 互联网套接字结构 (Internet socket address structure)，结构体 sockaddr_in，定义于 &lt;netinet/in.h&gt; 中 (POSIX)。
1 2 3 4 5 6 7 8 9 10 struct in_addr { in_addr_t s_addr; // 32 bit IPv4 地址 (网络序) }; struct sockaddr_in { uint8_t sin_len; // 结构体大小 sa_family_t sin_family; // AF_INET in_port_t sin_port; // 16 bit 传输层端口号 (网络序) struct in_addr sin_addr; char sin_zero[8]; // unused }; 需要注意几点：
长度字段 sin_len 是为了增加对 OSI 协议的支持而在 4.]]></description>
</item><item>
    <title>传输层总述</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_002/</link>
    <pubDate>Tue, 18 Jan 2022 19:55:40 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_002/</guid>
    <description><![CDATA[在传输层中，主要学习三种协议
User Datagram Protocol (UDP, 用户数据报协议) 是一种简单 (simple)、不可靠 (unreliable) 的数据报协议 Transmission Control Protocol (TCP, 传输控制协议) 是一种复杂的 (sophisticated)、可靠的 (reliable)、字节流协议 Stream Control Transmission Protocol (SCTP, 流控制传输协议) 是一种较新的、可靠的协议，但它还提供消息边界 (message boundaries)、传输层级别的多宿 (multihoming)、最小化头端阻塞 (head-of-line blocking) 总图 图中最左边的应用 tcpdump 直接使用数据链路层接口 BPF (BSD packet filter, BSD 分组过滤器) 或 Datalink provider interface (DLPI, 数据链路提供者接口) 进行通信。而其他应用都是用 API 所提供的 socket 或 XTI。当然在 Linux 上提供了 SOCK_PACKET 这种 socket 来访问数据链路。
IPv4 Internet Protocol (IP, 网际协议)，版本 4。 这是自 1980 年代早期以来网际协议族中的主力协议，使用 32 bit 编码地址，为 TCP、 UDP、SCTP、ICMP 和 IGMP 提供分组传递服务。]]></description>
</item><item>
    <title>UNP 简介</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_001/</link>
    <pubDate>Mon, 17 Jan 2022 13:46:50 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_001/</guid>
    <description><![CDATA[信息 关于 UNP 的所有代码可以在 https://github.com/unpbook/unpv13e 上找到 从一个简单的时间获取客户端开始接下来，将从一个使用 TCP 连接的获取时间的客户端开始。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // 以下代码与 UNP intro/daytimetcpcli.]]></description>
</item><item>
    <title>初识 Phoenix Framework</title>
    <link>https://blog.ginshio.org/2021/elixir_phoenix_framework_notes_001/</link>
    <pubDate>Tue, 23 Feb 2021 19:52:05 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2021/elixir_phoenix_framework_notes_001/</guid>
    <description><![CDATA[Phoenix Framework 是一个 MVC web 框架，与 Ruby 的 Rails 和 Python 的 Django 类似，是整个 Elixir 社区的核心项目之一，推荐阅读 Phoenix 文档
安装我们使用 Phoenix (v1.5.7) 前，需要安装相关依赖与 mix
Elixir (&gt;= v1.6) Erlang (&gt;= 20) node.js [optional] (&gt;= 5.0.0) Database [default=PostgreSQL] inotify-tools [linux] erlang 与 elixir 是运行时环境，数据库方面使用同为社区维护的 Ecto 来操作，Phoenix 使用 node.js 的原因是使用 webpack 编译静态资源，当然你可以只开发 API 不使用静态资源
Phoenix 提供了非常有用的实时重新加载功能，不过 Linux 用户需要安装 inotify-tools 才能使用
创建新项目我们使用 mix 来创建一个 Phoenix 项目
1 mix phx.new awesome 如果你没有 phx.new 这个命令，你需要先使用 mix 安装一下]]></description>
</item></channel>
</rss>
