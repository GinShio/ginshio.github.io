<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Optimization - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/optimization/</link>
        <description>Optimization - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Fri, 23 Sep 2022 17:06:56 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/optimization/" rel="self" type="application/rss+xml" /><item>
    <title>优化简介</title>
    <link>https://blog.ginshio.org/2022/introduction_to_optimization/</link>
    <pubDate>Fri, 23 Sep 2022 17:06:56 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/introduction_to_optimization/</guid>
    <description><![CDATA[<h2 id="优化背景" class="headerLink">
    <a href="#%e4%bc%98%e5%8c%96%e8%83%8c%e6%99%af" class="header-mark"></a>优化背景</h2><p>上世纪 80 年代早期优化在编译器开发中还是一个可选特性，一般在其他部分都完成后才会添加到编译器中。因此出现了<strong>调试编译器</strong>和<strong>优化编译器</strong>的区别，即前者强调编译速度，因此可执行代码与源码之间存在较强的对应关系；后者强调最小化或最大化可执行程序的某些属性。因此优化编译器会花费更多时间来编译，生成质量更好的代码，通常这个过程伴随着大量移动操作，使调试变得困难。</p>
<p>从 RISC 开始流行，运行时性能开始需要编译器的优化。分支指令的延迟槽、非阻塞内存操作、流水线使用的增多以及功能单元数目的增加等，这些特性使得处理器性能不仅收程序布局和结构方面的制约，还受到指令调度和资源分配等底层细节的限制。</p>
<p>优化编译器现在变得司空见惯 (反而 go 是异类)，进而使编译器改变成了前端、后端的架构，优化将前端与性能问题分割开来。优化假定后端会处理资源分配的问题，因而假定针对具有无限寄存器、内存和功能单元的理想机器进行优化。这也对编译器后端产生了更大压力。</p>
<h3 id="示例-改进数组的地址计算" class="headerLink">
    <a href="#%e7%a4%ba%e4%be%8b-%e6%94%b9%e8%bf%9b%e6%95%b0%e7%bb%84%e7%9a%84%e5%9c%b0%e5%9d%80%e8%ae%a1%e7%ae%97" class="header-mark"></a>示例：改进数组的地址计算</h3><p>如果编译器前端对数组的引用 <code>m[i, j]</code> 生成的 IR 没有关于 m、i、j 的信息或不了解外围的上下文，编译器如果按照默认的行主序处理地址。生成的表达式类似</p>
<p>\[m + (i - low_{1}(m)) \times (high_{2}(m) - low_{2}(m) + 1) \times w + (j - low_{2}(m)) \times
w.\]</p>
<p>m 是数组的首地址，\(low_{i}(m)\) 和 \(high_{i}(m)\) 分别表示 m 的第 i 维的下界和上界，w 是 m 中一个元素的字节长度。如何降低该计算的代价，直接取决于对该数组变量极其上下文的分析。如果数组 m 是局部变量并各维度下界均从 1 开始，且上界已知，那么就可以将计算简化为
\[m + (i - 1) \times high_{2}(m) \times w + (j - 1) \times w.\]</p>
<p>如果引用出现在循环内部，且循环中 i 从 1 变动到 I，那么编译器可以使用<strong>运算符强度折减</strong> (OSR, Operator Strength Reduction) 将 \((i - 1) \times high_{2}(m) \times
w\) 替换为 \(i^{&rsquo;}_{x} = i^{&rsquo;}_{x - 1} + high_{2}(m) \times w\) (其中 \(i^{&rsquo;}_{1} =
0\))。同样地，如果 j 也是个循环的归纳变量 (IV, Induction Variable)，且 j 从 1 变动到 J，那么经过 OSR 后就有了 \(j^{&rsquo;}_{y} = j^{&rsquo;}_{y - 1} + w\) (其中
\(j^{&rsquo;}_{1} = 0\))。经过两次 OSR 后，只需要计算此式
\[m + i^{&rsquo;} + j^{&rsquo;}.\]</p>]]></description>
</item></channel>
</rss>
