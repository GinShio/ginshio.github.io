<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>IuputOutput - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/iuputoutput/</link>
        <description>IuputOutput - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/iuputoutput/" rel="self" type="application/rss+xml" /><item>
    <title>I/O 复用</title>
    <link>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</link>
    <pubDate>Sat, 26 Feb 2022 14:35:50 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/unixnetworkprogramming_005/</guid>
    <description><![CDATA[在客户端阻塞在 read 等待用户输入时，服务器关闭会导致向客户端发送 FIN，这是客户端的另一个输入。但由于客户端阻塞在 read 从而无法立即接受这个输入，直到从套接字读入为止。这就需要进程提前告知内核，使得内核在进程指定的输入准备好后，或可以输出后，立即通知进程，这个能力被称为 I/O 复用 (I/O multiplexing)。
I/O 复用有多个 syscall 可以实现，Unix 古老的函数 select 与 poll，POSIX 有一个比较新的变种为 pselect，而 Linux 与 freeBSD 独立发展出了 epoll 与 kqueue。
I/O 复用典型适用于以下场合：
当客户处理多个描述符时 客户同时处理多个套接字时，不过这种场景比较少见 如果 TCP 服务器既要监听套接字，又要处理已连接的套接字 如果一个服务器既要处理 TCP 又要处理 UDP，或同时处理多个不同协议，或多个服务 需要注意的是，并非只有网络编程需要用到 I/O 复用，I/O 复用是对文件描述符状态的监听，因此其他场景下也有其适用的空间。
I/O 模型在 Unix 系统上，一个输入操作通常包含两个不同的阶段
数据准备完成 从内核向进程复制数据 在等待数据准备到复制数据的过程，根据行为的不同，I/O 模型主要分为以下几种
blocking I/O (阻塞式 I/O)
阻塞式 I/O 模型是最常见、最简单、最好理解的 I/O 模型，目前为止所有的套接字函数都是阻塞式 I/O，另外 C 标准库所提供的 I/O 也是阻塞式 I/O，这样的模型符合初学函数时提及的运行流程。
在 recvfrom 这个示例中，只有数据报到达且复制到进程缓冲区中或错误发生才返回，而这段时间内进程是被阻塞的，不再向下运行代码。
nonblocking I/O (非阻塞式 I/O)]]></description>
</item><item>
    <title>输入输出</title>
    <link>https://blog.ginshio.org/2021/operatingsystem_004/</link>
    <pubDate>Sun, 25 Jul 2021 14:01:08 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2021/operatingsystem_004/</guid>
    <description><![CDATA[除了提供抽象外，操作系统还要控制计算机的所有 IO (输入/输出) 设备，必须向设备发送命令、捕获中断并处理设备的各种错误。它还应该在设备和其他部分之间提供简单且易于使用的接口，且这些接口应该尽可能的对所有设备都相同，即设备无关。
单位在进行本篇之前，需要明确一下计算机领域常用单位，只有统一了单位，我们才能更好的交流。
计算机领域以 bit (b，位) 和 byte (B，字节) 作为基本单位，bit 是只能表示 1 或 0 的单位数据，\(1 \texttt{Byte} = 8 \texttt{bit}\)，即 1 Byte 可以表示 256 种不同的状态。另外在 IO 传输数据时，最常用的单位即 比特率 (单位：bit/s 或 bps)，即每秒传输的 bit 数量，当然也可以对其进行除以 8 运算转变为 Byte/s。
传统单位以 SI (10 进制) 前缀为词头，而计算机领域多以 IEC 60027 (2 进制) 前缀为词头。一般内存与 CD 使用 IEC-60027 词头，而磁盘、闪存、DVD 常用 SI 词头表示容量。至于 Windows 系统对于容量的显示问题，内部转换为 IEC-60027 但显示的词头却是 SI，这也是历史原因所造成的。
词头 prefix 符号 \(10^{n}\) prefix 符号 \(2^{n}\) \(16^{n}\) 尧 yotta Y \(10^{24}\) yobi Yi \(2^{80}\) \(16^{20}\) 泽 zetta Z \(10^{21}\) zebi Zi \(2^{70}\) \(16^{17.]]></description>
</item></channel>
</rss>
