<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>DragonBook - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/dragonbook/</link>
        <description>DragonBook - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 28 May 2022 18:18:47 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/dragonbook/" rel="self" type="application/rss+xml" /><item>
    <title>中间代码生成</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_008/</link>
    <pubDate>Sat, 28 May 2022 18:18:47 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2022/compilerprinciple_008/</guid>
    <description><![CDATA[<p>在将给定源语言的一个程序翻译成特定机器代码的过程中，一个编译器可能构造出一系列中间表示。高层的中间表示接近源语言，而底层的表示接近目标语言。语法树是高层表示，它刻画了源程序的自然层次性结构，且适用于静态类型检查。低层表示适用于机器相关处理，如寄存器分配、指令选择等。</p>]]></description>
</item><item>
    <title>语法制导翻译</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_007/</link>
    <pubDate>Thu, 19 May 2022 13:26:43 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2022/compilerprinciple_007/</guid>
    <description><![CDATA[<p>最通用的语法制导翻译的方法是先通过构造一棵语法分析树，然后通过访问这棵树的各个结点来计算结点的属性值。在很多情况下，翻译可以在语法扫描分析期间完成，不需要构造出明确的语法分析树。语法制导翻译主要有两类：</p>]]></description>
</item><item>
    <title>语法分析 3</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_006/</link>
    <pubDate>Wed, 20 Apr 2022 16:25:13 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2022/compilerprinciple_006/</guid>
    <description><![CDATA[<p>一个自底向上的语法分析过程对应于为输入字符串构造语法分析树的过程，它从叶节点开始开始逐渐向上构造。虽然大部分编译器前端不会显示构造语法分析树，而是直接翻译，但自底向上构建有些像构建语法分析树。</p>]]></description>
</item><item>
    <title>语法分析 2</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_005/</link>
    <pubDate>Tue, 12 Apr 2022 22:23:17 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2022/compilerprinciple_005/</guid>
    <description><![CDATA[<p>自顶向下语法可以被看作输入串构造语法分析树的问题，从语法分析树的根结点开始，深度优先创建这棵树的各个结点。</p>
<p>对于输入 <strong>id</strong> <code>+</code> <strong>id</strong> <code>*</code> <strong>id</strong>，可以根据最左推导序列产生语法分析树序列：
\[\begin{aligned}
E &amp;\rightarrow TE^{&rsquo;}\\
E^{&rsquo;} &amp;\rightarrow +\ T\ E^{&rsquo;}\,|\,\varepsilon\\
T &amp;\rightarrow FT^{&rsquo;}\\
T^{&rsquo;} &amp;\rightarrow *\ F\ T^{&rsquo;}\,|\,\varepsilon\\
F &amp;\rightarrow (\ E\ )\,|\,\textbf{id}\\
\end{aligned}\]</p>]]></description>
</item><item>
    <title>语法分析 1</title>
    <link>https://blog.ginshio.org/2020/compilerprinciple_004/</link>
    <pubDate>Tue, 03 Nov 2020 16:09:25 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2020/compilerprinciple_004/</guid>
    <description><![CDATA[<p>程序设计语言构造的语法可以使用 <strong>上下文无关文法</strong> 或者 <strong>BNF (巴库斯-瑙尔范式)</strong> 表示法来描述，文法为语言设计者和编译器编写者提供了很大便利:</p>
<ul>
<li>文法给出了一个程序设计语言的精确易懂的语法归约</li>
<li>对于某些类型的文法，我们可以自动构造出高效的语法分析器，它能够确定一个源程序的语法结构。同时，语法分析器的构造过程可以揭示出语法的二义性，同时还可能发现一些容易在语言的初始设计阶段被忽略的问题</li>
<li>一个正确设计的文法给出了一个语言的结构，该结构有助于把源程序翻译为正确的目标代码，也有助于检测错误</li>
<li>一个文法支持逐步加入可以完成新任务的新语言构造，从而迭代地演化和开发程序语言。如果对语言的实现遵循语言的文法结构，那么在实现中加入这些新构造的工作就会变得更加容易</li>
</ul>
<p>语法分析器从词法分析器获得一个词法单元组成的串，并验证这个串可以由源语言的文法生成，我们期望语法分析器能够以易于理解的方式报告语法错误，并能够从常见的错误中恢复并继续处理程序的其余部分。从概念上来说，对于良构的程序，语法分析器构造出一棵 <strong>语法分析树</strong>，并把它传递给编译器的其他部分进一步处理。我们并不需要显式地构造出语法分析树，对于源程序的检查和翻译工作可以和语法分析过程交替完成，因此语法分析器和其他部分可以用一个模块实现。</p>]]></description>
</item><item>
    <title>词法分析 2</title>
    <link>https://blog.ginshio.org/2020/compilerprinciple_003/</link>
    <pubDate>Sat, 17 Oct 2020 22:33:04 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2020/compilerprinciple_003/</guid>
    <description><![CDATA[<h2 id="nfa的重要状态" class="headerLink">
    <a href="#nfa%e7%9a%84%e9%87%8d%e8%a6%81%e7%8a%b6%e6%80%81" class="header-mark"></a>NFA的重要状态</h2><p>如果一个 NFA 状态有一个标号非 \(\varepsilon\) 的离开转换，那么我们称这个状态为 <strong>重要状态</strong>
(important state)。子集构造法在计算 \(\varepsilon-closure(move(T，a))\) 的时候，它只使用了集合T中的重要状态，也就是说只有当状态s是重要的，状态集合 \(move(s,a)\) 才可能是非空的。在子集构造法的应用过程中，两个NFA状态集合可以被认为是一致的条件是</p>]]></description>
</item><item>
    <title>词法分析 1</title>
    <link>https://blog.ginshio.org/2020/compilerprinciple_002/</link>
    <pubDate>Thu, 16 Jul 2020 16:47:49 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2020/compilerprinciple_002/</guid>
    <description><![CDATA[<p>词法分析是编译器的第一阶段，主要负责读取源程序的输入字符，将它们组成 <strong>词素</strong>，生成并输出一个词法单元序列，每个词法单元对应一个词素，这个词法单元序列将被语法分析器进行语法分析。除此之外，词法分析器还会过滤源程序中的注释和空白，生成错误信息与源程序的位置关联起来，有时还会进行宏扩展。</p>]]></description>
</item><item>
    <title>编译器与程序设计语言</title>
    <link>https://blog.ginshio.org/2020/compilerprinciple_001/</link>
    <pubDate>Tue, 14 Jul 2020 15:47:02 &#43;0800</pubDate><author>
                    <name>GinShio</name>
                </author><guid>https://blog.ginshio.org/2020/compilerprinciple_001/</guid>
    <description><![CDATA[<h2 id="编译器" class="headerLink">
    <a href="#%e7%bc%96%e8%af%91%e5%99%a8" class="header-mark"></a>编译器</h2><p>编译器是一个 <strong>程序</strong>，它可以阅读以某一 <code>源语言</code> 编写的程序，并把该程序翻译成一个
<strong>等价的</strong>、用 <code>目标语言</code> 编写的程序; 解释器是另一种语言处理器，它直接利用用户提供的输入执行源程序中指定的操作。</p>]]></description>
</item></channel>
</rss>
