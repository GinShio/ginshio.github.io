<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Sort - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/sort/</link>
        <description>Sort - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Fri, 27 Aug 2021 08:26:23 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/sort/" rel="self" type="application/rss+xml" /><item>
    <title>排序算法</title>
    <link>https://blog.ginshio.org/2021/data_strucures_and_algorithm_analysis_007_sorting_algorithm/</link>
    <pubDate>Fri, 27 Aug 2021 08:26:23 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2021/data_strucures_and_algorithm_analysis_007_sorting_algorithm/</guid>
    <description><![CDATA[Sorting something that you will never search is a complete waste; searching something you never sorted is merely inefficient.
&mdash; Brian Christian
我们假设对数组进行排序，数组的所有位置都有元素，且长度为 N。对于排序，假设元素存在 \(&lt;\) 和 \(&gt;\) 用以将输入按一致的次序放置，比较运算是除赋值运算外仅有的能对输入数据进行的操作。这种条件下的排序称之为 比较排序 (comparison-based sorting)。另外对于已经排序完成的数组，如果可以保持原本的数据次序我们称之为 稳定排序 (stable sorting)。
当然这与 STL 的算法有一点点出入，sort 接收的是迭代器来表示待排序的范围，以及一个可选的比较器。而且 sort 的底层算法也更加复杂，这里只是简单地说明各个基础排序。
1 2 3 4 template &lt;class Iterator&gt; void sort(Iterator begin, Iterator end); template &lt;class Iterator, class Comparator&gt; void sort(Iterator begin, Iterator end, Comparator cmp); 为了方便理解，将使用 Wikipedia 上关于排序的动图来帮助理解这种排序。先放个大招
表格 排序算法简要比较 摘自 Wikipedia]]></description>
</item></channel>
</rss>
