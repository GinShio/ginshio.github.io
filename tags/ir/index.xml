<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>IR - 标签 - iris</title>
        <link>https://blog.ginshio.org/tags/ir/</link>
        <description>IR - 标签 - iris</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>ginshio78@gmail.com (GinShio)</managingEditor>
            <webMaster>ginshio78@gmail.com (GinShio)</webMaster><lastBuildDate>Mon, 19 Sep 2022 15:59:40 &#43;0800</lastBuildDate><atom:link href="https://blog.ginshio.org/tags/ir/" rel="self" type="application/rss+xml" /><item>
    <title>中间表示</title>
    <link>https://blog.ginshio.org/2022/intermediate_representation/</link>
    <pubDate>Mon, 19 Sep 2022 15:59:40 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/intermediate_representation/</guid>
    <description><![CDATA[<p>编译器通常组织为一连串的处理 pass，在每两个 pass 之间需要将已知的所有信息进行传递，因此编译器需要<strong>中间表示</strong> (IR, Intermediate Representation) 表达信息。IR 在编译器中可能是唯一的，也可能有多种。在转换期间，编译器不会回头查看源代码，而是只观察
IR，因此 IR 的性质对编译器对代码的处理由决定性影响。</p>
<p>除了词法分析器，大多数 pass 的输入都是 IR；除了代码生成器，大多数 pass 的输出都是 IR。大多数源代码并不足以支持编译器必须的信息，比如变量与常量的地址，或参数使用的寄存器等，为了记录所有信息，大多数编译器还会添加表和集合来记录额外信息，通常认为这也是 IR 的一部分。</p>
<p>IR 的实现会迫使编译器的开发人员专注于实际问题，用廉价的方式来执行需要频繁进行的操作，并且简洁的表示编译器间可能出现的所有结构。除了这些，还需要可读的 IR 表示。当然，对于使用 IR 的编译器来说，总会在 IR 上进行多次处理，一个 pass 处理中收集信息，另一个 pass 处理中优化代码。</p>
<h2 id="ir-的分类" class="headerLink">
    <a href="#ir-%e7%9a%84%e5%88%86%e7%b1%bb" class="header-mark"></a>IR 的分类</h2><p>编译器使用过许多种 IR，主要是三个方面：<strong>结构性的组织</strong>、<strong>抽象层次</strong>和<strong>命名方案</strong>。一般来说，这三个属性是独立的。对于 IR 从结构上可以分为：</p>
<dl>
<dt>图 IR</dt>
<dd>将编译器信息编码在图中。算法通过途中的对象来表述：结点、边、列表、树。</dd>
<dt>线性 IR</dt>
<dd>类似某些抽象机上的伪代码，相应算法将迭代遍历简单的线性操作序列。</dd>
<dt>混合 IR</dt>
<dd>混合前两种以获取优势，比如现代编译器中常见的 BasicBlock (BB) 内线性表示，而使用控制流图来表示 bb 之间的关系。</dd>
</dl>
<p>IR 的结构性组织对编译器的分析、优化、代码生成等有极大影响，比如树形 IR 得出的处理 pass 在结构上很自然的设计为某种形式的树遍历，而线性 IR 得出的处理 pass 一般顺序迭代遍历各个操作。</p>
<p>IR 所处的抽象层次，如果接近源代码，可能只需要一个结点就可以表示数组访问或过程调用，而较底层的表示中，可能需要合并几个 IR 操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-glsl" data-lang="glsl"><span class="line"><span class="cl"><span class="n">uint</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">]</span> <span class="n">arr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">arr</span><span class="p">[</span><span class="mi">50</span><span class="p">][</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="c1">;; Spir-V</span>
</span></span><span class="line"><span class="cl"><span class="nv">%_var_arr</span> <span class="nf">=</span> <span class="nv">OpVariable</span> <span class="nv">%_ptr_arr_100_100</span> <span class="nv">Function</span>
</span></span><span class="line"><span class="cl">    <span class="nv">%elem</span> <span class="nf">=</span> <span class="nv">OpAccessChain</span> <span class="nv">%_ptr_int</span> <span class="nv">%_var_arr</span> <span class="nv">%uint_50</span> <span class="nv">%uint_50</span>
</span></span><span class="line"><span class="cl">            <span class="nv">OpStore</span> <span class="nv">%elem</span> <span class="nv">%uint_32</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="c1">;; LLVM IR</span>
</span></span><span class="line"><span class="cl"><span class="nv">%1</span> <span class="nf">=</span> <span class="nv">alloca</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="nv">i32</span><span class="p">]]</span><span class="o">,</span> <span class="nv">align</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nv">%2</span> <span class="nf">=</span> <span class="nv">getelementptr</span> <span class="nv">inbounds</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="nv">i32</span><span class="p">]]</span><span class="o">,</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="nv">i32</span><span class="p">]]</span><span class="nf">*</span> <span class="nv">%1,</span> <span class="nv">i64</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">i64</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="nv">%3</span> <span class="nf">=</span> <span class="nv">getelementptr</span> <span class="nv">inbounds</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="nv">i32</span><span class="p">]</span><span class="o">,</span> <span class="p">[</span><span class="mi">100</span> <span class="nv">x</span> <span class="nv">i32</span><span class="p">]</span><span class="nf">*</span> <span class="nv">%2,</span> <span class="nv">i64</span> <span class="mi">0</span><span class="o">,</span> <span class="nv">i64</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="nv">store</span> <span class="nv">i32</span> <span class="mi">32</span><span class="o">,</span> <span class="nv">i32*</span> <span class="nv">%3,</span> <span class="nv">align</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>很明显，上面这三个不同层次的代码，对于简单的构造数组，并进行访问元素赋值，它们是不一样的。低层次的 IR 可以展现出更多源代码中所隐藏的细节，从而为编译器优化提供更多可能。</p>]]></description>
</item><item>
    <title>中间代码生成</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_008/</link>
    <pubDate>Sat, 28 May 2022 18:18:47 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/compilerprinciple_008/</guid>
    <description><![CDATA[<p>在将给定源语言的一个程序翻译成特定机器代码的过程中，一个编译器可能构造出一系列中间表示。高层的中间表示接近源语言，而底层的表示接近目标语言。语法树是高层表示，它刻画了源程序的自然层次性结构，且适用于静态类型检查。低层表示适用于机器相关处理，如寄存器分配、指令选择等。</p>
<h2 id="语法树的变体" class="headerLink">
    <a href="#%e8%af%ad%e6%b3%95%e6%a0%91%e7%9a%84%e5%8f%98%e4%bd%93" class="header-mark"></a>语法树的变体</h2><p>语法树中的各个结点代表了源程序的构造，一个结点的所有子结点反映了该结点对应构造的有意义的组成成分。为表达式构建的有向无环图 (Directed Acyclic Graph, DAG) 指出了表达式中的公共子表达式。</p>
<p>与语法分析树有些不同的是，DAG 的结点可能有多个父结点，也就是说这个结点是个公共子结点。比如表达式 \(a + a * (b - c) + (b - c) * d\)</p>
<figure>
</figure>

<p>SDD 既可以构造语法树，也可以构造 DAG，在构造 DAG 结点时每次构造之前都会检查是否已存在这样的结点。如果已存在结点，就返回已有结点，否则构建新结点。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">编号</th>
          <th style="text-align: left">产生式</th>
          <th style="text-align: left">语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">\(E\rightarrow{}E_{1}+T\)</td>
          <td style="text-align: left">\(E.node=\textbf{new}\ Node(&rsquo;+&rsquo;,E_{1}.node,T.node)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">2</td>
          <td style="text-align: left">\(E\rightarrow{}E_{1}-T\)</td>
          <td style="text-align: left">\(E.node=\textbf{new}\ Node(&rsquo;-&rsquo;,E_{1}.node,T.node)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">3</td>
          <td style="text-align: left">\(\begin{aligned}E&amp;\rightarrow{}T\\T&amp;\rightarrow{}T_{1}*F\end{aligned}\)</td>
          <td style="text-align: left">\(\begin{aligned}E.node&amp;=T.node\\T.node&amp;=\textbf{new}\ Node(&rsquo;*&rsquo;,T_{1}.node,F.node)\end{aligned}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">4</td>
          <td style="text-align: left">\(T\rightarrow{}(E)\)</td>
          <td style="text-align: left">\(T.node=E.node\)</td>
      </tr>
      <tr>
          <td style="text-align: left">5</td>
          <td style="text-align: left">\(T\rightarrow{}\textbf{id}\)</td>
          <td style="text-align: left">\(T.node=\textbf{new}\ Leaf(\textbf{id},\textbf{id}.entry)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">6</td>
          <td style="text-align: left">\(T\rightarrow{}\textbf{num}\)</td>
          <td style="text-align: left">\(T.node=\textbf{new}\ Leaf(\textbf{num},\textbf{num}.entry)\)</td>
      </tr>
  </tbody>
</table>
<p>通常语法树或 DAG 的结点存放在记录数组中，每个记录第一个字段是运算符代码，也是该结点的标号；叶结点可能有一个存放词法值的字段，而内部结点可能有两个指向其左右运算数的字段。</p>
<p>在这样的一个数组中，我们只需要给定结点对应的整数下标就可以引用该结点了。而这个下标被称为表达式的<strong>值编码</strong> (value number)。通常为了防止结点太多所造成的巨大的搜索开销，可以用 Hash 的方法实现，加快创建结点时的搜索。</p>
<h2 id="三地址码" class="headerLink">
    <a href="#%e4%b8%89%e5%9c%b0%e5%9d%80%e7%a0%81" class="header-mark"></a>三地址码</h2><p>三地址码中一条指令的右侧最多有一个运算符，因此 \(x+y*z\) 这样的代码可能被翻译成
\[\begin{aligned}
t_{1} &amp;= y * z\\
t_{2} &amp;= x + t_{1}
\end{aligned}\]</p>]]></description>
</item><item>
    <title>语法制导翻译</title>
    <link>https://blog.ginshio.org/2022/compilerprinciple_007/</link>
    <pubDate>Thu, 19 May 2022 13:26:43 &#43;0800</pubDate><author>
                        <name>GinShio</name><uri>https://blog.ginshio.org/</uri><email>ginshio78@gmail.com</email></author><guid>https://blog.ginshio.org/2022/compilerprinciple_007/</guid>
    <description><![CDATA[<p>最通用的语法制导翻译的方法是先通过构造一棵语法分析树，然后通过访问这棵树的各个结点来计算结点的属性值。在很多情况下，翻译可以在语法扫描分析期间完成，不需要构造出明确的语法分析树。语法制导翻译主要有两类：</p>
<ul>
<li>L 属性翻译 (从左到右)，可以在语法分析过程中完成的翻译方案</li>
<li>S 属性翻译 (综合)，可以很容易与自底向上语法分析过程联系起来</li>
</ul>
<h2 id="语法制导定义" class="headerLink">
    <a href="#%e8%af%ad%e6%b3%95%e5%88%b6%e5%af%bc%e5%ae%9a%e4%b9%89" class="header-mark"></a>语法制导定义</h2><p>语法制导定义 (Syntax-Directed Definition, SDD) 是一个上下文无关文法
(Context-Free Grammar, CFG) 和属性及规则的结合，属性和文法符号相关联，而规则和产生式相关联。如果 X 是一个符号而 a 是 X 的一个属性，那么我们用 <code>X.a</code> 表示 a 在某个标号为 X 的分析树结点上的值。</p>
<h3 id="继承属性与综合属性" class="headerLink">
    <a href="#%e7%bb%a7%e6%89%bf%e5%b1%9e%e6%80%a7%e4%b8%8e%e7%bb%bc%e5%90%88%e5%b1%9e%e6%80%a7" class="header-mark"></a>继承属性与综合属性</h3><p>处理非终结符的两种属性：</p>
<dl>
<dt>综合属性 (synthesized attribute)</dt>
<dd>在分析树结点 N 上的非终结符 A 的综合属性是由 N 上的产生式所关联的语义规则来定义的。这个产生式的头部一定是 A，结点 N 上的综合属性只能通过 N 的子结点或 N
本身的属性值来定义。</dd>
<dt>继承属性 (inherited attribute)</dt>
<dd>在分析树结点 N 上的非终结符 B 的继承属性是由 N 的父结点上的产生式所关联的语义规则来定义的。这个产生式的体中必然包含符号 B，结点 N 上的继承属性只能通过
N 的父结点、N 本身和 N 的兄弟结点上的属性来定义。</dd>
</dl>
<p>虽然不允许结点 N 的继承属性通过子结点上的属性来定义，但可以通过结点本身的继承属性定义综合属性。另外，终结符可以由综合属性，但不能有继承属性，它的属性值是由词法分析器提供的词法值，SDD 中没有计算终结符的属性值的语义规则。</p>
<p>比如有一个简单的加乘计算器。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">编号</th>
          <th style="text-align: left">产生式</th>
          <th style="text-align: left">语义规则</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">\(L\rightarrow{}E\textbf{n}\)</td>
          <td style="text-align: left">\(L.val = E.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">2</td>
          <td style="text-align: left">\(E\rightarrow{}E_{1}+T\)</td>
          <td style="text-align: left">\(E.val = E_{1}.val + T.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">3</td>
          <td style="text-align: left">\(E\rightarrow{}T\)</td>
          <td style="text-align: left">\(E.val = T.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">4</td>
          <td style="text-align: left">\(T\rightarrow{}T_{1}*F\)</td>
          <td style="text-align: left">\(T.val = T_{1}.val \times F.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">5</td>
          <td style="text-align: left">\(T\rightarrow{}F\)</td>
          <td style="text-align: left">\(T.val = F.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">6</td>
          <td style="text-align: left">\(F\rightarrow(E)\)</td>
          <td style="text-align: left">\(F.val = E.val\)</td>
      </tr>
      <tr>
          <td style="text-align: left">7</td>
          <td style="text-align: left">\(F\rightarrow{}\textbf{digit}\)</td>
          <td style="text-align: left">\(F.val = \textbf{digit}.lexval\)</td>
      </tr>
  </tbody>
</table>
<p>产生式 1 设置了整个表达式的值，而产生式 2 的值由它的两个子结点的值求和得来，类似的产生式 4 的值由它的两个子结点的值求积得来。而产生式 7 的值由词法单元返回的数值得来。这个只包含综合属性的 SDD 被称作 S 属性 (S-attribute) SDD，它的头部的非终结符的值都由产生式的体的属性值计算得来。</p>]]></description>
</item></channel>
</rss>
