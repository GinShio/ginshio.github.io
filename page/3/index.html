

<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta name="generator" content="Hugo 0.134.2">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>iris</title><meta name="Description" content="iris | GinShio 的个人博客"><meta property="og:url" content="https://blog.ginshio.org/">
  <meta property="og:site_name" content="iris">
  <meta property="og:title" content="iris">
  <meta property="og:description" content="iris | GinShio 的个人博客">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">
    <meta property="og:image" content="https://blog.ginshio.org/avatar.webp">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://blog.ginshio.org/avatar.webp">
  <meta name="twitter:title" content="iris">
  <meta name="twitter:description" content="iris | GinShio 的个人博客">
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="iris">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="iris"><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/color.34e5eb0ed3195c558eb6994b94f6ce01b4d7121bda08365c4f94b70d178301efdb761cb63c963c02c67c45152c3c9498.css" integrity="sha384-NOXrDtMZXFWOtplLlPbOAbTXEhvaCDZcT5S3DReDAe/bdhy2PJY8AsZ8RRUsPJSY"><link rel="stylesheet" href="/css/style.min.71903c93e482438bcb694a21934b32795f3f9dc2c7076dadfa66ca836805f90335eae546d168ddaa1c5de8eda3532d79.css" integrity="sha384-cZA8k&#43;SCQ4vLaUohk0syeV8/ncLHB22t&#43;mbKg2gF&#43;QM16uVG0Wjdqhxd6O2jUy15"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <meta name="google-site-verification" content="fbzw9fQcZyEFrrrUtxLfzYW-qhZ5TMEZKHHSp9NeLBw" /><meta name="msvalidate.01" content="EC9CEC799D42793C414AE7BDB0D0205C" /><meta name="yandex-verification" content="c0b808dd3e49f730" /><meta name="baidu-site-verification" content="code-RhPhu2ccLc" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/blog.ginshio.org\/","inLanguage": "zh-cn","author": {
                "@type": "Person",
                "name": "GinShio"
            },"description": "iris | GinShio 的个人博客","image": "https:\/\/blog.ginshio.org\/screenshot.png","thumbnailUrl": "https:\/\/blog.ginshio.org\/screenshot.png","name": "iris"
    }
    </script><script src="//instant.page/5.1.1" defer type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>
</head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme; }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="#" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="page home" posts><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="归档"><img
        
        loading="eager"
        src="/avatar.webp"
        srcset="/avatar.webp, /avatar.webp 1.5x, /avatar.webp 2x"
        sizes="auto"
        alt="/avatar.webp"
        title="/avatar.webp" height="100"   width="100" ></a></div><h1 class="home-title">GinShio</h1><h2 class="home-subtitle"><div id="id-1" class="typeit"></div></h2><div class="links"><a href="https://github.com/GinShio" title="GitHub" target="_blank" rel="noopener noreferrer me"><i class="fab fa-github-alt fa-fw"></i></a><a href="https://gitlab.com/GinShio" title="GitLab" target="_blank" rel="noopener noreferrer me"><i class="fab fa-gitlab fa-fw"></i></a><a href="https://steamcommunity.com/id/GinShio" title="Steam" target="_blank" rel="noopener noreferrer me"><i class="fab fa-steam fa-fw"></i></a><a href="https://space.bilibili.com/5091427" title="bilibili" target="_blank" rel="noopener noreferrer me"><i data-svg-src="/svg/icons/bilibili.min.svg"></i></a><a href="mailto:ginshio78@gmail.com" title="Email" rel=" me"><i class="far fa-envelope fa-fw"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreferrer me"><i class="fas fa-rss fa-fw"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_007_sorting_algorithm/">排序算法</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-27">08-27</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><blockquote>
<p>Sorting something that you will never search is a complete waste; searching something you never sorted is merely inefficient.</p>
<p>&mdash; Brian Christian</p>
</blockquote>
<p>我们假设对数组进行排序，数组的所有位置都有元素，且长度为 N。对于排序，假设元素存在 \(&lt;\) 和 \(&gt;\) 用以将输入按一致的次序放置，比较运算是除赋值运算外仅有的能对输入数据进行的操作。这种条件下的排序称之为 <strong>比较排序</strong> (comparison-based sorting)。另外对于已经排序完成的数组，如果可以保持原本的数据次序我们称之为 <strong>稳定排序</strong>
(stable sorting)。</p>
<p>当然这与 STL 的算法有一点点出入，sort 接收的是迭代器来表示待排序的范围，以及一个可选的比较器。而且 sort 的底层算法也更加复杂，这里只是简单地说明各个基础排序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Iterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Comparator</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">sort</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">,</span> <span class="n">Comparator</span> <span class="n">cmp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了方便理解，将使用 Wikipedia 上关于排序的动图来帮助理解这种排序。先放个大招</p>
<p>表格 <a href="#table--tbl:comparison-of-algorithm" rel="">排序算法简要比较</a> 摘自 <a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms" target="_blank" rel="noopener noreferrer">Wikipedia</a></p>
<p><a id="table--tbl:comparison-of-algorithm"></a></p>
<div class="table-caption">
  <span class="table-number"><a href="#table--tbl:comparison-of-algorithm">Table 1</a>:</span>
  排序算法简要比较
</div>
<table>
  <thead>
      <tr>
          <th style="text-align: left">名称</th>
          <th style="text-align: left">英文名称</th>
          <th style="text-align: left">稳定性</th>
          <th style="text-align: left">\(Time_{avg}\)</th>
          <th style="text-align: left">\(Time_{bad}\)</th>
          <th style="text-align: left">\(Mem\)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">冒泡排序</td>
          <td style="text-align: left">bubble sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">选择排序</td>
          <td style="text-align: left">selection sort</td>
          <td style="text-align: left">\(\times\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">插入排序</td>
          <td style="text-align: left">insertion sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">希尔排序</td>
          <td style="text-align: left">shell sort</td>
          <td style="text-align: left">\(\times\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{\frac{3}{2}})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">堆排序</td>
          <td style="text-align: left">heap sort</td>
          <td style="text-align: left">\(\times\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">归并排序</td>
          <td style="text-align: left">merge sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">原地归并排序</td>
          <td style="text-align: left">in-place merge sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}^{2}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}^{2}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(1)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">快速排序</td>
          <td style="text-align: left">quick sort</td>
          <td style="text-align: left">\(\times\)</td>
          <td style="text-align: left">\(\mathcal{O}(N\log_{}{N})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2})\)</td>
          <td style="text-align: left">\(\mathcal{O}(\log_{}{N})\)</td>
      </tr>
      <tr>
          <td style="text-align: left">桶排序</td>
          <td style="text-align: left">bucket sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + k)\)</td>
          <td style="text-align: left">\(\mathcal{O}(N^{2} + k)\)</td>
          <td style="text-align: left">\(\mathcal{O}(2^{k})\)</td>
      </tr>
      <tr>
          <td style="text-align: left">计数排序</td>
          <td style="text-align: left">counting sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + r)\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + r)\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + r)\)</td>
      </tr>
      <tr>
          <td style="text-align: left">基数排序 (LSD)</td>
          <td style="text-align: left">lsd radix sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N \frac{k}{d})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N \dfrac{k}{d})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + 2^{d})\)</td>
      </tr>
      <tr>
          <td style="text-align: left">基数排序 (MSD)</td>
          <td style="text-align: left">msd radix sort</td>
          <td style="text-align: left">\(\checkmark\)</td>
          <td style="text-align: left">\(\mathcal{O}(N \frac{k}{d})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N \dfrac{k}{d})\)</td>
          <td style="text-align: left">\(\mathcal{O}(N + 2^{d})\)</td>
      </tr>
  </tbody>
</table>
<p>其中 k 为键的大小，d 为数位大小，r 为排序的数字的范围大小。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_007_sorting_algorithm/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/sort/">Sort</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_006_heap_structure/">堆结构</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-25">08-25</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><h2 id="模型" class="headerLink">
    <a href="#%e6%a8%a1%e5%9e%8b" class="header-mark"></a>模型</h2><p>优先队列 (priority queue) 的 ADT 与 queue 类似，它们都提供了基本的 <code>enqueue</code> 与
<code>dequeue</code> 操作。但是 priority queue 可以在 dequeue 时将数据按照一定顺序弹出队列，而不是 FIFO。我们这里主要讨论每次出队最小的元素 (即 <code>delete_min</code>)，如果你希望进行其他一些有规范的操作，方法与这类似。</p>
<p>显然 priority queue 有一个朴素解，那就是在每次 <code>delete_min</code> 时遍历整个存储单元，找到最小的元素并删除，其时间复杂度 \(\mathcal{O}(N)\) ，当然插入元素的时间复杂度会好很多，只需要 \(\mathcal{O}(1)\) 。当然你也可以将其反过来，在插入时就找到最小的元素。</p>
<p>显然这是无法接受的，即使是利用前几篇中介绍过的 AVL 树都可以将其时间复杂度压缩到
\(\mathcal{O}(\log_{}{N})\) 。不过这有点太过分了，平衡 BST 的很多操作可能是用不上的，而且为了优先队列再实现一个平衡树实在是太难为人了。</p>
<p>我们将要介绍的工具叫做 <strong>二叉堆</strong> (binary heap)，用以实现有限队列。但是需要注意的是， <code>堆</code> (heap) 这里指的是一种数据结构，而非操作系统中用以分配动态内存的地方。</p>
<h2 id="二叉堆" class="headerLink">
    <a href="#%e4%ba%8c%e5%8f%89%e5%a0%86" class="header-mark"></a>二叉堆</h2><h3 id="结构性质" class="headerLink">
    <a href="#%e7%bb%93%e6%9e%84%e6%80%a7%e8%b4%a8" class="header-mark"></a>结构性质</h3><p>binary heap 是一棵被完全填满的二叉树，或者说是一棵 complete binary tree。由于
complete binary tree 的排列十分有规律，因此我们可以将其转化为数组，不再需要链来链接它。</p>
<figure><img src="/images/algo-array-implement-for-complete-binary-tree.svg" width="64%">
</figure>

<p>对于数组任一位置 \(i\) 上的元素，其左右儿子分别在在位置 \(2i + 1\) 和 \(2i +2\) 上，而它的父亲则在位置 \(\lfloor(i - 1)/2\rfloor\) 上。当然如果根从 \(1\) 开始，那么位置 \(i\) 上元素的左右儿子的位置分别为 \(2i\) 和 \(2i + 1\) ，而父亲的位置是 \(\lfloor i/2 \rfloor\) 。以下未说明的情况，我们将 1 作为 root 的下标。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_006_heap_structure/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/heap/">Heap</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_005_hash_table/">散列表</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-25">08-25</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><blockquote>
<p>She made a hash of the proper names, to be sure.</p>
<p>&mdash; Grant Allen</p>
</blockquote>
<h2 id="散列函数" class="headerLink">
    <a href="#%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0" class="header-mark"></a>散列函数</h2><p>如果可以将存储的数据，其中某一项用于查找，则这个项被称为 <strong>键</strong> (key)，而通过一定规则将键映射到表中的一个合适的单元，这个规则被称为 <strong>散列函数</strong> (hash function)。我们希望 hash 足够简单且保证两个不同的 key 映射到不同的单元，但是单元是有限的，因此我们需要寻找一个 hash function 尽量均匀的产生 hash value。当映射不是单射而是多射时，即发生了 <strong>冲突</strong> (collision)，有两个不同的 key 经过 hash function 得到了相同的 hash value，我们应该处理这个 collision。</p>
<p>顺便一提，我们一般使用 hash value 对表长进行取模，从而确定数据在表中的位置，表长为素数是可以很好的让 hash value 取模后均匀分布在表中。</p>
<p>我们假设一个简单的字符串 hash function，即将字符串中所有的字符的 ASCII 相加所得到的。如果表很大，就不能很好的平均分配数据。比如 \(TableSize = 10'007\) ，并设所有的键长度为 8，而这些键的最大 hash value 不超过 1016 (\(127 * 8\))，这显然不是平均分配的。</p>
<p>如果假设 Key 至少有 3 个字符，并且设置一个只考虑前 3 个字符的 hash function：
\(c_{0} + 27 * c_{1} + 27 * 27 * c_{2}\) 。我们假设键的前三个字符是随机的，表的大小依然是 10007，那么我们就会得到一个均匀分布的 hash value。但是英文实际上并不是随机的，虽然前三个字符有 \(26^{3} = 16576\) 种可能的组合，但是事实证明 3 个字母不同的组合数实际上只有 <code>2851</code> 。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_005_hash_table/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/hashtable/">HashTable</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_004_searching_structure/">查找结构</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-23">08-23</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><p>如果给定一个序列，你将如何在这个序列中查找一个给定元素 target，当找到时返回该元素的迭代器，否则返回末尾迭代器。首先排除时间复杂度 \(\mathcal{O}(N)\) 的朴素算法，这不是本文的重点。</p>
<h2 id="二分查找" class="headerLink">
    <a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be" class="header-mark"></a>二分查找</h2><p><strong>二分法</strong> (Dichotomy) 是一种思想，将一个整体事物分割成两部分，这两部分必须是互补事件，即所有事物必须属于双方中的一方且互斥。如此我们就可以在 \(\mathcal{O}(1)\) 的时间内将问题大小减半。</p>
<p><strong>二分查找</strong> (binary search)，又称折半查找，这是一种可以在
\(\mathcal{O}(\log_{}{N})\) 时间复杂度下完成查找的算法。二分查找要求序列必须是有序的，才能正确执行：将序列划分为两部分，如果中间值大于 target，意味着这之后的值都大于 target，需要继续向前找；如果中间值小于 target，意味着这之前的所有值都小于
target，需要继续向后找。</p>
<h2 id="avl-树" class="headerLink">
    <a href="#avl-%e6%a0%91" class="header-mark"></a>AVL 树</h2><p>上一篇介绍树时分析了 BST 中为什么很容易发生不平衡现象。在极端情况下，只有一个
leaf 的树，在查找元素时其时间复杂度退化为 \(\mathcal{O}(N)\) 。</p>
<p>为了防止 BST 退化为链表，必须保证其可以维持树的平衡，一次需要有一个 <strong>平衡条件</strong>
(balanced condition)。如果每个结点都要求其左右子树具有相同的高度，显然是不可能的，因为这样实在是太难了。在 1962 年，由苏联计算机科学家 G.M.Adelson-Velsky 和
Evgenii Landis 在其论文 <strong>An algorithm for the organization of information</strong> 中公开了数据结构 AVL (Adelson-Velsky and Landis) 树，这是计算机科学中 <code>最早被发现的</code>
自平衡二叉树。</p>
<h3 id="avl-的平衡因子" class="headerLink">
    <a href="#avl-%e7%9a%84%e5%b9%b3%e8%a1%a1%e5%9b%a0%e5%ad%90" class="header-mark"></a>AVL 的平衡因子</h3><p>AVL 树将子树的高度限制在差为 1，即一个结点，如果其左子树与由子树的高度差
\(|D_{h}| \leq 1\) ，则认为这棵树是平衡的。因此带有平衡因子 \(-1\) 、 \(0\) 或 \(1\) 的结点被认为是平衡的，而 \(-2\) 或 \(2\) 的平衡因子被认为是需要调整的。平衡因子可以直接存储于结点之中，也可以利用存储在结点中的子树高度计算得出。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_004_searching_structure/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/binarytree/">BinaryTree</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_003_tree_structure/">树结构</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-19">08-19</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><blockquote>
<p>Not all roots are buried down in the ground, some are at the top of a tree.</p>
<p>&mdash; Jinvirle</p>
</blockquote>
<h2 id="树--tree" class="headerLink">
    <a href="#%e6%a0%91--tree" class="header-mark"></a>树 (tree)</h2><p>Tree 是一些结点的集合，这个集合可以是空集；若不是空集，则 Tree 是由称为 <strong>根</strong> 的结点 r 以及零或多个非空的子树 \(T_{1}, T_{2}, \cdots, T_{N}\) 组成，这些子树的根都与 r 有一条有向边 (edge) 连接。这些子树的根被称为根 r 的孩子 (child)，而 r 是这些 child 的父亲 (parent)。</p>
<h3 id="树的属性" class="headerLink">
    <a href="#%e6%a0%91%e7%9a%84%e5%b1%9e%e6%80%a7" class="header-mark"></a>树的属性</h3><p>根据给出的树的递归定义，可以发现一个树是由 \(N\) 个 node 和 \(N - 1\) 条 edge 的集合。而除 root 外的所有 node 都有一个由其 parent 指向它的 edge。在树中有一些特殊的属性是需要注意的，这里先给出相关概念与示例，如果不是很理解，可以通过结合示例来理解这些概念。</p>
<dl>
<dt>结点的度 (degree)</dt>
<dd>一个节点含有的子树的个数称为该节点的度</dd>
<dt>树的度 (degree of tree)</dt>
<dd>一棵树中最大的 node degree 称为树的度</dd>
<dt>叶结点 (leaf)</dt>
<dd>或称<strong>终端结点</strong>，如果结点满足 \(degree = 0\) 则该结点为叶结点</dd>
<dt>分支结点 (branch node)</dt>
<dd>或称<strong>内部结点</strong> (internal node)、<strong>非终端结点</strong>，度不为 0 的结点</dd>
<dt>层次 (level)</dt>
<dd>从 root 开始，root 所在的层为第 1 层，root 的 child 为第二层，以此类推</dd>
<dt>关系</dt>
<dd>树就像一本族谱，从 root 开始结点直接有一定的亲缘关系
<ul>
<li><strong>兄弟 (sibling):</strong> 具有相同父节点的节点互为兄弟节点</li>
<li><strong>叔父 (uncle):</strong> 父结点的兄弟结点为该结点的叔父结点</li>
<li><strong>堂兄弟:</strong> 父结点在同一层的结点互为堂兄弟</li>
</ul>
</dd>
<dt>路径 (path)</dt>
<dd>结点 \(n_{1}, n_{2}, \cdots, n_{k}\) 的一个序列，使得对于 \(1 \leq i &lt; k\) 满足 \(n_{i}\) 是 \(n_{i + 1}\) 的 parent，则这个序列被称为从 \(n_{1}\) 到结点 \(n_{k}\) 的 path。其路径长度 (length) 为路径上的 edge 的数量，即 \(k - 1\) 。特别地，每个结点到自己的 path lenth 为 <code>0</code></dd>
<dt>深度 (depth)</dt>
<dd>对于结点 \(n_{i}\) ，从 root 到 \(n_{i}\) 的唯一路径的长度 (\(Depth_{root} = 0\))</dd>
<dt>高度 (height)</dt>
<dd>对于结点 \(n_{i}\) ，从 \(n_{i}\) 到 leaf 的最长路径长度 (\(Height_{leaf} = 0\))</dd>
<dt>树的高度</dt>
<dd>或称树的深度，其总是等于根的高度，或最深的结点的深度，可以认为一棵空树的高度为 \(-1\)</dd>
<dt>祖先 (ancestor)</dt>
<dd>对于结点 \(n_{i}\) 与 \(n_{j}\) 存在一条 \(n_{i}\) 到 \(n_{j}\) 的路径，那么称 \(n_{i}\) 是 \(n_{j}\) 的祖先 (ancestor)，而 \(n_{j}\) 是 \(n_{i}\) 的 <strong>后裔</strong> (descendant)</dd>
<dt>距离 (distance)</dt>
<dd>对于结点 \(n_{i}\) 与 \(n_{j}\) ，从最近的公共祖先结点 \(n_{k}\) 分别到它们的路径长度之和被称为距离 (distance)。特别地，如果 \(n_{i} = n_{k}\) ，则 \(n_{i}\) 与 \(n_{j}\) 的距离为 \(n_{i}\) 到 \(n_{j}\) 的路径的长度</dd>
</dl>
<figure><img src="/images/algo-tree-example.svg" width="80%">
</figure>

<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">严蔚敏老师的数据结构中，或者往常的实现中，根的高度为 1，而叶的深度也为 1，树的高度一般指其最大的层次，因此认为空树的高度为 0。</div>
        </div>
    </div>
<h3 id="树的实现" class="headerLink">
    <a href="#%e6%a0%91%e7%9a%84%e5%ae%9e%e7%8e%b0" class="header-mark"></a>树的实现</h3><p>实现树的一种方法是在每一个结点上，除数据外还需要一些链域来指向该结点的每个子结点，然而由于每个结点的子结点数量是不确定的，我们不能直接建立到各个子结点的直接链接。如果申请一定大小的空间以存放子结点，则可能会造成空间的浪费，或不足。因此我们链表的形式存储子结点，而父结点中只存储第一个子结点的指针，如果该链域为空则意味着该结点是叶结点 (\(degree = 0\))。每个结点中存在一个指向其下一个兄弟的指针，为遍历父结点的所有孩子提供了方法，当该结点 \(next\_sibling = nullptr\) 时意味着这是父结点的最后一个子结点。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_003_tree_structure/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/binarytree/">BinaryTree</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_002_linear_data_structure/">线性数据结构</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-16">08-16</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><blockquote>
<p>Should array indices start at 0 or 1? My compromise of 0.5 was rejected without,
I thought, proper consideration.</p>
<p>&mdash; Stan Kelly-Bootle</p>
</blockquote>
<h2 id="表--list" class="headerLink">
    <a href="#%e8%a1%a8--list" class="header-mark"></a>表 (List)</h2><p>我们将形如 \(a_0, a_1, a_2, \cdots, a_{N-1}\) 组成的有限序列称为 list，这个 list 的大小是 \(N (N \in \mathbb{N})\) ，我们将大小为 0 的表称之为 <strong>空表</strong> (empty list)。</p>
<p>除空表外的任何表，我们从 <code>0</code> 开始标记元素，最后一个元素的下标为 \(N - 1\) ，那么第
\(i (i \in \mathbb{N}^{*})\) 个元素是 \(a_{i-1}\) ，称 \(a_{i}\) 是 \(a_{i + 1}\) 的 <strong>前驱</strong> ，
\(a_{i}\) 是 \(a_{i - 1}\) 的 <strong>后继</strong> 。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_002_linear_data_structure/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/list/">List</a>,&nbsp;<a href="/tags/stack/">Stack</a>,&nbsp;<a href="/tags/queue/">Queue</a>,&nbsp;<a href="/tags/string/">String</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/data_strucures_and_algorithm_analysis_001_introduction/">数据结构与算法分析引论</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-15">08-15</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href=""><i class="far fa-folder fa-fw"></i></a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><i class="far fa-list-alt fa-fw"></i>数据结构与算法分析</a></span></div><div class="content"><blockquote>
<p>I will, in fact, claim that the difference between a bad programmer and a good
one is whether he considers his code or his data structures more important. Bad
programmers worry about the code. Good programmers worry about data structures
and their relationships.</p>
<p>&mdash; Linus Torvalds</p>
</blockquote>
<h2 id="基本的数学知识" class="headerLink">
    <a href="#%e5%9f%ba%e6%9c%ac%e7%9a%84%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86" class="header-mark"></a>基本的数学知识</h2><p>首先我们需要复习一些在初高中可能学过的基础数学知识。</p>
<h3 id="集合" class="headerLink">
    <a href="#%e9%9b%86%e5%90%88" class="header-mark"></a>集合</h3><p><strong>集合</strong> (Set) 是基本的数学概念，指具体的某种性质的事物的总体，集合中的事物称之为
<strong>元素</strong> (element)。</p>
<p>element 通常使用小写字母表示，而 set 通常使用大写字母表示。若 \(x\) 是集合 \(A\) 中的元素，记作 \(x \in A\) ；反之不在集合中记作 \(x \notin A\) 。当两个 set 中所包含的
element 完全一样时，就称这两个 set 相等，记作 \(A = B\) 。</p></div><div class="post-footer">
        <a href="/2021/data_strucures_and_algorithm_analysis_001_introduction/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/operatingsystem_005/">死锁</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="08-06">08-06</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/operatingsystem/"><i class="far fa-folder fa-fw"></i>OperatingSystem</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/operating-system-note/"><i class="far fa-list-alt fa-fw"></i>Operating System Note</a></span></div><div class="content"><p>计算机中有很多独占 resource，在任一时刻它们只能被一个进程使用，因此 OS 需要授权一个进程临时地、排他地访问某一 resource 的能力。一般进程会排他性地访问若干资源，假设进程 A 在先使用扫描仪的情况请求蓝光光盘刻录机，而进程 B 在先使用蓝光光盘刻录机的情况下请求扫描仪，由于两个进程都占有一定 resouce 且不会释放，并且互相请求了对方的 Resource，而造成这两个进程无限阻塞下去，这样的状态被称为 <strong>死锁</strong>
(deadlock)。请不要单纯理解只有一台机器才会产生 deadlock，在多台机器同时访问局域网下的多个独占 resource 时也可能发生。</p>
<h2 id="资源" class="headerLink">
    <a href="#%e8%b5%84%e6%ba%90" class="header-mark"></a>资源</h2><p>我们将需要排他访问的对象称为 <strong>资源</strong> (resource)，资源可以是硬件设备或一组信息，通常有多种资源同时存在，且一些类型的资源存在若干实例 (打印店在同一局域网下会存在多台打印机)。</p>
<p>还记得学习进程与线程时所说的，scheduling algorithm 分为两类： <strong>抢占式</strong>
(preemptable) 与 <strong>非抢占式</strong> (nonpreemptable)，这里我们也将 resource 分为这两类，且意义相同。比如说 RAM 就是 preemptable resource，一个进程可以在使用时被 OS 换出
RAM；而蓝光刻录机则是 nonpreemptable resource，将正在刻录的蓝光刻录机分配给另一个进程可能造成蓝光光盘的损坏。不过需要思考一个问题，如果这台计算机不支持交换和页面调度，那么内存也就变为了 nonpreemptable resource。因此区分 preemptable /
nonpreemptable resource 取决于上下文环境。</p>
<p>preemptable resource 的 deadlock 可以通过 resource 的重新配分而化解，因此
deadlock 主要与 nonpreemptable resource 有关。若 resource 变得不可用，则请求进程将不可用，有的 OS 在这时会阻塞该进程，直到 resource 可用时再次唤醒；有些 OS 则会返回一个错误代码，请求进程自己处理这个错误。但是大部分进程会选择请求、休眠、再请求的方式进行循环，这与被阻塞没什么两样，因此假设 OS 在 resource 不可用时阻塞进程。</p></div><div class="post-footer">
        <a href="/2021/operatingsystem_005/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/concurrency/">Concurrency</a>,&nbsp;<a href="/tags/deadlock/">Deadlock</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/operatingsystem_004/">输入输出</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="07-25">07-25</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/operatingsystem/"><i class="far fa-folder fa-fw"></i>OperatingSystem</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/operating-system-note/"><i class="far fa-list-alt fa-fw"></i>Operating System Note</a></span></div><div class="content"><p>除了提供抽象外，操作系统还要控制计算机的所有 IO (输入/输出) 设备，必须向设备发送命令、捕获中断并处理设备的各种错误。它还应该在设备和其他部分之间提供简单且易于使用的接口，且这些接口应该尽可能的对所有设备都相同，即设备无关。</p>
<h2 id="单位" class="headerLink">
    <a href="#%e5%8d%95%e4%bd%8d" class="header-mark"></a>单位</h2><p>在进行本篇之前，需要明确一下计算机领域常用单位，只有统一了单位，我们才能更好的交流。</p>
<p>计算机领域以 bit (b，位) 和 byte (B，字节) 作为基本单位，bit 是只能表示 1 或 0
的单位数据，\(1 \texttt{Byte} = 8 \texttt{bit}\)，即 1 Byte 可以表示 256 种不同的状态。另外在 IO 传输数据时，最常用的单位即 <strong>比特率</strong> (单位：bit/s 或 bps)，即每秒传输的 bit 数量，当然也可以对其进行除以 8 运算转变为 <code>Byte/s</code>。</p>
<p>传统单位以 <a href="https://en.wikipedia.org/wiki/Metric_prefix" target="_blank" rel="noopener noreferrer">SI</a> (10 进制) 前缀为词头，而计算机领域多以 <a href="https://en.wikipedia.org/wiki/Binary_prefix" target="_blank" rel="noopener noreferrer">IEC 60027</a> (2 进制) 前缀为词头。一般内存与 CD 使用 IEC-60027 词头，而磁盘、闪存、DVD 常用 SI 词头表示容量。至于 Windows 系统对于容量的显示问题，内部转换为 IEC-60027 但显示的词头却是 SI，这也是历史原因所造成的。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">词头</th>
          <th style="text-align: left">prefix</th>
          <th style="text-align: left">符号</th>
          <th style="text-align: left">\(10^{n}\)</th>
          <th style="text-align: left">prefix</th>
          <th style="text-align: left">符号</th>
          <th style="text-align: left">\(2^{n}\)</th>
          <th style="text-align: left">\(16^{n}\)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">尧</td>
          <td style="text-align: left">yotta</td>
          <td style="text-align: left">Y</td>
          <td style="text-align: left">\(10^{24}\)</td>
          <td style="text-align: left">yobi</td>
          <td style="text-align: left">Yi</td>
          <td style="text-align: left">\(2^{80}\)</td>
          <td style="text-align: left">\(16^{20}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">泽</td>
          <td style="text-align: left">zetta</td>
          <td style="text-align: left">Z</td>
          <td style="text-align: left">\(10^{21}\)</td>
          <td style="text-align: left">zebi</td>
          <td style="text-align: left">Zi</td>
          <td style="text-align: left">\(2^{70}\)</td>
          <td style="text-align: left">\(16^{17.5}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">艾</td>
          <td style="text-align: left">exa</td>
          <td style="text-align: left">E</td>
          <td style="text-align: left">\(10^{18}\)</td>
          <td style="text-align: left">exbi</td>
          <td style="text-align: left">Ei</td>
          <td style="text-align: left">\(2^{60}\)</td>
          <td style="text-align: left">\(16^{15}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">拍</td>
          <td style="text-align: left">peta</td>
          <td style="text-align: left">P</td>
          <td style="text-align: left">\(10^{15}\)</td>
          <td style="text-align: left">pebi</td>
          <td style="text-align: left">Pi</td>
          <td style="text-align: left">\(2^{50}\)</td>
          <td style="text-align: left">\(16^{12.5}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">太</td>
          <td style="text-align: left">tera</td>
          <td style="text-align: left">T</td>
          <td style="text-align: left">\(10^{12}\)</td>
          <td style="text-align: left">tebi</td>
          <td style="text-align: left">Ti</td>
          <td style="text-align: left">\(2^{40}\)</td>
          <td style="text-align: left">\(16^{10}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">吉</td>
          <td style="text-align: left">giga</td>
          <td style="text-align: left">G</td>
          <td style="text-align: left">\(10^{9}\)</td>
          <td style="text-align: left">gibi</td>
          <td style="text-align: left">Gi</td>
          <td style="text-align: left">\(2^{30}\)</td>
          <td style="text-align: left">\(16^{7.5}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">兆</td>
          <td style="text-align: left">mega</td>
          <td style="text-align: left">M</td>
          <td style="text-align: left">\(10^{6}\)</td>
          <td style="text-align: left">mebi</td>
          <td style="text-align: left">Mi</td>
          <td style="text-align: left">\(2^{20}\)</td>
          <td style="text-align: left">\(16^{5}\)</td>
      </tr>
      <tr>
          <td style="text-align: left">千</td>
          <td style="text-align: left">kilo</td>
          <td style="text-align: left">k</td>
          <td style="text-align: left">\(10^{3}\)</td>
          <td style="text-align: left">kibi</td>
          <td style="text-align: left">Ki</td>
          <td style="text-align: left">\(2^{10}\)</td>
          <td style="text-align: left">\(16^{2.5}\)</td>
      </tr>
  </tbody>
</table>
<h2 id="io-硬件原理" class="headerLink">
    <a href="#io-%e7%a1%ac%e4%bb%b6%e5%8e%9f%e7%90%86" class="header-mark"></a>IO 硬件原理</h2><p>对于不同角度观察的人，IO 硬件的理解是不同的。对于电子工程师而言，IO 硬件就是芯片、导线、电源、电机和其他组成硬件的物理部件。对程序员而言，则只注意 IO 硬件提供给软件的接口，如硬件能够接收的命令、实现的功能以及能够报告的错误。因此这里所描述的
IO 设备仅限于对硬件的编程，而非其内部工作原理。</p></div><div class="post-footer">
        <a href="/2021/operatingsystem_004/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/iuputoutput/">IuputOutput</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/operatingsystem_003/">文件系统</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="07-19">07-19</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/operatingsystem/"><i class="far fa-folder fa-fw"></i>OperatingSystem</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/operating-system-note/"><i class="far fa-list-alt fa-fw"></i>Operating System Note</a></span></div><div class="content"><p>对于长期存储的信息有三个基本要求：</p>
<ol>
<li>能够存储大量信息</li>
<li>使用信息的进程终止时，信息依旧存在</li>
<li>必须能使多个进程并发访问相关信息</li>
</ol>
<p>磁盘由于其长期存储的性质，已有多年的使用历史。今年固态硬盘因其没有易损坏的移动部件、可以提供高速的随即访问，而流行起来。但磁盘和光盘虽然性能较差但也广泛用于备份。磁盘可以看做一种大小固定的块的线性序列，且支持：</p>
<ol>
<li>读块 k</li>
<li>写块 k</li>
</ol>
<p>磁盘一般支持更多操作，但只要存在这两个操作，原则上就可以解决长期存储问题。当然这还远远不够，一些操作不便于实现，在思考时往往还产生一些问题：</p>
<ol>
<li>如何找到信息</li>
<li>如何防止一个用户读取另一个用户的数据</li>
<li>如何知道哪些块是空闲的</li>
</ol>
<p>就像 OS 提取处理器的概念来创建进程的抽象，以及提取 RAM 的概念来创建进程虚拟地址空间的抽象一样，使用 <strong>文件</strong> (File) 来解决磁盘的问题。File 是 <strong>进程创建的信息逻辑单元</strong>，文件是对磁盘的建模而非 RAM，因此将文件看做地址空间就能理解了。</p>
<p>进程可以读取已存在的 File，并在需要时建立新 File，存储的文件必须是持久的，因此不会受到进程的创建与终止而受到影响，只有在其所有者明确删除它的情况下才会消失。File
受操作系统管理，有关的构造、命名、访问、使用、保护、实现和管理方法都是 OS 设计的主要内容。从总体上看，OS 处理文件的部分被称为 <strong>文件系统</strong> (file system)，这才是
OS 的核心问题之一。从用户的角度看，File System 中最重要的就是其表现形式，即文件由什么组成的，如何命名、修改等操作。至于如何实现，和我这个用户有什么关系呢。</p>
<h2 id="文件" class="headerLink">
    <a href="#%e6%96%87%e4%bb%b6" class="header-mark"></a>文件</h2><p>首先先从用户的角度观察文件，文件是对磁盘上保存信息的一种抽象，用户不必关心磁盘如何存储、存储到哪里、实际的工作方式等细节。</p>
<p>文件系统是实现这些细节的程序，在 MS-DOS 中使用的是 <code>FAT-16</code> 文件系统，Windows98
对其进行了扩展，从而成为今天耳熟能详的 <code>FAT-32</code> 文件系统，Windows 如今是用一种更为先进的 <code>NTFS</code> 文件系统。微软还根据 FAT 文件系统开发出了 <code>exFAT</code> ，这是针对于闪存和大文件开发的系统，并且也是唯一能满足 OS X 读写操作的微软开发的文件系统。UNIX
的文件系统也有很多，目前主流的是 Linux 的 <code>ext4</code> (其是 ext2 和 ext3 的升级版本)、
Solaris 的 <code>ZFS</code> 、Unix 传统的 <code>FFS</code> 以及 OS X 的 <code>HFS+</code> 等，还有一些著名公司如
SGI 开发的 <code>XFS</code> 、RedHat 主导的 <code>BtrFS</code> 等。这些文件系统可能底层实现、适用环境不同，但大部分都遵循 POSIX 实现，对用户操作来说是透明的。</p></div><div class="post-footer">
        <a href="/2021/operatingsystem_003/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/filesystem/">FileSystem</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/operatingsystem_002/">内存管理</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="07-14">07-14</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/operatingsystem/"><i class="far fa-folder fa-fw"></i>OperatingSystem</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/operating-system-note/"><i class="far fa-list-alt fa-fw"></i>Operating System Note</a></span></div><div class="content"><p>内存 (随机访问存储器，RAM) 是计算机中一种需要认真管理的重要资源。不管存储器有多大，程序都能把它填满。经过多年的探索，我们有了 <strong>分层存储器体系</strong> (memory
hierarchy) 的概念，即计算机拥有若干 MiB 快速、昂贵且易失性的 Cache，数 GiB 速度与价格适中的易失性内存，以及数 TiB 快速、廉价但非易失性的磁盘存储。计算机中管理分层存储器体系的部分被称为 <strong>存储管理器</strong> (memory manager)。它的任务是有效地管理内存，记录哪些内存正在使用，哪些内存是空闲的，在进程需要时为其分配内存，在进程使用完后释放内存。</p>
<h2 id="无存储器抽象" class="headerLink">
    <a href="#%e6%97%a0%e5%ad%98%e5%82%a8%e5%99%a8%e6%8a%bd%e8%b1%a1" class="header-mark"></a>无存储器抽象</h2><p>最简单的存储器抽象是不使用抽象。早期的大型机 (60 年代以前)、小型机 (70 年代以前)
以及个人计算机 (80 年代以前) 都是没有存储器抽象的，每一个程序都直接访问物理内存，这种模型中系统每次仅运行一个进程。</p>
<p>虽然直接使用物理内存，但还是有不同的模型，下图展示了三种模型。a 模型中操作系统位于 RAM 底部，这种模型曾被用于大型机与小型机；b 模型中操作系统位于内存顶端的 ROM
(只读存储器) 中，这种模型被用于掌上电脑或嵌入式系统中；c 模型中设备驱动程序位于顶部的 ROM 中，而操作系统的其他部分位于 RAM 的底部，该方案被用于早期的个人计算机中 (如运行 MS-DOS 的计算机)，在 ROM 中的系统部分被称为 BIOS (基本输入输出系统，
Basic Input Output System)。a 和 c 模型当用户程序出错时，可能会摧毁操作系统，引发灾难性后果。</p>
<figure><img src="/images/no-abstract-memory-manager.svg">
</figure>

<p>在无存储器抽象的系统中实现并行的方法是采用多线程编程。由于引入线程时假设一个进程中的所有线程对同一内存映像都可见，如此实现并行也就不是问题。虽然方法行得通，但没有被广泛使用，因为人们通常希望能够在同一时间运行没有关联的程序，而这正是线程抽象所不能提供的。因此一个无存储器抽象的系统也不大可能提供线程抽象的功能。</p>
<p>由于使用无存储器抽象时并发进程，可以在一个进程运行一段时间后，从磁盘中加载其他进程到 RAM 中。但由于两个进程都引用的绝对地址，因此可能会引用到第一个进程的私有地址，导致进程崩溃。IBM 360 对上述问题的补救方案就是在第二个进程装载到内存的时候，使用静态重定位的技术修改它。</p>
<h2 id="一种存储器抽象-地址空间" class="headerLink">
    <a href="#%e4%b8%80%e7%a7%8d%e5%ad%98%e5%82%a8%e5%99%a8%e6%8a%bd%e8%b1%a1-%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4" class="header-mark"></a>一种存储器抽象：地址空间</h2><p>当物理地址暴露给进程会带来下面一些严重问题：</p>
<ol>
<li>如果用户程序可以寻址内存的每个字节，它们就可以很容易地 (故意地或偶然地) 破坏操作系统，从而使整个系统慢慢地停止运行，除非有特殊的硬件保护 (IBM 360 的锁键模式)</li>
<li>使用这种模型，想要同时运行多个程序是很困难的</li>
</ol>
<h3 id="地址空间的概念" class="headerLink">
    <a href="#%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e7%9a%84%e6%a6%82%e5%bf%b5" class="header-mark"></a>地址空间的概念</h3><p>要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题：<strong>保护</strong> 和 <strong>重定位</strong> 。</p></div><div class="post-footer">
        <a href="/2021/operatingsystem_002/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/memory/">Memory</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/2021/operatingsystem_001/">进程与线程</a>
    </h1><div class="post-meta">
        <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="07-11">07-11</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/operatingsystem/"><i class="far fa-folder fa-fw"></i>OperatingSystem</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/operating-system-note/"><i class="far fa-list-alt fa-fw"></i>Operating System Note</a></span></div><div class="content"><h2 id="进程" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b" class="header-mark"></a>进程</h2><p>进程 (Process) 是操作系统中的核心概念，是对正在运行的程序的抽象。即使只有一个可用的 CPU，也可以启动多个进程，让操作系统具有并发能力。</p>
<h3 id="进程模型" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e6%a8%a1%e5%9e%8b" class="header-mark"></a>进程模型</h3><p>一个进程就是一个正在执行的程序实例，每个进程都拥有一个自己的虚拟 CPU、程序计数器、寄存器、内存地址空间等，这些是一个进程私有的，不可被其他进程所访问、修改，真正的
CPU 在各个进程之间来回切换。</p>
<p>假设现在有 4 个程序，它们在运行时装入自己虚拟的程序计数器、寄存器，并有物理 CPU
运行程序。当程序被切换时，物理程序计数器等数据被保存到内存中。在观察足够长的时间时，所有的进程都运行了，但每个瞬间仅有一个程序在执行。需要注意的是，如果一个程序运行了两遍，那将被算作两个进程。</p>
<p>进程的核心思想即：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</p>
<p>当进程创建了一个新进程后，其被称为父进程，新进程被称为子进程，这些进程组成了层次结构。在 UNIX 中一个称为 init 的特殊进程出现在启动映像中，init 运行时读入终端数量的文件，并为每一个终端创建一个新进程。这些终端等待用户登陆，登陆成功时便会执行
shell 进程来接收用户命令。整个系统中，所有进程都属于以 init 为根的进程树。
Windows 中没有层次结构概念，所有进程地位相同。创建进程时父进程得到 <strong>句柄</strong> 用于控制子进程，但也可以将句柄传送给其他进程。</p>
<h3 id="进程的创建与终止" class="headerLink">
    <a href="#%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%88%9b%e5%bb%ba%e4%b8%8e%e7%bb%88%e6%ad%a2" class="header-mark"></a>进程的创建与终止</h3><p>操作系统往往需要一种方式来创建进程，一般由 4 种主要事件来创建进程：</p>
<ol>
<li>系统初始化</li>
<li>正在运行的程序执行了创建进程的系统调用 (syscall)</li>
<li>用户请求创建新进程</li>
<li>批处理作业的初始化</li>
</ol>
<p>新进程都是由于一个已存在的进程执行了一个用于创建进程的 syscall 用而创建的。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序。</p>
<p>在 UNIX 系统，往往采用 syscall <code>fork</code> 来创建一个与调用进程相同的副本。调用成功后，两个进程拥有相同的内存映像、相同的环境字符串与打开文件。通常子进程执行 <code>exec</code> 系列 syscall 来修改其内存映像，并运行一个新程序。在执行 <code>exec</code> 之前，允许子进程处理其文件描述符等操作。</p>
<p>UNIX 中子进程的初始地址空间是父进程的一个副本，但是两个不同的地址空间，不可写的部分则是共享的。而某些 UNIX 实现中，子进程共享父进程的所有内存，内存通过 <strong>写时复制</strong> (Copy-On-Write, COW) 技术实现共享，即当两者之一修改内存时，这块内存被明确的复制，以保证修改发生在进程的私有区域。</p>
<p>进程在创建之后开始运行，完成其工作，进程可能在未来的某个时刻完成任务并被终止。通常终止进程由以下条件引起：</p>
<ol>
<li>正常退出 (自愿)</li>
<li>错误退出 (自愿)</li>
<li>严重错误 (非自愿)</li>
<li>被其他进程杀死 (非自愿)</li>
</ol>
<p>前两种即进程自己所处理的终止，完成工作或者在运行时遇到了一些可处理的错误，这时进程通过 <code>exit</code> 调用终止，并向父进程返回状态值。</p></div><div class="post-footer">
        <a href="/2021/operatingsystem_001/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/process/">Process</a>,&nbsp;<a href="/tags/thread/">Thread</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/4/">4</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/5/">5</a>
                    </span>
                </li></ul></div></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.134.2">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.3.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank" rel="noopener noreferrer">GinShio</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/katex/katex.min.bcaaee8fe6b5dd4f321c8900c8680ad49dc0ad32f3ac51816c1734b43a7869dfc4c9ec0449e5c4fc8bfaec08fc80a674.css" integrity="sha384-vKruj&#43;a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"data":{"id-1":"過去一直去，未來一直來，只有現在……"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"ABF13CGNA0","algoliaIndex":"ginshio_blog","algoliaSearchKey":"51cf3425aba132c091b477c3d5e06eea","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"sharerjs":true,"table":{"sort":true},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/lib/tablesort/tablesort.min.d120034e53740430f5243f8e25b646e7bdcca97780e02962c37e3adefb264c1b457f8fc397698851f42e32d7168bdd1e.js" integrity="sha384-0SADTlN0BDD1JD&#43;OJbZG573MqXeA4Cliw3463vsmTBtFf4/Dl2mIUfQuMtcWi90e"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/typeit/typeit.min.14cdb050c8a3046875884e15b60fa92f6d70fc894f4cd51f453bc7bc96bee1a2f336e328b7ed68b5b61091aee9996b2d.js" integrity="sha384-FM2wUMijBGh1iE4Vtg&#43;pL21w/IlPTNUfRTvHvJa&#43;4aLzNuMot&#43;1otbYQka7pmWst"></script><script type="text/javascript" src="/lib/katex/katex.min.3f04544ff62a6e71239193b4cd9c4da9cc400ab5defa3efae94d9a997720320e78e7baef7b663b23a6494a6d80d264b8.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe&#43;j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f95071777afa5e0511c9caad675d7b9d8c38e0e39c21ac79e99e1d09159bc723edd0aa1a875b87a0ad28e3efd1444d39.js" integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.c30ff9f376878715a4cf90c4567e8e2ad36221a2e2da20513595df251898d408bbb6727d517a44b32bce2135694e5e00.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.453374f1ad005c88a83c1715a2c12a3d47ca2beacfa7e875c7f8b347bc4c91d332bb091c64259dc4ef914b0205b495cd.js" integrity="sha384-RTN08a0AXIioPBcVosEqPUfKK&#43;rPp&#43;h1x/izR7xMkdMyuwkcZCWdxO&#43;RSwIFtJXN" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-J5NHMZLLDX', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-J5NHMZLLDX" async></script><script>
			var _hmt = _hmt || [];
			(function() {
			  var hm = document.createElement("script");
			  hm.src = "https://hm.baidu.com/hm.js?9370523af547bac6b97e9c3b1461cd16";
			  var s = document.getElementsByTagName("script")[0]; 
			  s.parentNode.insertBefore(hm, s);
			})();
		</script></div>
</body>

</html>