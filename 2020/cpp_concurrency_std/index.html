<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>并发标准库 - iris</title><meta name="Description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"><meta property="og:title" content="并发标准库" />
<meta property="og:description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.ginshio.org/2020/cpp_concurrency_std/" /><meta property="og:image" content="https://blog.ginshio.org/avatar.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-01T19:42:25+08:00" />
<meta property="article:modified_time" content="2022-04-07T19:30:06+08:00" /><meta property="og:site_name" content="iris | GinShio的个人博客" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.ginshio.org/avatar.webp"/>

<meta name="twitter:title" content="并发标准库"/>
<meta name="twitter:description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"/>
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2020/cpp_concurrency_std/" /><link rel="prev" href="https://blog.ginshio.org/2020/mail_server/" /><link rel="next" href="https://blog.ginshio.org/2020/cpp_concurrency_atomic/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/style.min.cd14de6b7577483a378a3e7b1d8d4d22e9116704e99988548443184415b6e7ea3d5f86d181e92e8d979297f4dc91299a.css" integrity="sha384-zRTea3V3SDo3ij57HY1NIukRZwTpmYhUhEMYRBW25&#43;o9X4bRgekujZeSl/TckSma"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <meta name="google-site-verification" content="fbzw9fQcZyEFrrrUtxLfzYW-qhZ5TMEZKHHSp9NeLBw" /><meta name="msvalidate.01" content="EC9CEC799D42793C414AE7BDB0D0205C" /><meta name="yandex-verification" content="c0b808dd3e49f730" /><meta name="baidu-site-verification" content="code-RhPhu2ccLc" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "并发标准库",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2020\/cpp_concurrency_std\/"
        },"image": ["https:\/\/blog.ginshio.org\/screenshot.png"],"genre": "posts","keywords": "Note, C\u002b\u002b, Concurrency, Library","wordcount":  7118 ,
        "url": "https:\/\/blog.ginshio.org\/2020\/cpp_concurrency_std\/","datePublished": "2020-12-01T19:42:25+08:00","dateModified": "2022-04-07T19:30:06+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/avatar.webp"},"authors": [{
                        "@type": "Person",
                        "name": "GinShio"                    
                    }],"description": "GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark');}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#线程管理">线程管理</a>
      <ul>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#传递参数">传递参数</a></li>
        <li><a href="#线程标识">线程标识</a></li>
      </ul>
    </li>
    <li><a href="#共享数据">共享数据</a>
      <ul>
        <li><a href="#条件竞争">条件竞争</a></li>
        <li><a href="#互斥量">互斥量</a>
          <ul>
            <li><a href="#死锁">死锁</a></li>
            <li><a href="#灵活的管理锁">灵活的管理锁</a></li>
          </ul>
        </li>
        <li><a href="#保护共享数据的方式">保护共享数据的方式</a>
          <ul>
            <li><a href="#保护共享数据的初始化过程">保护共享数据的初始化过程</a></li>
            <li><a href="#保护不常更新的数据结构">保护不常更新的数据结构</a></li>
            <li><a href="#重入锁">重入锁</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#同步操作">同步操作</a>
      <ul>
        <li><a href="#等待条件">等待条件</a></li>
        <li><a href="#future">future</a>
          <ul>
            <li><a href="#异步返回值">异步返回值</a></li>
            <li><a href="#绑定任务">绑定任务</a></li>
            <li><a href="#promise">Promise</a></li>
          </ul>
        </li>
        <li><a href="#限时等待">限时等待</a>
          <ul>
            <li><a href="#时钟">时钟</a></li>
            <li><a href="#时间段">时间段</a></li>
            <li><a href="#时间戳">时间戳</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">并发标准库</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://blog.ginshio.org/authors/ginshio'>GinShio</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/programminglanguage/"><i class="far fa-folder fa-fw"></i>ProgrammingLanguage</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/c++-%E5%B9%B6%E5%8F%91/"><i class="far fa-list-alt fa-fw"></i>C++ 并发</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="12-01">12-01</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="04-07">04-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7118 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
        </div><div class="details series-nav open">
                                <div class="details-summary series-title">
                                    <span>系列 - C&#43;&#43; 并发</span>
                                    <span><i class="details-icon fas fa-angle-right"></i></span>
                                </div>
                                <div class="details-content series-content">
                                    <nav>
                                        <ul><li><span class="active">并发标准库</span></li>
                                                    <li><a href="/2020/cpp_concurrency_atomic/">原子操作</a></li></ul>
                                    </nav>
                                </div>
                            </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#线程管理">线程管理</a>
      <ul>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#传递参数">传递参数</a></li>
        <li><a href="#线程标识">线程标识</a></li>
      </ul>
    </li>
    <li><a href="#共享数据">共享数据</a>
      <ul>
        <li><a href="#条件竞争">条件竞争</a></li>
        <li><a href="#互斥量">互斥量</a>
          <ul>
            <li><a href="#死锁">死锁</a></li>
            <li><a href="#灵活的管理锁">灵活的管理锁</a></li>
          </ul>
        </li>
        <li><a href="#保护共享数据的方式">保护共享数据的方式</a>
          <ul>
            <li><a href="#保护共享数据的初始化过程">保护共享数据的初始化过程</a></li>
            <li><a href="#保护不常更新的数据结构">保护不常更新的数据结构</a></li>
            <li><a href="#重入锁">重入锁</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#同步操作">同步操作</a>
      <ul>
        <li><a href="#等待条件">等待条件</a></li>
        <li><a href="#future">future</a>
          <ul>
            <li><a href="#异步返回值">异步返回值</a></li>
            <li><a href="#绑定任务">绑定任务</a></li>
            <li><a href="#promise">Promise</a></li>
          </ul>
        </li>
        <li><a href="#限时等待">限时等待</a>
          <ul>
            <li><a href="#时钟">时钟</a></li>
            <li><a href="#时间段">时间段</a></li>
            <li><a href="#时间戳">时间戳</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="线程管理" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b%e7%ae%a1%e7%90%86" class="header-mark"></a>线程管理</h2><h3 id="创建线程" class="headerLink">
    <a href="#%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b" class="header-mark"></a>创建线程</h3><p>新的线程会在 <code>::std::thread</code> (头文件 <em>thread</em> 中) 对象创建的时候被启动，在函数执行完毕后，该线程也就结束了，提供的函数对象会复制到新线程的存储空间中，函数对象的执行与操作都在线程的内存空间中执行。在创建新线程时你可以指定一个函数作为任务，或者是 <strong>仿函数</strong>​，当然也可以是 lambda 表达式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread0</span><span class="p">{</span><span class="n">do_something</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread1</span><span class="p">{</span><span class="n">Task</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread2</span><span class="p">{[]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程启动后，需要指定是​<code>等待线程结束</code>​还是​<code>让其自主运行</code>​，如果 <code>::std::thread</code> 对象销毁之前没有做出决定，程序就会终止，因此必须确保线程能够正确 <strong>汇入</strong>​ (joined)
或 <strong>分离</strong> (detached)。调用 join() 可以等待线程完成，并在线程结束时清理相关的内存，使 ::std::thread 对象不再与已完成线程有任何关联，所以一个线程一旦被汇入将不能再次汇入。调用 detach() 会使线程在后台运行，不再与主线程进行直接交互， ::std::thread
对象不再引用这个线程，分离的线程也不可被再次汇入，不过C++运行时库保证线程退出时可以正确回收相关资源。</p>
<p>在C++中 ::std::thread 对象是一种 <strong>可移动但不可复制</strong> 的资源，它可以交出它的所有权，但不能与其他对象共享线程的所有权。如果你希望对一个已持有线程的对象更改其行为，那你必须先汇入或分离已关联的线程，或者将已关联的线程的所有权交出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{</span><span class="n">do_something</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{</span><span class="n">some_other_function</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">t3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// t1 = std::move(t3); // 错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="传递参数" class="headerLink">
    <a href="#%e4%bc%a0%e9%80%92%e5%8f%82%e6%95%b0" class="header-mark"></a>传递参数</h3><p>向线程中传递参数十分简单，为 ::std::thread 构造函数附加参数即可，所有参数 将会拷贝到新线程的内存空间中，即使函数中的参数是引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{</span><span class="n">f1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">}};</span>
</span></span><span class="line"><span class="cl"><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ::std::thread t2{f2, 2, ::std::string{&#34;Hello&#34;}}; // Error
</span></span></span><span class="line"><span class="cl"><span class="c1">// t2.join();
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里 f2 期望传入一个::std::string的引用，传递参数时会将拷贝的参数以右值的方式进行传递 (为了支持移动的类型)，与函数期望的非常量引用不符，故会在编译期报错。不过我们可以使用 <code>::std::ref</code> 将参数转换为引用的形式进行传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">{</span><span class="n">f2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl"><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当然也可以在一个线程上运行一个成员函数，做法也是很简单的，第一个参数传递成员函数的指针，第二个参数传递这个类的对象的指针，剩下的则是这个待运行的函数的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">{</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">do_something</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="线程标识" class="headerLink">
    <a href="#%e7%ba%bf%e7%a8%8b%e6%a0%87%e8%af%86" class="header-mark"></a>线程标识</h3><p>线程的标识类型是 <code>::std:🧵:id</code> ，可以使用 ::std::thread 对象的成员函数
<code>get_id()</code> 获取，当线程没有和任何执行线程关联时将返回默认值来表示 <strong>无线程</strong>; 也可以使用 <code>::std::this_thread::get_id()</code> 来获取当前线程的标识。​<code>::std:🧵:id</code> 对象可以拷贝或对比，因为标识符是可复用的，当两个标识符相等时代表​<strong>同一个线程</strong>​或这两个线程​<strong>无关联线程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">master_thread_id</span> <span class="o">==</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">master_do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">worker_do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="共享数据" class="headerLink">
    <a href="#%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae" class="header-mark"></a>共享数据</h2><p>涉及到共享数据时，问题就是因为共享数据的修改所导致，如果共享数据只读，那么不会影响到数据，更不会对数据进行修改，所有线程都会获得同样的数据。但当一个或多个线程要修改共享数据时，就会产生很多麻烦，需要小心谨慎，才能确保所有线程都正常工作。</p>
<h3 id="条件竞争" class="headerLink">
    <a href="#%e6%9d%a1%e4%bb%b6%e7%ab%9e%e4%ba%89" class="header-mark"></a>条件竞争</h3><p>并发中的竞争条件，取决于一个以上线程的执行顺序，每个线程都抢着完成自己的任务，大多数情况下，即使改变执行顺序，也是良性竞争，结果是可以接受的。遗憾的是，当不变量遭到破坏时会产生条件竞争，通常是恶性竞争：并发的去修改一个独立对象。恶性竞争时对一个数据块进行修改时，其他线程可能同时对其进行访问，导致数据不一致或与预期不符，并且出现概率低且难复现。</p>
<p>避免恶性竞争，最简单的方法就是对数据结构采用某种​<strong>保护机制</strong>​，确保只有修改线程可以看到不变量的中间状态，其他线程观察结构时会发现其修改还未开始。另一方式就是对数据结构与不变量进行修改，修改后的结构可以完成一系列不可分割的变量，从而保证不变量的状态，即​<strong>无锁编程</strong>​。</p>
<h3 id="互斥量" class="headerLink">
    <a href="#%e4%ba%92%e6%96%a5%e9%87%8f" class="header-mark"></a>互斥量</h3><p>访问共享数据前将数据锁住，在访问结束后再将数据解锁，当线程使用互斥量锁住共享数据时，其他的线程都必须等到之前那个线程对数据进行解锁后，才能进行访问数据。</p>
<p>通过实例化 <code>::std::mutex</code> (头文件 <em>mutex</em> 中) 创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁，不过不推荐使用成员函数，因为你必须在函数的出口处正确的解锁，其中包括异常情况也必须保证正确解锁，否则互斥量可能无法正常使用。推荐的做法是使用互斥量RAII模板类 <code>::std::lock_guard</code> (头文件 <em>mutex</em> 中)，构造时加锁并在析构时解锁，保证互斥量可以被正确的解锁。</p>
<p>下面例子中，如果多个线程访问add_n函数，那么互斥量mu就会保护变量 <code>result</code> ，在一个线程中修改它时其他线程将无法访问它， \(result += i\) 将会在线程中安全的执行，不会因为数据竞争导致线程看到的result脏值，从而污染结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add_n</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1ll</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过通常互斥量会与需要保护的数据封装在同一个类中，让它们联系在一起，保证数据不变量的稳定状态。不过当类中某个方法返回保护数据的指针或者引用时，可能会破坏数据，此时需要谨慎的对接口进行设计，切勿将受保护数据的指针或引用传递到互斥锁作用域之外。</p>
<p>使用互斥量保护数据时，还需要考虑接口间的条件竞争，比如常使用的 ::std::stack，以下代码在单线程中是正确的，但是当 ::std::stack 是共享数据时，虽然每次调用接口时内部可能返回正确的结果，但是当用户使用时可能并非安全的。很明显代码中，top() 调用时很可能其他线程已经 pop() 了最后一个元素，虽然该线程访问到栈不为空，但是 top() 获取到错误的结果，​<code>top()</code> 与 <code>pop()</code> 存在数据竞争关系</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>锁的粒度太小，恶性条件竞争已经出现，需要保护的操作并未全覆盖到; 如果锁的粒度太大，会抵消并发带来的性能提升。</p>
<h4 id="死锁" class="headerLink">
    <a href="#%e6%ad%bb%e9%94%81" class="header-mark"></a>死锁</h4><p>使用多个互斥量操作时需要注意 <strong>死锁</strong>​，这会让两个线程互相等待，直到另一个解锁互斥量。死锁产生的必要条件:</p>
<dl>
<dt>互斥条件</dt>
<dd>一个资源每次只能被一个任务使用</dd>
<dt>占有且等待</dt>
<dd>因请求资源而阻塞时，对已获得的资源保持不放</dd>
<dt>不可剥夺</dt>
<dd>已获得的资源，在末使用完之前，不能强行剥夺</dd>
<dt>循环等待条件</dt>
<dd>若干任务之间形成一种头尾相接的循环等待资源关系</dd>
</dl>
<p>一般在C++使用互斥量时，避免循环等待即可，对多个互斥量可以使用标准库中的
<code>::std::lock</code> 与 <code>::std::lock_guard</code> 进行RAII锁定，可以按照一定的顺序对互斥量进行锁定，避免循环锁定。以下代码展示了一次锁定多个互斥量，​::std::lock 锁定互斥量，并创建两个 ::std::lock_guard 对象对互斥量进行管理，​<code>::std::adopt_lock</code> 表示
::std::lock_guard 可以获取锁并将锁交给其管理，::std::lock_guard 对象不需要再构建新的锁。值得一提的是，::std::lock 可能会抛出异常，但是请放心，已锁定的锁会随着异常而自动释放，所以 ::std::lock 要么 <strong>全部锁住</strong> 要么 <strong>一个都不锁</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockl</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockr</span><span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C++17 中提供了RAII模板类 <code>::std::scoped_lock</code> (头文件 <em>mutex</em> 中) 用来支持这种情况，并且增加了 <strong>自动推导模板参数</strong>​，是所以这种情况在 C++17 中将会更简单的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">guard</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 等价于:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ::std::scoped_lock&lt;::std::mutex, ::std::mutex&gt; guard{lhs.mu, rhs.mu};
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>死锁通常是对锁的使用不当造成，当然也可以是其他情况，不过我们应该尽可能的避免死锁</p>
<dl>
<dt>避免嵌套锁</dt>
<dd>获取一个锁时就别再获取第二个，需要获取多个锁时应使用 ::std::lock
来完成</dd>
<dt>避免在持有锁时调用外部代码</dt>
<dd>代码是由外部提供的，我们无法确定外部的行为，可能会造成与第一条违反的情况</dd>
<dt>使用固定顺序获取锁</dt>
<dd>当有多个锁且无法使用 ::std::lock 时，应在每个线程上以固定的顺序获取锁</dd>
</dl>
<h4 id="灵活的管理锁" class="headerLink">
    <a href="#%e7%81%b5%e6%b4%bb%e7%9a%84%e7%ae%a1%e7%90%86%e9%94%81" class="header-mark"></a>灵活的管理锁</h4><p>标准库提供了一种灵活的RAII管理锁的方式 <code>::std::unique_lock</code> (头文件 <em>mutex</em> 中)，它允许使用 <code>::std::adopt_lock</code> 假设已拥有互斥的所有权，也允许使用
<code>::std::defer_lock</code> 假设不获取互斥的所有权，使用 ::std::unique_lock 会与
::std::lock_guard 的实现方式等价。::std::unique_lock 对象中带有标志来确定是否持有互斥量，并确保正确地在析构函数中处理互斥量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockl</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockr</span><span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lockl</span><span class="p">,</span> <span class="n">lockr</span><span class="p">);</span> <span class="c1">// 持有的互斥量并锁定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>::std::unique_lock 是一种可移动不可复制的类型，它可以交出已持有互斥量的所有权，使互斥量在不同作用域中传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">get_lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">extern</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">other</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">get_lock</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>::std::unique_lock 还支持在对象销毁之前放弃持有互斥，这样可以提前为其他等待线程释放锁，增加性能。</p>
<p>锁的粒度是用来描述锁保护的数据量的大小，​<strong>细粒度锁</strong> (fine-grained lock) 能够保护较小的数据量，​<strong>粗粒度锁</strong> (coarse-grained lock) 能够保护较多的数据量。比如数据库中，对一行进行锁定的锁比对整张表锁定的锁粒度小，行锁相对于表锁性能更高，因为可以同时处理多行，但是也更不安全。</p>
<h3 id="保护共享数据的方式" class="headerLink">
    <a href="#%e4%bf%9d%e6%8a%a4%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae%e7%9a%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>保护共享数据的方式</h3><h4 id="保护共享数据的初始化过程" class="headerLink">
    <a href="#%e4%bf%9d%e6%8a%a4%e5%85%b1%e4%ba%ab%e6%95%b0%e6%8d%ae%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e8%bf%87%e7%a8%8b" class="header-mark"></a>保护共享数据的初始化过程</h4><p>如果一个资源构造代价昂贵，我们可能会使用延迟初始化来构造它，不过这在单线程下是安全的，多线程下初始化是需要被保护的，不然可能会出现多次初始化的情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">lk</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>双重检测锁定模式 (DCLP) 也是一种保护初始化的状态，不过遗憾的是，它存在潜在的条件竞争，即线程可能得知其他线程完成了初始化，但可能没有看到新创建的实例，在调用
do_something()时得到不正确的结果。Java引入了volatile关键字并安全地实现了DCLP，
C++11开始我们也可以实现安全的DCLP。详细可以阅读 <a href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf" target="_blank" rel="noopener noreferrer">C++与双重检测锁定模式的风险</a>，我们也可以在之后的学习中学习安全的DCLP实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// DCLP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	    <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span> <span class="c1">// 数据竞争
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过我们可以不这么麻烦，C++标准库为我们提供了 <code>::std::once_flag</code> 与
<code>::std::call_once</code> (头文件 <em>mutex</em> 中) 来处理这种情况，并且相比使用互斥量所消耗的资源更少</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">once</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">once</span><span class="err">，</span><span class="p">[]()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">});</span>
</span></span><span class="line"><span class="cl">    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>局部作用域中的static变量在声明后就已经完成初始化，对于C++11之前初始化的过程中存在条件竞争，但是从 <strong>C++11</strong> 开始初始化与定义完全在一个线程中发生</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">element</span> <span class="nf">get_element_instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">element</span> <span class="n">instance</span><span class="p">;</span> <span class="c1">// C++11 开始为线程安全的初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="保护不常更新的数据结构" class="headerLink">
    <a href="#%e4%bf%9d%e6%8a%a4%e4%b8%8d%e5%b8%b8%e6%9b%b4%e6%96%b0%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-mark"></a>保护不常更新的数据结构</h4><p>当有不常更新的数据结构时，我们希望在修改时线程可以独占并安全的修改内容，完成修改后可以并发的安全访问数据。使用 ::std::mutex 来保护这样的数据结构对于性能来说并不是一个很好的方法，这会削弱读取数据的性能。我们可以想象这样一种互斥量，它可以在
<strong>写</strong> 线程中独占访问，而允许 <strong>读</strong> 线程并发访问，这样的互斥量被称为 <strong>读写锁</strong>​，读线程需要等写线程释放锁后才可以并发访问，而写线程必须等全部读线程放弃互斥量后才可以独占访问。</p>
<p>C++17标准库提供了 <code>::std::shared_mutex</code> (头文件 <em>shared_mutex</em> 中)，C++14提供了
RAII模板类 <code>::std::shared_lock</code> 与有时限的读写锁 <code>::std::shared_timed_mutex</code> (头文件
<em>shared_mutex</em> 中)，可惜的是C++11中并没有提供相应的设施。timed_mutex系列互斥量相比普通互斥量，多了时限功能，在时限内可以获得锁则返回true并获得锁，否则返回false
并不能获得锁，不过普通的互斥量则相较有更高的性能。在读写锁的使用中，对于写线程可以使用 <code>::std::lock_guard&lt;::std::shared_mutex&gt;</code> 或 <code>::std::unique_lock&lt;::std::shared_mutex&gt;</code>
进行RAII管理，它们与普通的互斥量行为一致；对于读线程，则需要
<code>::std::shared_lock&lt;::std::shared_mutex&gt;</code> 进行RAII管理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">DnsCache</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="err">，</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">entries_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">mu_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu_</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">entries_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">entries_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">?</span> <span class="s">&#34;&#34;</span> <span class="o">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">,</span> <span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu_</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">entries_</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="重入锁" class="headerLink">
    <a href="#%e9%87%8d%e5%85%a5%e9%94%81" class="header-mark"></a>重入锁</h4><p>在一个线程上，对已上锁的 ::std::mutex 再次上锁是错误的，会引起未定义行为，如果希望在线程上对一个互斥量在释放前进行多次上锁，则需要使用 <code>::std::recursive_mutex</code> (头文件 <em>mutex</em> 中)。当然要牢记，你对其上锁了多少次，那一定需要解锁多少次，否则就会出现锁死其他线程的情况 (请善用 ::std::lock_guard 与 ::std::unique_lock)</p>
<h2 id="同步操作" class="headerLink">
    <a href="#%e5%90%8c%e6%ad%a5%e6%93%8d%e4%bd%9c" class="header-mark"></a>同步操作</h2><h3 id="等待条件" class="headerLink">
    <a href="#%e7%ad%89%e5%be%85%e6%9d%a1%e4%bb%b6" class="header-mark"></a>等待条件</h3><p>通过一条线程触发等待事件的机制是最基本的唤醒方式，这种机制被称为 <strong>条件变量</strong>​，条件变量与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程，终止线程会向等待着的线程广播信息。</p>
<p>C++标准库实现了条件变量 (头文件 <em>condition_variable</em> 中)
<code>::std::condition_variable</code> 和 <code>::std::condition_variable_any</code> ，它们需要与互斥量一起才能工作，前者需要和 ::std::mutex 一起工作，而 _any 后缀的条件变量可以和任何互斥量一起，但是相比普通条件变量更消耗系统资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">data_chunk</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">preparation</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">more</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">const</span> <span class="n">data_chunk</span> <span class="n">data</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">processing</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
</span></span><span class="line"><span class="cl">	<span class="n">data_chunk</span> <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">is_last_chunk</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>以上代码就是一个条件变量的应用，执行情况如下</p>
<ol>
<li>preparation 线程将获取数据，上锁互斥量并将数据压入队列</li>
<li>processing 线程必须对互斥量进行锁定，之后才能调用条件变量的成员函数 wait()
检查条件谓词，如果成立则继续，如果不成立将解锁互斥量并阻塞当前线程</li>
<li>preparation 线程调用 notify_one() 会唤醒 <strong>一个正在等待</strong> 的线程，调用后需要解锁互斥量，如果没有等待线程则无事发生，notify_one() 不会唤醒调用后开始等待的线程</li>
<li>如果 processing 线程被唤醒，则会重新获取锁，并再次进行条件谓词的检查</li>
</ol>
<p>条件变量调用wait()的过程中，可能会多次检查条件谓词，并在谓词为true的情况下立即返回。另一点，等待线程可能会在不被其他线程通知的情况下被唤醒，这被称为 <strong>虚假唤醒</strong>​，而虚假唤醒的数量和频率都是不确定的，所以条件谓词不建议有副作用。</p>
<h3 id="future" class="headerLink">
    <a href="#future" class="header-mark"></a>future</h3><p>当线程需要等待特定事件时，某种程度上来说就需要知道期望的结果，线程会周期性的等待或检查事件是否触发，检查期间也会执行其他任务。另外，等待任务期间也可以先执行另外的任务，直到对应的任务触发，而后等待future的状态会变为就绪状态。future可能是和数据相关，也可能不是，当事件发生时，这个future就不能重置了。</p>
<p>C++标准库提供了两种future (头文件 <em>future</em> 中) <code>::std::future</code> 和
<code>::std::shared_future</code>​，它们与智能指针 ::std::shared_ptr 和 ::std::unique_ptr 十分类似。::std::future 只能与指定事件相关连，而 ::std::shared_future 可以关联多个事件，而实现中所有实例会同时变为就绪状态，并且可以访问与事件相关的数据。如果希望future与数据无关，则可以使用 <strong>void</strong> 的特化。future 像是线程通信，但是其本身并不提供同步访问，如果需要访问独立的future对象时则需要使用互斥量或类似同步机制进行保护，::std::shared_future 提供访问异步操作结果的机制，每个线程可以安全的访问自身
::std::shared_future 对象的副本。</p>
<h4 id="异步返回值" class="headerLink">
    <a href="#%e5%bc%82%e6%ad%a5%e8%bf%94%e5%9b%9e%e5%80%bc" class="header-mark"></a>异步返回值</h4><p>我们可以使用 <code>::std::async</code> (头文件 <em>future</em> 中) 和 ::std::future 启动一个异步任务，获取线程的返回值，当然等待返回值的线程会阻塞，直到 ::std::future 就绪为止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">async_func</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">async_func</span><span class="p">);</span> <span class="c1">// 异步执行 async_func
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">do_something</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Return: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">flush</span> <span class="c1">// 立即打印
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 阻塞，直到 future 就绪
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>::std::future 是否需要等待取决于绑定的 ::std::async 是否启动一个线程，或是否有任务正在进行，大多数情况下在函数调用之前可以传递一个 <code>::std::launch</code> 类型的对象</p>
<dl>
<dt>::std::launch::defered</dt>
<dd>惰性求值，延迟到 wait() 或 get() 时进行求值</dd>
<dt>::std::launch::async</dt>
<dd>异步求值，求值将在一个独立的线程上进行</dd>
<dt>::std::launch::async \(|\) ::std::luanch::defered</dt>
<dd>默认行为，惰性求值或异步求值，具体求值方式由实现定义</dd>
</dl>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">f0</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">func0</span><span class="p">);</span> <span class="c1">// 异步求值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">defered</span><span class="p">,</span> <span class="n">func1</span><span class="p">);</span> <span class="c1">// 惰性求值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span> <span class="o">|</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">defered</span><span class="p">,</span> <span class="n">func2</span><span class="p">);</span> <span class="c1">// 求值方式由实现定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">func3</span><span class="p">);</span> <span class="c1">// 求值方式由实现定义
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="绑定任务" class="headerLink">
    <a href="#%e7%bb%91%e5%ae%9a%e4%bb%bb%e5%8a%a1" class="header-mark"></a>绑定任务</h4><p><code>::std::packaged_task</code> (头文件 <em>future</em> 中) 允许将 future 与可调用对象进行绑定，::std::packaged_task 的模板参数是一个可调用类型，在调用 ::std::packaged_task 时就会调用相关函数，而 future 状态就绪时则会存储返回值，通过 get_future() 获取绑定的 future 对象。</p>
<h4 id="promise" class="headerLink">
    <a href="#promise" class="header-mark"></a>Promise</h4><p>大部分并发编程语言都实现了 <strong>Promise/Future</strong> 结构，起源于函数式编程和相关范例，目的是将值与其计算方式分离，从而允许更灵活地进行计算，特别是通过并行化。后来它在分布式计算中得到了应用，减少了通信往返的延迟。future是变量的 <strong>只读</strong> 占位符视图，而
promise是 <strong>可写</strong> 的单赋值容器，用于设置future的值。</p>
<p>类模板 <code>::std::promise</code> (头文件 <em>future</em> 中) 提供存储值或异常的设施，之后通过
::std::promise 对象所创建的 ::std::future 对象异步获得结果。::std::future 会阻塞等待线程，::std::promise 则会设置结果并将关联的 ::std::future 对象设置为就绪状态，不过
std::promise 只应当使用一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">accumulate</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">work_thread</span><span class="p">(</span><span class="n">accumulate</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">			      <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">accumulate_promise</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 等待结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>::std::shared_future 可用于同时向多个线程发信息, 类似于
<code>::std::condition_variable::notify_all()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready_promise</span><span class="p">,</span> <span class="n">t1_promise</span><span class="p">,</span> <span class="n">t2_promise</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready_future</span><span class="p">{</span><span class="n">ready_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">()};</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">high_resolution_clock</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">milli</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			    <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ready_future</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">milli</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">t1_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="n">ready_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// 等待来自 main() 的信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">result2</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			    <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ready_future</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">milli</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">t2_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">				<span class="n">ready_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// 等待来自 main() 的信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">return</span> <span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			    <span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="n">t1_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">t2_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">ready_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 1 received the signal &#34;</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="n">result1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; ms after start</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 2 received the signal &#34;</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="n">result2</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; ms after start</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="限时等待" class="headerLink">
    <a href="#%e9%99%90%e6%97%b6%e7%ad%89%e5%be%85" class="header-mark"></a>限时等待</h3><p>阻塞调用会将线程挂起一段不确定的时间，直到相应的事件发生，通常情况下这样的方式很不错，但是在一些情况下，需要限定线程等待的时间。</p>
<p>通常有两种指定超时方式：一种是 <strong>时间段</strong>​，另一种是 <strong>时间点</strong>​。第一种方式，需要指定一段时间；第二种方式，就是指定一个时间点。多数等待函数提供变量，对两种超时方式进行处理，处理持续时间的变量 (<strong>时间段</strong>) 以 <code>_for</code> 作为后缀，处理绝对时间的变量
(时间戳) 以 <code>_until</code> 作为后缀。</p>
<h4 id="时钟" class="headerLink">
    <a href="#%e6%97%b6%e9%92%9f" class="header-mark"></a>时钟</h4><p>时钟就是时间信息源，一个时钟的当前时间可由静态成员函数 <code>now()</code> 获取，特定的时间点的类型是成员类型 <code>time_point</code> 。时钟节拍被指定为1/x秒，这是由时间周期所决定，当时钟节拍均匀分布且不可修改时这种时钟被称为稳定时钟。</p>
<h4 id="时间段" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e6%ae%b5" class="header-mark"></a>时间段</h4><p>时间段 <code>::std::chrono::duration</code> (头文件 <em>chrono</em> 中) 由 Rep 类型的 <strong>计次数</strong> 和
Period 类型的 <strong>计次周期</strong> 组成，计次周期是一个编译期有理数常量，表示从一个计次到下一个的秒数，比如分钟的类型可以使用 <code>::std::chrono::duration&lt;long long, ::std::ratio&lt;60, 1&gt;&gt;</code> 表示，而毫秒的类型可以使用 <code>::std::chrono::duration&lt;long long, ::std::ratio&lt;1, 1000&gt;&gt;</code> 表示。不过为了方便起见，标准库定义了辅助类型来简化使用</p>
<ul>
<li><strong>::std::chrono::nanoseconds</strong> (纳秒)</li>
<li><strong>::std::chrono::microseconds</strong> (微秒)</li>
<li><strong>::std::chrono::milliseconds</strong> (毫秒)</li>
<li><strong>::std::chrono::seconds</strong> (秒)</li>
<li><strong>::std::chrono::minutes</strong> (分)</li>
<li><strong>::std::chrono::hours</strong> (时)</li>
</ul>
<p>C++20开始，标准库又增加了天、周、月、年来方便使用时间段。</p>
<p>C++14 中，​<code>::std::literals</code> 中定义了一些 duration 字面量方便使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="k">using</span> <span class="k">namespace</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">one_day</span> <span class="o">=</span> <span class="mi">24</span><span class="n">h</span><span class="p">;</span> <span class="c1">// 24小时
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">half_an_hour</span> <span class="o">=</span> <span class="mi">30</span><span class="n">min</span><span class="p">;</span> <span class="c1">// 30分钟
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">five_seconds</span> <span class="o">=</span> <span class="mi">5</span><span class="n">s</span><span class="p">;</span> <span class="c1">// 5秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">one_second</span> <span class="o">=</span> <span class="mi">1000</span><span class="n">ms</span><span class="p">;</span> <span class="c1">// 1000毫秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">ten_micros</span> <span class="o">=</span> <span class="mi">10u</span><span class="n">s</span><span class="p">;</span> <span class="c1">// 10微秒
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">auto</span> <span class="n">two_nanos</span> <span class="o">=</span> <span class="mi">2</span><span class="n">ns</span><span class="p">;</span> <span class="c1">// 2纳秒
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="时间戳" class="headerLink">
    <a href="#%e6%97%b6%e9%97%b4%e6%88%b3" class="header-mark"></a>时间戳</h4><p>时间戳 <code>::std::chrono::time_point</code> (头文件 <em>chrono</em> 中) 由 Clock 类型的 <strong>时钟</strong> 和
Duration 类型的 <strong>时钟间隔</strong> 组成，并且可以通过算术运算调整时间戳。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">time_t</span> <span class="n">now_c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">hours</span><span class="p">(</span><span class="mi">24</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;24 hours ago, the time was &#34;</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_c</span><span class="p">),</span> <span class="s">&#34;%F %T&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Printing took &#34;</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&lt;&lt;</span> <span class="s">&#34;us.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 24 hours ago, the time was 2020-12-03 23:47:43
</span></span></span><span class="line"><span class="cl"><span class="c1">// Hello World
</span></span></span><span class="line"><span class="cl"><span class="c1">// Printing took 4us.
</span></span></span></code></pre></td></tr></table>
</div>
</div></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 04-07</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/2020/cpp_concurrency_std/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span><span>|&nbsp;<a class="link-to-report" href=https://gitlab.com/GinShio/ginshio.gitlab.io/issues/new?issue[title]=[BUG]%20%E5%B9%B6%E5%8F%91%E6%A0%87%E5%87%86%E5%BA%93&issue[description]=[POST](https://blog.ginshio.org/2020/cpp_concurrency_std/)%0A%0A##%20Isseus%0A target="_blank" rel="noopener noreferrer">报告问题</a>
                    </span></div>
            <div class="post-info-share">
                <span><a href="#" onclick="return false;" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库" data-hashtags="Note,C&#43;&#43;,Concurrency,Library"><i class="fab fa-twitter fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-hashtag="Note"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/"><i class="fab fa-linkedin fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" onclick="return false;" title="分享到 Telegram" data-sharer="telegram" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库" data-web><i class="fab fa-telegram-plane fa-fw"></i></a><a href="#" class="weixin" onclick="return false;" title="分享到 微信" data-sharer="weixin" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="并发标准库" data-web><i class="fab fa-weixin fa-fw"></i><img src="https://api.oick.cn/qrcode/api.php?size=256&amp;text=https://blog.ginshio.org/2020/cpp_concurrency_std/" title="并发标准库">
    </a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/note/">Note</a>,&nbsp;<a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>,&nbsp;<a href="/tags/concurrency/">Concurrency</a>,&nbsp;<a href="/tags/library/">Library</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2020/mail_server/" class="prev" rel="prev" title="搭建邮箱服务器"><i class="fas fa-angle-left fa-fw"></i>搭建邮箱服务器</a>
            <a href="/2020/cpp_concurrency_atomic/" class="next" rel="next" title="原子操作">原子操作<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.102.3">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank" rel="noopener noreferrer"> </a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.b250718923eb2b3c2ba2de589fcc7f623ebf3efa17f0e501e7de204156024b108524ffafaf0958fd09d3b68cf0412999.css" integrity="sha384-slBxiSPrKzwrot5Yn8x/Yj6/PvoX8OUB594gQVYCSxCFJP&#43;vrwlY/QnTtozwQSmZ"><link rel="stylesheet" href="/lib/katex/katex.min.bcaaee8fe6b5dd4f321c8900c8680ad49dc0ad32f3ac51816c1734b43a7869dfc4c9ec0449e5c4fc8bfaec08fc80a674.css" integrity="sha384-vKruj&#43;a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"96cbbb15f26bebd9141b","clientSecret":"29c7df99d6e1806113996333163a9476027ff1fa","id":"2020-12-01T19:42:25+08:00","owner":"GinShio","repo":"ginshio.github.io","title":"并发标准库"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"ABF13CGNA0","algoliaIndex":"ginshio_blog","algoliaSearchKey":"51cf3425aba132c091b477c3d5e06eea","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"sharerjs":true,"table":{"sort":true}};</script><script type="text/javascript" src="/lib/gitalk/gitalk.min.1420a0c0459673bc6824e7ba713f1e0ec1540e86491daf1b6149a7af9cd3f396c86b9182d03e4c727faefae17b746033.js" integrity="sha384-FCCgwEWWc7xoJOe6cT8eDsFUDoZJHa8bYUmnr5zT85bIa5GC0D5Mcn&#43;u&#43;uF7dGAz"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.dd4cfdb9c1bcaa687c9794e0620c478af43dec711c465b0560c274a0c20d6023bc183b8817015eb778ab746927905d6e.js" integrity="sha384-3Uz9ucG8qmh8l5TgYgxHivQ97HEcRlsFYMJ0oMINYCO8GDuIFwFet3irdGknkF1u"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.cd363f7498fd08d5e75d97ca1f2510d87d073b35592ba69016728082f8e5e9db33b432643010810a6e88152c4f650059.js" integrity="sha384-zTY/dJj9CNXnXZfKHyUQ2H0HOzVZK6aQFnKAgvjl6dsztDJkMBCBCm6IFSxPZQBZ"></script><script type="text/javascript" src="/lib/tablesort/tablesort.min.d120034e53740430f5243f8e25b646e7bdcca97780e02962c37e3adefb264c1b457f8fc397698851f42e32d7168bdd1e.js" integrity="sha384-0SADTlN0BDD1JD&#43;OJbZG573MqXeA4Cliw3463vsmTBtFf4/Dl2mIUfQuMtcWi90e"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/katex/katex.min.3f04544ff62a6e71239193b4cd9c4da9cc400ab5defa3efae94d9a997720320e78e7baef7b663b23a6494a6d80d264b8.js" integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe&#43;j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f95071777afa5e0511c9caad675d7b9d8c38e0e39c21ac79e99e1d09159bc723edd0aa1a875b87a0ad28e3efd1444d39.js" integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.c30ff9f376878715a4cf90c4567e8e2ad36221a2e2da20513595df251898d408bbb6727d517a44b32bce2135694e5e00.js" integrity="sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.453374f1ad005c88a83c1715a2c12a3d47ca2beacfa7e875c7f8b347bc4c91d332bb091c64259dc4ef914b0205b495cd.js" integrity="sha384-RTN08a0AXIioPBcVosEqPUfKK&#43;rPp&#43;h1x/izR7xMkdMyuwkcZCWdxO&#43;RSwIFtJXN" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-J5NHMZLLDX', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-J5NHMZLLDX" async></script><script>
			var _hmt = _hmt || [];
			(function() {
			  var hm = document.createElement("script");
			  hm.src = "https://hm.baidu.com/hm.js?9370523af547bac6b97e9c3b1461cd16";
			  var s = document.getElementsByTagName("script")[0]; 
			  s.parentNode.insertBefore(hm, s);
			})();
		</script></div>
</body>

</html>